<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta name="description" content="这是我的小栈，记录点滴">
<meta property="og:type" content="website">
<meta property="og:title" content="程序小栈">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="程序小栈">
<meta property="og:description" content="这是我的小栈，记录点滴">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="程序小栈">
<meta name="twitter:description" content="这是我的小栈，记录点滴">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"right","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/">





  <title>程序小栈</title>
  








</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-right 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">程序小栈</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/11/09/渗透测试---信息搜集初识/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="WeiQingcai">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/head_logo.png">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="程序小栈">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/11/09/渗透测试---信息搜集初识/" itemprop="url">渗透测试---信息搜集初识</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-11-09T16:49:37+08:00">
                2018-11-09
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/网络安全/" itemprop="url" rel="index">
                    <span itemprop="name">网络安全</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="渗透测试—信息搜集初识"><a href="#渗透测试—信息搜集初识" class="headerlink" title="渗透测试—信息搜集初识"></a>渗透测试—信息搜集初识</h2><h3 id="一-外围信息搜集方式"><a href="#一-外围信息搜集方式" class="headerlink" title="一. 外围信息搜集方式"></a><strong>一. 外围信息搜集方式</strong></h3><ol>
<li><strong>使用whois 进行域名注册信息查询</strong></li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">whois [域名]</span><br></pre></td></tr></table></figure>
<p>注：使用whois查询时需要去掉www，ftp等前缀</p>
<ol start="2">
<li><strong>使用nslookup与dig查询域名注册信息</strong></li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.  nslookup</span><br><span class="line">2.  set type=A           //（参数A表示查询IP地址，MX表示邮件转发）</span><br><span class="line">	set [域名]</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1.  dig @[DNS服务器][待查询域名]</span><br></pre></td></tr></table></figure>
<p>注：nslookup和dig的区别在于：nslookup得到的是DNS解析服务器保存在Cache中的非权威解答，而dig则是可以指定DNS解析服务器向官方权威DNS服务器进行查询</p>
<ol start="3">
<li><strong>使用IP2Location进行地理位置查询，网站信息查询，反查域名等</strong></li>
</ol>
<p>一些网站提供IP地址到地理位置的查询服务，网站的信息查询等服务，可以进行信息的搜集。对于一些虚拟主机，可以通过域名反查来获取信息。</p>
<ol start="4">
<li><strong>使用搜索引擎进行信息搜集</strong><ol>
<li>使用Google Hacking技术，以及一些自动化工具来进行查询，如SiteDigger和Search Diggity</li>
<li>通过在Google中输入parent directory site：[域名]来查询网站的目录</li>
<li>通过在Google中输入site：[域名] filetype：[文件类型名]来查询特定的文件</li>
<li>通过使用Metasploit中的辅助模块search_email_collector来进行邮件地址搜集</li>
<li>通过在Google中输入site:[域名] inurl:[关键字]来查询易存在SQL注入点的页面</li>
</ol>
</li>
</ol>
<h3 id="二-主机探测与端口扫描"><a href="#二-主机探测与端口扫描" class="headerlink" title="二.  主机探测与端口扫描"></a><strong>二.  主机探测与端口扫描</strong></h3><ol>
<li><strong>ICMP Ping命令</strong></li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ping [域名或IP地址]</span><br></pre></td></tr></table></figure>
<ol start="2">
<li><strong>Metasploit的主机发现模块</strong></li>
</ol>
<p>Metasploit中提供了一些辅助模块用于发现活跃的主机，位于Metasploit的modules/auxiliary/scanner/discovery/目录下。其中arp_sweep与udp_sweep两个模块最常用</p>
<ol start="3">
<li><strong>使用Nmap进行主机探测及系统识别</strong></li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nmap [扫描选项][扫描目标地址] //可以扫描单个地址或者是一个地址段</span><br><span class="line">nmap -o [目标IP地址] -A     //-o参数可以识别目标地址的系统类型，-A可以得到更加详细信息</span><br></pre></td></tr></table></figure>
<ol start="4">
<li><p><strong>端口扫描与服务类型探测</strong></p>
<ol>
<li>Metasploit中的端口扫描器，Metasploit中的auxiliary/scanner/portscan/中提供了多种端口扫描器</li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1. ack: 通过ack扫描的方式对防火墙上未被屏蔽的端口进行探测</span><br><span class="line">2. ftpbounce： 通过ftp bounce攻击的原理对TCP服务进行枚举</span><br><span class="line">3. syn： 使用发送TCP SYN标志的方式探测开放端口</span><br><span class="line">4. tcp： 通过一次完整的TCP链接过程来探测端口是否开放，准确度最高，但速			度很慢</span><br><span class="line">5. xmans： 一种更为隐秘的扫描方式，通过发送FIN，PSH和URG标志，能够躲				避一些TCP标记检测器的过滤</span><br></pre></td></tr></table></figure>
<p>​</p>
<ol start="2">
<li>nmap端口扫描：</li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">nmap [扫描参数] [扫描选项] [扫描地址]</span><br><span class="line">1）常见扫描参数：</span><br><span class="line">	 	1.  -sT:Tcp connect 扫描，类似于Metasploit中的tcp扫描模块</span><br><span class="line">	 	2.  -sS:TCP SYN扫描，类似于Metasploit中的syn扫描模块</span><br><span class="line">	 	3.  -sF/-sX/-sN:通过发送一些特殊的标记位来避开一些设备或者软件的监测</span><br><span class="line">	 	4.  -sP：通过发送ICMP echo请求探测主机是否存活，原理同ping</span><br><span class="line">	 	5.  -sU：探测目标主机开放了哪些UDP端口</span><br><span class="line">	 	6.  -sA：TCP ACK扫描，类似于Metasploit中的ack扫描模块</span><br><span class="line">	 	7.  -sV：获取更加详细的服务版本等信息</span><br><span class="line">2）常见扫描选项：</span><br><span class="line">		-Pn：在扫描之前不发送ICMP echo测试目标是否活跃</span><br><span class="line">		-O：启用对于TCP/IP协议栈的指纹特征扫描以获得远程主机的操作系统类型等信息</span><br><span class="line">		-F：快速扫描模式，只扫描在nmap-services中列出的端口</span><br><span class="line">		-p[端口范围]：可以使用这个参数指定希望扫描的端口</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="三-服务扫描与查点"><a href="#三-服务扫描与查点" class="headerlink" title="三. 服务扫描与查点"></a><strong>三. 服务扫描与查点</strong></h3><ol>
<li><strong>Telnet服务扫描</strong></li>
</ol>
<p>Metasploit中提供了Telnet服务扫描的模块，该模块位于auxiliary/scanner/telnet/telnet_version，可以通过该模块探查目标主机的telnet版本</p>
<ol start="2">
<li><strong>SHH服务扫描</strong></li>
</ol>
<p>Metasploit同样提供了对于SSH服务的扫描木块，该模块位于auxiliary/scanner/ssh/ssh_version。</p>
<ol start="3">
<li><strong>Oracle数据库查点</strong></li>
</ol>
<p>Metasploit提供对于Oracle数据库的扫描，该模块位于auxiliary/scanner/oracle/tnslsnr_version。</p>
<ol start="4">
<li><strong>开放代理与利用</strong></li>
</ol>
<p>Metasploit提供用于隐藏自己地址的代理服务，该模块位于auxiliary/scanner/http/open_proxy，可以使用该模块设置自己的代理服务</p>
<ol start="5">
<li><strong>口令猜测和嗅探</strong><ol>
<li>SSH口令猜测：Metasploit提供了用于猜测SSH口令的模块，通过设置高质量的密码字典可以有效的破解弱口令密码，该模块位于auxiliary/scanner/ssh/ssh_login</li>
<li>psnuffle口令嗅探：Metasploit提供了一个用于口令嗅探的工具，可以截获常见协议的身份认证过程，并记录用户名和口令，该模块位于auxiliary/sniffer/psnuffle</li>
</ol>
</li>
</ol>
<h3 id="三-网络漏洞扫描"><a href="#三-网络漏洞扫描" class="headerlink" title="三. 网络漏洞扫描"></a><strong>三. 网络漏洞扫描</strong></h3><p><strong>1.  使用Nessus</strong></p>
<p>Nessus提供完整的电脑端漏洞扫描服务，并会及时更新漏洞数据库。同时不同于传统的漏洞扫描工具，Nessus提供同时在本机和远程端上得控制，在命令行的基础上也提供图形化操作界面。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1.  启动Nessus</span><br><span class="line">	nessusd start</span><br><span class="line">2.  激活Nessus</span><br><span class="line">	nessus -fetch --register [激活码]</span><br><span class="line">3.  添加用户</span><br><span class="line">	nessus -add user</span><br></pre></td></tr></table></figure>
<p><strong>2.  使用OpenVAS</strong></p>
<p>OpenVAS常用来评估目标主机上得漏洞，是Nessus项目的一个分支，提供完全免费的服务。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">1.  配置OpenVAS</span><br><span class="line">	openvas-mkcert</span><br><span class="line">2.  同步OpenVAS NVT数据库</span><br><span class="line">	openvas-nvt-sync</span><br><span class="line">3.  创建客户端证书库</span><br><span class="line">	openvas-mkcert-client -n [用户名] -i</span><br><span class="line">4.  重建数据库</span><br><span class="line">	openvasmd -rebuild</span><br><span class="line">5.  启动openvas并加载插件</span><br><span class="line">	openvassd</span><br><span class="line">6.  创建数据库备份</span><br><span class="line">	openvasmd -backup</span><br><span class="line">7.  创建管理账户</span><br><span class="line">	openvasad -c 'add_user' -n [账户名] -r Admin</span><br><span class="line">8.  创建普通账户</span><br><span class="line">	openvasad -adduser</span><br><span class="line">9.  为openvas配置端口</span><br><span class="line">	openvasmd -p [端口号] -a [IP地址]</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/11/09/Android自动化测试/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="WeiQingcai">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/head_logo.png">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="程序小栈">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/11/09/Android自动化测试/" itemprop="url">Android自动化测试</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-11-09T16:49:37+08:00">
                2018-11-09
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index">
                    <span itemprop="name">Android</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Android自动化测试"><a href="#Android自动化测试" class="headerlink" title="Android自动化测试"></a>Android自动化测试</h1><blockquote>
<ol>
<li>adb shell monkey -p package [事件数]</li>
</ol>
</blockquote>
<p>用于对指定包名的应用进行压力测试</p>
<blockquote>
<ol start="2">
<li>adb logcat | find “标签字符串”</li>
</ol>
</blockquote>
<p>用于将logcat中的命令输出到控制台</p>
<blockquote>
<ol start="3">
<li>adb shell monkey –throttle [milliseconds]</li>
</ol>
</blockquote>
<p>每步操作之间间隔时长为 milliseconds</p>
<blockquote>
<ol start="4">
<li>adb shell monkey -s seed [event-count]</li>
</ol>
</blockquote>
<p>指定一个随机生成的值，每一个随机值确定一组相同的随机操作</p>
<blockquote>
<ol start="5">
<li>adb shell monkey –ptc-touch [percent]</li>
</ol>
</blockquote>
<p>设定一组monkey事件组中触摸事件所占百分比</p>
<blockquote>
<ol start="6">
<li>adb shell monkey –ptc-motion [percent]</li>
</ol>
</blockquote>
<p>设定一组monkey事件组中动作事件所占百分比</p>
<blockquote>
<ol start="7">
<li>adb shell monkey –ptc-trackball [percent]</li>
</ol>
</blockquote>
<p>设定一组monkey事件组中轨迹球事件所占百分比</p>
<blockquote>
<ol start="8">
<li>adb shell monkey –ptc-nav [percent]</li>
</ol>
</blockquote>
<p>设定一组monkey事件组中基本导航事件所占百分比</p>
<blockquote>
<ol start="9">
<li>adb shell monkey –ptc-majornav [percent]</li>
</ol>
</blockquote>
<p>设定一组monkey事件组中主要导航事件所占百分比</p>
<blockquote>
<ol start="10">
<li>adb shell monkey –ptc-syskeys [percent]</li>
</ol>
</blockquote>
<p>设定一组monkey事件组中系统导航事件所占百分比</p>
<blockquote>
<ol start="11">
<li>adb shell monkey –ptc-appswitch [percent]</li>
</ol>
</blockquote>
<p>设定一组monkey事件组中启动Activity事件所占百分比</p>
<blockquote>
<ol start="12">
<li>adb shell monkey –ptc-anyevent [percent]</li>
</ol>
</blockquote>
<p>设定一组monkey事件组中不常用事件所占百分比</p>
<blockquote>
<ol start="13">
<li>adb shell monkey –ignore-crashs [event-count]</li>
</ol>
</blockquote>
<p>忽略崩溃事件继续进行测试</p>
<blockquote>
<ol start="13">
<li>adb shell monkey –ignore-timeout [event-count]</li>
</ol>
</blockquote>
<p>忽略ANR事件继续进行测试</p>
<blockquote>
<ol start="14">
<li>adb shell monkey -f [scriptfile] [event-count] </li>
</ol>
</blockquote>
<p>执行monkey脚本</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/11/09/CCNA考试复习总结/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="WeiQingcai">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/head_logo.png">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="程序小栈">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/11/09/CCNA考试复习总结/" itemprop="url">CCNA考试复习总结</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-11-09T16:49:37+08:00">
                2018-11-09
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/计算机网络/" itemprop="url" rel="index">
                    <span itemprop="name">计算机网络</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="CCNA考试复习总结"><a href="#CCNA考试复习总结" class="headerlink" title="CCNA考试复习总结"></a>CCNA考试复习总结</h1><ul>
<li><p>设置默认网关：ip default-network [网关IP地址]或者是：ip route [源ip地址]  [ 子 网 掩码] [下一跳ip地址]</p>
</li>
<li><p>为需要远程管理的交换机进行配置：</p>
<ul>
<li>ip default-getway [网关地址]</li>
<li>interface vlan 1</li>
<li>ip address [需要远程管理的交换机的ip] [掩码]</li>
<li>no shutdown</li>
</ul>
</li>
<li><p>网络不可连接时的检查步骤：</p>
<ul>
<li>检查网络连接是否正常</li>
<li>验证网卡配置</li>
<li>验证IP配置</li>
<li>检查URL是否正确</li>
</ul>
</li>
<li><p>四种不同的线：</p>
<ul>
<li>同种设备使用交叉反线（crossover）</li>
<li>异种设备间使用直通线（straight through）</li>
<li>PC的COM口连接交换机的console口使用全反电缆（rollover cable）</li>
<li>连接带有串口的串行线（serial）</li>
</ul>
</li>
<li><p>名词解释：</p>
<ul>
<li>CIR：约定信息速率</li>
<li>DCE：数据通讯设备</li>
<li>DTE：数据终端设备</li>
<li>LMI：本地管理接口</li>
<li>PVC：永久虚拟电路</li>
<li>SVC：虚电路</li>
<li>DLCI：数据链路标识符</li>
<li>PVST+：增强的按VLAN生成树</li>
</ul>
</li>
<li><p>几种协议的管理距离：</p>
<ul>
<li>RIP：120</li>
<li>OSPF：110</li>
<li>静态路由：1</li>
<li>内部EIGRP：90</li>
<li>外部EIGRP：170</li>
<li>内部BGP：200</li>
<li>EGP：140</li>
<li>EIGRP路由汇总：5</li>
<li>外部BGP：20</li>
<li>IGRP：100</li>
<li>IS-IS自制系统：115</li>
<li>EGP：140</li>
<li>直连网络：0</li>
</ul>
</li>
<li><p>组播地址：</p>
<ul>
<li>IPV4：224.0.0.2</li>
<li>IPV6：FF02：：2</li>
</ul>
</li>
<li><p>本地地址：</p>
<ul>
<li>IPV4:127.0.0.1</li>
<li>IPV6： FE80开头 + {本地的MAC地址}</li>
</ul>
</li>
<li><p>查看CPU使用率：show process</p>
</li>
<li><p>查看trunk端口：</p>
<ul>
<li>show interface trunk</li>
<li>show interface switchport</li>
</ul>
</li>
<li><p>交换机在trunk模式下的模式：</p>
<ul>
<li>auto：不会主动发送DTP信息</li>
<li>on：强制称为trunk，也会主动发送信息</li>
<li>desireable：DTP主动模式，发DTP和对方协商</li>
</ul>
</li>
<li><p>STP（802.1d）端口状态：</p>
<ul>
<li>阻塞(blocking)该端口被阻塞，不可以转发或接收数据包</li>
<li>监听(listening)该端口正在等待接收bpdu数据包，bpdu可能告知该端口重新回到阻塞状态</li>
<li>学习(learning)该端口正在向其转发数据库中添加地址，但是，并不转发数据包</li>
<li>转发(forwarding)该端口正在转发数据包</li>
<li>失效(disabled)该端口只是相应网管消息，并且必须先转到阻塞状态</li>
</ul>
</li>
<li><p>RSTP（802.1w）端口状态：</p>
<ul>
<li>禁止（Discarding）</li>
<li>学习（Learning）</li>
<li>转发（Forwarding）</li>
</ul>
</li>
<li><p>IPV6任播的三个特点：</p>
<ul>
<li>数据包传送到该组接口，转发到最近结点</li>
<li>同组中多个接口公用一个地址</li>
<li>发送到任播地址的接口被发送到最近的结点</li>
</ul>
</li>
<li><p>Trunk的协议：</p>
<ul>
<li>通用的802.1q</li>
<li>思科私有的ISL</li>
</ul>
</li>
<li><p>IPV4向IPV6转换的方式：</p>
<ul>
<li>隧道</li>
<li>双栈</li>
<li>NAT-PT</li>
</ul>
</li>
<li><p>DoD模型：</p>
<ul>
<li>Application</li>
<li>Host to Host</li>
<li>Internet</li>
<li>Network Access</li>
</ul>
</li>
<li><p>查看OSPF链路状态：show ip ospf database </p>
</li>
<li><p>OSPF中进程号范围为1-65535</p>
</li>
<li><p>DHCP中IP地址冲突解决方案：检测到IP地址冲突时，会将冲突的IP地址删除，直到冲突解决之后再将IP地址放回</p>
</li>
<li><p>查看端口安全状态：show port-security interface [端口名]</p>
</li>
<li><p>链路状态协议的特点：</p>
<ul>
<li>提供参看拓扑的命令</li>
<li>计算最短路径<br>-利用触发更新</li>
</ul>
</li>
<li><p>OSPF建立邻居关系的四个条件：</p>
<ul>
<li>区域ID一致</li>
<li>hello，dead时间一致</li>
<li>认证方式和认证密码一致</li>
<li>区域性质一致（都是普通区域或者是末节区域）</li>
</ul>
</li>
<li><p>在全局配置模式下查看直连设备：cdp run</p>
</li>
<li><p>EIGRP查看邻居关系：show ip eigrp neighbors</p>
</li>
<li><p>PAP采用两次握手机制，CHAP采用三次握手机制</p>
</li>
<li><p>PVC状态：</p>
<ul>
<li>ACTIVE：成功的端对端电路</li>
<li>INACTIVE：表示成功连接到交换机，但是在另一端未检测到DTE</li>
<li>配置的端口被交换机视为无效</li>
</ul>
</li>
<li><p>SNMPv3比SNMPv2多添加的：</p>
<ul>
<li>数据完整性</li>
<li>认证</li>
<li>加密</li>
</ul>
</li>
<li><p>系统日志存储位置：</p>
<ul>
<li>RAM</li>
<li>控制台终端</li>
<li>系统日志服务器</li>
</ul>
</li>
<li><p>系统日志级别：</p>
<ul>
<li>0：Emergency</li>
<li>1：Alert</li>
<li>2：Critical</li>
<li>3：Error</li>
<li>4：Warning</li>
<li>5：Notice</li>
<li>6：Informational</li>
<li>7：Debug</li>
</ul>
</li>
<li><p>HSRP的virtual mac address以0000.0c07.acxx开头</p>
</li>
<li><p>IPV6任播的三个特点：</p>
<ul>
<li>数据包转发到该组接口，转发到最近的结点</li>
<li>同组中多个接口公用一个地址</li>
<li>发到任播地址的包被转发到最近的结点</li>
</ul>
</li>
<li><p>IPV6地址：</p>
<ul>
<li>FF01::1 – all nodes（node-local）</li>
<li>FF01::2 – all routers(node-local)</li>
<li>FF02::1 – all nodes(link-local)</li>
<li>FF02::2 – all routers(link-local)</li>
<li>FF02::5 – OSPFv3 routers</li>
<li>FF02::6 – OSPFv3 designated routers</li>
<li>FF02::9 – RIP</li>
<li>FF02::A – EIGRP routers</li>
<li>FF02::B – Mobile agents</li>
<li>FF02::C – SSDP</li>
<li>FF02::D – all PIM routers</li>
<li>FF05::2 – all routers(site-local)</li>
<li>FF05::1:3 – DHCP</li>
</ul>
</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/11/09/MongoDB入门及问题总结/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="WeiQingcai">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/head_logo.png">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="程序小栈">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/11/09/MongoDB入门及问题总结/" itemprop="url">MongoDB使用入门及问题总结</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-11-09T16:49:37+08:00">
                2018-11-09
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/杂学/" itemprop="url" rel="index">
                    <span itemprop="name">杂学</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <ul>
<li><a href="#mongodb%E4%BD%BF%E7%94%A8%E5%85%A5%E9%97%A8%E5%8F%8A%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93">MongoDB使用入门及问题总结</a><ul>
<li><a href="#%E5%85%B3%E4%BA%8Emongodb">关于MongoDB</a><ul>
<li><a href="#%E5%8F%82%E8%80%83%E6%96%87%E6%A1%A3"><strong>参考文档：</strong></a></li>
<li><a href="#mongodb%E5%AE%98%E7%BD%91"><strong>MongoDB官网</strong></a></li>
<li><a href="#mongodb%E4%B8%AD%E6%96%87%E7%A4%BE%E5%8C%BA"><strong>MongoDB中文社区</strong></a></li>
<li><a href="#mongodb%E5%AE%98%E6%96%B9%E4%B8%AD%E6%96%87%E6%96%87%E6%A1%A3"><strong>MongoDB官方中文文档</strong></a></li>
<li><a href="#mongodb%E7%9A%84%E5%85%A5%E9%97%A8%E8%A7%86%E9%A2%91%E6%95%99%E7%A8%8B"><strong>MongoDB的入门视频教程</strong></a></li>
</ul>
</li>
<li><a href="#mongodb%E7%9A%84%E4%B8%8B%E8%BD%BD%E5%92%8C%E5%AE%89%E8%A3%85">MongoDB的下载和安装</a></li>
<li><a href="#mongodb%E7%9A%84%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98"><strong>MongoDB的遇到的问题</strong></a><ul>
<li><a href="#%E4%B8%80--%E5%AE%89%E8%A3%85%E5%AE%98%E6%96%B9%E4%B8%8B%E8%BD%BD%E7%9A%84msi%E7%9A%84%E6%97%B6%E5%80%99%E5%A7%8B%E7%BB%88%E6%8F%90%E7%A4%BA%E5%AE%89%E8%A3%85%E5%A4%B1%E8%B4%A5"><strong>一 . 安装官方下载的msi的时候始终提示安装失败</strong></a></li>
<li><a href="#%E4%BA%8C-%E9%85%8D%E7%BD%AEmongodb%E4%B8%BAwindow%E6%9C%8D%E5%8A%A1%E6%97%B6%E5%A4%B1%E8%B4%A5"><strong>二. 配置MongoDB为window服务时失败</strong></a></li>
<li><a href="#%E7%9B%B8%E5%85%B3%E5%8F%82%E8%80%83%E6%96%87%E7%AB%A0"><strong>相关参考文章</strong></a></li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="MongoDB使用入门及问题总结"><a href="#MongoDB使用入门及问题总结" class="headerlink" title="MongoDB使用入门及问题总结"></a>MongoDB使用入门及问题总结</h1><p>最近学习Python爬虫开发时需要使用MongoDB数据库，为此做个使用入门的介绍和所遇问题的总结。</p>
<h2 id="关于MongoDB"><a href="#关于MongoDB" class="headerlink" title="关于MongoDB"></a>关于MongoDB</h2><p>关于MongoDB的简介可以直接去官网查看，主要和传统的MySQL，SQL Server这些数据库的不同之处在于它是NoSql型数据库，即非关系型数据库。不同于MySQL中的数据都是一张张的关系表结构，MongoDB中的数据并不是以相互之间的关系表来存储的，所以这种数据的存储方式更适合复杂的爬虫环境。</p>
<h3 id="参考文档："><a href="#参考文档：" class="headerlink" title="参考文档："></a><strong>参考文档：</strong></h3><h3 id="MongoDB官网"><a href="#MongoDB官网" class="headerlink" title="MongoDB官网"></a><strong><a href="https://www.mongodb.com/" target="_blank" rel="noopener">MongoDB官网</a></strong></h3><h3 id="MongoDB中文社区"><a href="#MongoDB中文社区" class="headerlink" title="MongoDB中文社区"></a><strong><a href="http://www.mongoing.com/" target="_blank" rel="noopener">MongoDB中文社区</a></strong></h3><h3 id="MongoDB官方中文文档"><a href="#MongoDB官方中文文档" class="headerlink" title="MongoDB官方中文文档"></a><strong><a href="http://www.mongoing.com/docs/" target="_blank" rel="noopener">MongoDB官方中文文档</a></strong></h3><h3 id="MongoDB的入门视频教程"><a href="#MongoDB的入门视频教程" class="headerlink" title="MongoDB的入门视频教程"></a><strong><a href="https://www.bilibili.com/video/av13384870" target="_blank" rel="noopener">MongoDB的入门视频教程</a></strong></h3><h2 id="MongoDB的下载和安装"><a href="#MongoDB的下载和安装" class="headerlink" title="MongoDB的下载和安装"></a>MongoDB的下载和安装</h2><p>关于下载和安装直接按照官网的流程来即可</p>
<p><img src="C:\Users\75993\Pictures\Saved Pictures\study124.PNG" alt="官网下载社区版"></p>
<p>选择对应操作系统的版本，下载下来直接安装即可。</p>
<h2 id="MongoDB的遇到的问题"><a href="#MongoDB的遇到的问题" class="headerlink" title="MongoDB的遇到的问题"></a><strong>MongoDB的遇到的问题</strong></h2><h3 id="一-安装官方下载的msi的时候始终提示安装失败"><a href="#一-安装官方下载的msi的时候始终提示安装失败" class="headerlink" title="一 .       安装官方下载的msi的时候始终提示安装失败"></a><strong>一 .       安装官方下载的msi的时候始终提示安装失败</strong></h3><p><strong>解决办法：</strong></p>
<p>在安装程序最后一步的时候不勾选左下角的mongodb-compass 选项</p>
<h3 id="二-配置MongoDB为window服务时失败"><a href="#二-配置MongoDB为window服务时失败" class="headerlink" title="二.   配置MongoDB为window服务时失败"></a><strong>二.   配置MongoDB为window服务时失败</strong></h3><p><strong>解决办法：</strong></p>
<p>删除用于存放数据库的文件夹中的mongod.lock和storage.bson 文件，在重新启动</p>
<h3 id="相关参考文章"><a href="#相关参考文章" class="headerlink" title="相关参考文章"></a><strong>相关参考文章</strong></h3><p><a href="https://blog.csdn.net/win7583362/article/details/78342151" target="_blank" rel="noopener">mongodb安装及100报错 </a></p>
<p><a href="https://blog.csdn.net/qq_33222328/article/details/53433848" target="_blank" rel="noopener">关于安装MongoDB的过程与错误48 100的解决方法 </a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/11/09/Windows系统安全综述/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="WeiQingcai">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/head_logo.png">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="程序小栈">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/11/09/Windows系统安全综述/" itemprop="url">Windows系统安全综述</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-11-09T16:49:37+08:00">
                2018-11-09
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/网络安全/" itemprop="url" rel="index">
                    <span itemprop="name">网络安全</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Windows系统安全综述"><a href="#Windows系统安全综述" class="headerlink" title="Windows系统安全综述"></a>Windows系统安全综述</h1><ul>
<li><a href="#windows%E7%B3%BB%E7%BB%9F%E5%AE%89%E5%85%A8%E7%BB%BC%E8%BF%B0">Windows系统安全综述</a><ul>
<li><a href="#%E8%B4%A6%E6%88%B7%E5%88%86%E7%B1%BB%E5%8F%8A%E6%A6%82%E8%BF%B0">账户分类及概述</a><ul>
<li><a href="#%E7%94%A8%E6%88%B7%E8%B4%A6%E6%88%B7">用户账户</a><ul>
<li><a href="#%E5%9C%A8%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AE%A1%E7%90%86%E5%99%A8%E4%B8%AD%E7%AE%A1%E7%90%86%E7%94%A8%E6%88%B7">在服务器管理器中管理用户</a></li>
<li><a href="#%E9%80%9A%E8%BF%87%E8%BF%9B%E7%A8%8B%E4%B8%8E%E6%9C%8D%E5%8A%A1%E5%8C%BA%E5%88%86%E5%90%84%E5%86%85%E7%BD%AE%E7%94%A8%E6%88%B7%E8%B4%A6%E6%88%B7%E7%9A%84%E4%BD%9C%E7%94%A8">通过进程与服务区分各内置用户账户的作用</a></li>
</ul>
</li>
<li><a href="#%E7%BB%84%E8%B4%A6%E6%88%B7">组账户</a><ul>
<li><a href="#%E5%9C%A8%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AE%A1%E7%90%86%E5%85%B6%E4%B8%AD%E7%AE%A1%E7%90%86%E7%BB%84">在服务器管理其中管理组</a></li>
<li><a href="#%E9%9C%80%E8%A6%81%E4%BA%BA%E4%B8%BA%E6%B7%BB%E5%8A%A0%E6%88%90%E5%91%98%E7%9A%84%E5%86%85%E7%BD%AE%E7%BB%84">需要人为添加成员的内置组</a></li>
<li><a href="#%E5%8A%A8%E6%80%81%E5%8C%85%E5%90%AB%E6%88%90%E5%91%98%E7%9A%84%E5%86%85%E7%BD%AE%E7%BB%84">动态包含成员的内置组</a></li>
</ul>
</li>
<li><a href="#%E5%85%8B%E9%9A%86%E8%B4%A6%E6%88%B7%E4%BB%A5%E5%8F%8A%E8%B4%A6%E6%88%B7%E8%B6%85%E7%BA%A7%E9%9A%90%E8%97%8F">克隆账户以及账户超级隐藏</a></li>
</ul>
</li>
<li><a href="#ntfs%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%8F%8A%E6%9D%83%E9%99%90%E5%BA%94%E7%94%A8">NTFS文件系统及权限应用</a></li>
<li><a href="#efs%E5%8A%A0%E5%AF%86">EFS加密</a></li>
<li><a href="#%E6%9C%8D%E5%8A%A1">服务</a></li>
<li><a href="#%E7%97%85%E6%AF%92%E5%8F%8A%E9%98%B2%E8%8C%83">病毒及防范</a><ul>
<li><a href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%97%85%E6%AF%92">计算机病毒</a><ul>
<li><a href="#%E5%AE%9A%E4%B9%89">定义</a></li>
<li><a href="#%E7%89%B9%E7%82%B9">特点</a></li>
<li><a href="#%E5%88%86%E7%B1%BB">分类</a></li>
</ul>
</li>
<li><a href="#%E8%84%9A%E6%9C%AC%E7%97%85%E6%AF%92">脚本病毒</a><ul>
<li><a href="#%E7%89%B9%E7%82%B9-1">特点</a></li>
</ul>
</li>
<li><a href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%9C%A8%E9%A9%AC">计算机木马</a><ul>
<li><a href="#%E5%AE%9A%E4%B9%89-1">定义</a></li>
<li><a href="#%E7%89%B9%E5%BE%81">特征</a></li>
<li><a href="#%E5%8D%B1%E5%AE%B3">危害</a><h2 id="账户分类及概述"><a href="#账户分类及概述" class="headerlink" title="账户分类及概述"></a>账户分类及概述</h2></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="用户账户"><a href="#用户账户" class="headerlink" title="用户账户"></a>用户账户</h3><ul>
<li>不同的用户身份拥有不同的权限</li>
<li>每个用户包含一个名称和一个密码</li>
<li>用户账户拥有唯一的安全标识符</li>
</ul>
<h4 id="在服务器管理器中管理用户"><a href="#在服务器管理器中管理用户" class="headerlink" title="在服务器管理器中管理用户"></a>在服务器管理器中管理用户</h4><ul>
<li>创建用户</li>
<li>为用户重置密码</li>
<li>重命名用户名</li>
<li>启用，禁用，删除用户账户</li>
<li>为用户设置权限</li>
</ul>
<h4 id="通过进程与服务区分各内置用户账户的作用"><a href="#通过进程与服务区分各内置用户账户的作用" class="headerlink" title="通过进程与服务区分各内置用户账户的作用"></a>通过进程与服务区分各内置用户账户的作用</h4><ul>
<li>与使用者关联的用户账户<ul>
<li>Administrator（管理员用户）</li>
<li>Guest（来宾用户）</li>
</ul>
</li>
<li>与Windows组件关联的用户账户<ul>
<li>SYSTEM（本地系统）</li>
<li>SYSTEM SERVICE（本地服务）</li>
<li>NETWORK SERVICE（网络服务）</li>
</ul>
</li>
</ul>
<h3 id="组账户"><a href="#组账户" class="headerlink" title="组账户"></a>组账户</h3><ul>
<li>组是一些用户的集合</li>
<li>组内的用户自动具备组所设置的权限</li>
</ul>
<h4 id="在服务器管理其中管理组"><a href="#在服务器管理其中管理组" class="headerlink" title="在服务器管理其中管理组"></a>在服务器管理其中管理组</h4><ul>
<li>新建组</li>
<li>向组内添加成员</li>
<li>重命名组</li>
<li>删除组</li>
</ul>
<h4 id="需要人为添加成员的内置组"><a href="#需要人为添加成员的内置组" class="headerlink" title="需要人为添加成员的内置组"></a>需要人为添加成员的内置组</h4><ul>
<li>Administrator</li>
<li>Guests</li>
<li>Power User</li>
<li>Users（标准用户）</li>
</ul>
<h4 id="动态包含成员的内置组"><a href="#动态包含成员的内置组" class="headerlink" title="动态包含成员的内置组"></a>动态包含成员的内置组</h4><ul>
<li>Interactive（动态包含在本地登陆的用户）</li>
<li>Authenticated Users（动态包含通过验证的用户，不包含来宾用户）</li>
<li>Everyone（包含任何用户，设置开放的权限是经常使用）</li>
</ul>
<h3 id="克隆账户以及账户超级隐藏"><a href="#克隆账户以及账户超级隐藏" class="headerlink" title="克隆账户以及账户超级隐藏"></a>克隆账户以及账户超级隐藏</h3><ol>
<li><p>在添加用户时在要添加的用户名后边多加一个 <code>$</code> 符号(表示隐藏)</p>
<blockquote>
<p>net user test$ /add</p>
</blockquote>
<p>通过这种方式创建的用户直接使用命令行的<code>net user</code>命令是无法查看到的，但是可以通过计算机管理界面查看到存在该账户</p>
</li>
<li><p>通过修改注册表中的信息来达到完全隐藏账户的</p>
<ol>
<li>新建一个常规的隐藏账户（test$）</li>
<li>打开注册表，找到HKEY_LOCAL_MACHINE下的SAM，右键为其赋予权限之后展开</li>
<li>将Administrator的权限导出，同时将test$账户的权限和用户信息注册表导出</li>
<li>打开导出的Administrator和test$的权限注册表，用Administrator中的F的值代替test$中的F的值</li>
<li>删除之前创建的test$用户</li>
<li>运行之前导出的test$的注册表和test$权限的注册表</li>
<li>完成完全隐藏用户的创建（只能通过注册表来查找到）</li>
</ol>
</li>
</ol>
<h2 id="NTFS文件系统及权限应用"><a href="#NTFS文件系统及权限应用" class="headerlink" title="NTFS文件系统及权限应用"></a>NTFS文件系统及权限应用</h2><blockquote>
<p>NTFS (New Technology File System)，是 WindowsNT 环境的文件系统。新技术文件系统是Windows NT家族（如，Windows 2000、Windows XP、Windows Vista、Windows 7和 windows 8.1）等的限制级专用的文件系统（操作系统所在的盘符的文件系统必须格式化为NTFS的文件系统，4096簇环境下）。NTFS取代了老式的FAT文件系统。<br>NTFS对FAT和HPFS作了若干改进，例如，支持元数据，并且使用了高级数据结构，以便于改善性能、可靠性和磁盘空间利用率，并提供了若干附加扩展功能。</p>
</blockquote>
<ul>
<li>提高磁盘读写性能</li>
<li>可靠性<ul>
<li>加密文件系统</li>
<li>访问控制列表</li>
</ul>
</li>
<li>磁盘利用率<ul>
<li>压缩</li>
</ul>
</li>
</ul>
<h2 id="EFS加密"><a href="#EFS加密" class="headerlink" title="EFS加密"></a>EFS加密</h2><p>为了提高文件的安全性，微软在Windows中针对NTFS引入了EFS加密技术。EFS加密操作简单，对加密文件的用户也是透明的，文件加密后不必再试用期手动解密，只有加密则才能打开加密文件。</p>
<blockquote>
<p>EFS加密是基于公钥策略的。然后将利用FEK和数据扩展标准X算法创建加密后的文件，。如果你登录到了域环境中，密钥的生成依赖于域控制器，否则它就依赖于本地机器</p>
</blockquote>
<blockquote>
<p>EFS加密最简单的办法就是在目标对象上点击鼠标右键，选择“属性”，打开属性对话框,然后在常规选项卡上点击“高级”按钮，打开高级属性对话框，选中“加密内容以便保护数据”这个选项，反之解密。</p>
</blockquote>
<h2 id="服务"><a href="#服务" class="headerlink" title="服务"></a>服务</h2><p>service可以分为两个大类，服务应用程序和驱动服务。</p>
<ul>
<li><p>服务应用程序指遵照Service Control Manager 2接口要求的，能在系统启动时自动启动的用户能够通过服务控制面板控制的那些没有用户登录也能够运行的程序。</p>
</li>
<li><p>驱动服务一般指设备驱动程序协议等应用于底层设备驱动的服务</p>
</li>
</ul>
<h2 id="病毒及防范"><a href="#病毒及防范" class="headerlink" title="病毒及防范"></a>病毒及防范</h2><h3 id="计算机病毒"><a href="#计算机病毒" class="headerlink" title="计算机病毒"></a>计算机病毒</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>  编制或者在计算机程序中插入的，破坏技术啊你功能或者破坏数据，影响计算机使用并且能够自我复制的一组计算机指令或者程序代码</p>
<h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ul>
<li>非授权执行</li>
<li>隐蔽性</li>
<li>传染性</li>
<li>潜伏性</li>
<li>破坏性</li>
<li>可触发性</li>
</ul>
<h4 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h4><ul>
<li>文件型</li>
<li>引导扇区型</li>
<li>宏病毒</li>
<li>VBS脚本病毒</li>
<li>蠕虫</li>
</ul>
<h3 id="脚本病毒"><a href="#脚本病毒" class="headerlink" title="脚本病毒"></a>脚本病毒</h3><ul>
<li>通常与网页相结合，将恶意的破坏性代码内嵌在网页中</li>
<li>利用asp，htm，html，vbs，js类型的文件进行传播</li>
<li>基于VB Script和Java Script脚本语言</li>
<li>由Windows脚本宿主解释执行（也具有跨平台的特性）</li>
</ul>
<h4 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h4><ul>
<li><p>隐蔽性强</p>
<p>浏览网页，电子邮件中的病毒可以具有双拓展名</p>
</li>
<li><p>传播性广</p>
<p>可以自我复制，不依赖于其他文件就可以直接解释执行</p>
</li>
<li><p>病毒变种多</p>
<p>只需要对源码稍加修改，就可以制造出新的变种病毒</p>
</li>
</ul>
<h3 id="计算机木马"><a href="#计算机木马" class="headerlink" title="计算机木马"></a>计算机木马</h3><h4 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h4><p>一个包含在合法程序中的非法程序</p>
<h4 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h4><ul>
<li>未经许可即获得计算机的使用权</li>
<li>程序容量小，执行时不会占用太多资源</li>
<li>执行后很难停止</li>
<li>执行时不会在系统中显示出来</li>
<li>执行一次后会驻留在系统中，可以自动加载运行</li>
<li>自动变更文件名</li>
<li>作为驻留程序隐藏在系统内部</li>
<li>分为客户端和服务端</li>
</ul>
<h4 id="危害"><a href="#危害" class="headerlink" title="危害"></a>危害</h4><p>文件操作，修改注册表，窃取密码，系统操控</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/11/09/Google Java编程风格指南/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="WeiQingcai">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/head_logo.png">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="程序小栈">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/11/09/Google Java编程风格指南/" itemprop="url">Google Java编程风格规范</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-11-09T16:49:37+08:00">
                2018-11-09
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/编程语言/" itemprop="url" rel="index">
                    <span itemprop="name">编程语言</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="作者：Hawstein"><a href="#作者：Hawstein" class="headerlink" title="作者：Hawstein"></a>作者：Hawstein</h1><p>出处：<a href="http://hawstein.com/posts/google-java-style.html" target="_blank" rel="noopener">http://hawstein.com/posts/google-java-style.html</a><br>声明：本文采用以下协议进行授权： 自由转载-非商用-非衍生-保持署名|Creative Commons BY-NC-ND 3.0 ，转载请注明作者及出处。</p>
<hr>
<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>这份文档是Google Java编程风格规范的完整定义。当且仅当一个Java源文件符合此文档中的规则， 我们才认为它符合Google的Java编程风格。</p>
<p>与其它的编程风格指南一样，这里所讨论的不仅仅是编码格式美不美观的问题， 同时也讨论一些约定及编码标准。然而，这份文档主要侧重于我们所普遍遵循的规则， 对于那些不是明确强制要求的，我们尽量避免提供意见。</p>
<h4 id="1-1术语说明"><a href="#1-1术语说明" class="headerlink" title="1.1术语说明"></a>1.1术语说明</h4><p>在本文档中，除非另有说明：</p>
<ol>
<li>术语class可表示一个普通类，枚举类，接口或是annotation类型(@interface)</li>
<li>术语comment只用来指代实现的注释(implementation comments)，我们不使用“documentation comments”一词，而是用Javadoc。</li>
</ol>
<p>其他的术语说明会偶尔在后面的文档出现。</p>
<h4 id="1-2指南说明"><a href="#1-2指南说明" class="headerlink" title="1.2指南说明"></a>1.2指南说明</h4><p>本文档中的示例代码并不作为规范。也就是说，虽然示例代码是遵循Google编程风格，但并不意味着这是展现这些代码的唯一方式。 示例中的格式选择不应该被强制定为规则。</p>
<hr>
<h3 id="源文件基础"><a href="#源文件基础" class="headerlink" title="源文件基础"></a>源文件基础</h3><h4 id="2-1-文件名"><a href="#2-1-文件名" class="headerlink" title="2.1 文件名"></a>2.1 文件名</h4><p>源文件以其最顶层的类名来命名，大小写敏感，文件扩展名为.java。</p>
<h4 id="2-2-文件编码：UTF-8"><a href="#2-2-文件编码：UTF-8" class="headerlink" title="2.2 文件编码：UTF-8"></a>2.2 文件编码：UTF-8</h4><p>源文件编码格式为UTF-8。</p>
<h4 id="2-3-特殊字符"><a href="#2-3-特殊字符" class="headerlink" title="2.3 特殊字符"></a>2.3 特殊字符</h4><h5 id="2-3-1-空白字符"><a href="#2-3-1-空白字符" class="headerlink" title="2.3.1 空白字符"></a>2.3.1 空白字符</h5><p>除了行结束符序列，ASCII水平空格字符(0x20，即空格)是源文件中唯一允许出现的空白字符，这意味着：</p>
<ol>
<li>所有其它字符串中的空白字符都要进行转义。</li>
<li>制表符不用于缩进。</li>
</ol>
<h5 id="2-3-2-特殊转义序列"><a href="#2-3-2-特殊转义序列" class="headerlink" title="2.3.2 特殊转义序列"></a>2.3.2 特殊转义序列</h5><p>对于具有特殊转义序列的任何字符(\b, \t, \n, \f, \r, “, ‘及)，我们使用它的转义序列，而不是相应的八进制(比如\012)或Unicode(比如\u000a)转义。</p>
<h5 id="2-3-3-非ASCII字符"><a href="#2-3-3-非ASCII字符" class="headerlink" title="2.3.3 非ASCII字符"></a>2.3.3 非ASCII字符</h5><p>对于剩余的非ASCII字符，是使用实际的Unicode字符(比如∞)，还是使用等价的Unicode转义符(比如\u221e)，取决于哪个能让代码更易于阅读和理解。</p>
<blockquote>
<p>Tip: 在使用Unicode转义符或是一些实际的Unicode字符时，建议做些注释给出解释，这有助于别人阅读和理解。</p>
</blockquote>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String unitAbbrev = <span class="string">"μs"</span>;                                 | 赞，即使没有注释也非常清晰</span><br><span class="line">String unitAbbrev = <span class="string">"\u03bcs"</span>; <span class="comment">// "μs"                    | 允许，但没有理由要这样做</span></span><br><span class="line">String unitAbbrev = <span class="string">"\u03bcs"</span>; <span class="comment">// Greek letter mu, "s"    | 允许，但这样做显得笨拙还容易出错</span></span><br><span class="line">String unitAbbrev = <span class="string">"\u03bcs"</span>;                            | 很糟，读者根本看不出这是什么</span><br><span class="line"><span class="keyword">return</span> <span class="string">'\ufeff'</span> + content; <span class="comment">// byte order mark             | Good，对于非打印字符，使用转义，并在必要时写上注释</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>Tip: 永远不要由于害怕某些程序可能无法正确处理非ASCII字符而让你的代码可读性变差。当程序无法正确处理非ASCII字符时，它自然无法正确运行， 你就会去fix这些问题的了。(言下之意就是大胆去用非ASCII字符，如果真的有需要的话)</p>
</blockquote>
<hr>
<h3 id="源文件结构"><a href="#源文件结构" class="headerlink" title="源文件结构"></a>源文件结构</h3><p>一个源文件包含(按顺序地)：</p>
<ol>
<li>许可证或版权信息(如有需要)</li>
<li>package语句</li>
<li>import语句</li>
<li>一个顶级类(只有一个)</li>
</ol>
<p>以上每个部分之间用一个空行隔开。</p>
<h4 id="3-1-许可证或版权信息"><a href="#3-1-许可证或版权信息" class="headerlink" title="3.1 许可证或版权信息"></a>3.1 许可证或版权信息</h4><p>如果一个文件包含许可证或版权信息，那么它应当被放在文件最前面。</p>
<h4 id="3-2-package语句"><a href="#3-2-package语句" class="headerlink" title="3.2 package语句"></a>3.2 package语句</h4><p>package语句不换行，列限制(4.4节)并不适用于package语句。(即package语句写在一行里)</p>
<h4 id="3-3-import语句"><a href="#3-3-import语句" class="headerlink" title="3.3 import语句"></a>3.3 import语句</h4><h5 id="3-3-1-import不要使用通配符"><a href="#3-3-1-import不要使用通配符" class="headerlink" title="3.3.1 import不要使用通配符"></a>3.3.1 import不要使用通配符</h5><p>即，不要出现类似这样的import语句：import java.util.*;</p>
<h5 id="3-3-2-不要换行"><a href="#3-3-2-不要换行" class="headerlink" title="3.3.2 不要换行"></a>3.3.2 不要换行</h5><p>import语句不换行，列限制(4.4节)并不适用于import语句。(每个import语句独立成行)</p>
<h5 id="3-3-3-顺序和间距"><a href="#3-3-3-顺序和间距" class="headerlink" title="3.3.3 顺序和间距"></a>3.3.3 顺序和间距</h5><p>import语句可分为以下几组，按照这个顺序，每组由一个空行分隔：</p>
<ol>
<li>所有的静态导入独立成组</li>
<li>com.google imports(仅当这个源文件是在com.google包下)</li>
<li>第三方的包。每个顶级包为一组，字典序。例如：android, com,junit, org, sun</li>
<li>java imports</li>
<li>javax imports</li>
</ol>
<p>组内不空行，按字典序排列。</p>
<h4 id="3-4-类声明"><a href="#3-4-类声明" class="headerlink" title="3.4 类声明"></a>3.4 类声明</h4><h5 id="3-4-1-只有一个顶级类声明"><a href="#3-4-1-只有一个顶级类声明" class="headerlink" title="3.4.1 只有一个顶级类声明"></a>3.4.1 只有一个顶级类声明</h5><p>每个顶级类都在一个与它同名的源文件中(当然，还包含.java后缀)。<br>例外：package-info.java，该文件中可没有package-info类。</p>
<h5 id="3-4-2-类成员顺序"><a href="#3-4-2-类成员顺序" class="headerlink" title="3.4.2 类成员顺序"></a>3.4.2 类成员顺序</h5><p>类的成员顺序对易学性有很大的影响，但这也不存在唯一的通用法则。不同的类对成员的排序可能是不同的。 最重要的一点，每个类应该以某种逻辑去排序它的成员，维护者应该要能解释这种排序逻辑。比如， 新的方法不能总是习惯性地添加到类的结尾，因为这样就是按时间顺序而非某种逻辑来排序的。</p>
<h6 id="3-4-2-1-重载：永不分离"><a href="#3-4-2-1-重载：永不分离" class="headerlink" title="3.4.2.1 重载：永不分离"></a>3.4.2.1 重载：永不分离</h6><p>当一个类有多个构造函数，或是多个同名方法，这些函数/方法应该按顺序出现在一起，中间不要放进其它函数/方法。</p>
<h3 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h3><p><strong>术语说明：</strong>块状结构(block-like construct)指的是一个类，方法或构造函数的主体。需要注意的是，数组初始化中的初始值可被选择性地视为块状结构(4.8.3.1节)。</p>
<h4 id="4-1-大括号"><a href="#4-1-大括号" class="headerlink" title="4.1 大括号"></a>4.1 大括号</h4><h5 id="4-1-1-使用大括号-即使是可选的"><a href="#4-1-1-使用大括号-即使是可选的" class="headerlink" title="4.1.1 使用大括号(即使是可选的)"></a>4.1.1 使用大括号(即使是可选的)</h5><p>大括号与if, else, for, do, while语句一起使用，即使只有一条语句(或是空)，也应该把大括号写上。</p>
<h5 id="4-1-2-非空块：K-amp-R-风格"><a href="#4-1-2-非空块：K-amp-R-风格" class="headerlink" title="4.1.2 非空块：K &amp; R 风格"></a>4.1.2 非空块：K &amp; R 风格</h5><p>对于非空块和块状结构，大括号遵循Kernighan和Ritchie风格 (Egyptian brackets):</p>
<ul>
<li>左大括号前不换行</li>
<li>左大括号后换行</li>
<li>右大括号前换行</li>
<li>如果右大括号是一个语句、函数体或类的终止，则右大括号后换行; 否则不换行。例如，如果右大括号后面是else或逗号，则不换行。</li>
</ul>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> MyClass() &#123;</span><br><span class="line">  <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (condition()) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        something();</span><br><span class="line">      &#125; <span class="keyword">catch</span> (ProblemException e) &#123;</span><br><span class="line">        recover();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>4.8.1节给出了enum类的一些例外。</p>
<h5 id="4-1-3-空块：可以用简洁版本"><a href="#4-1-3-空块：可以用简洁版本" class="headerlink" title="4.1.3 空块：可以用简洁版本"></a>4.1.3 空块：可以用简洁版本</h5><p>一个空的块状结构里什么也不包含，大括号可以简洁地写成{}，不需要换行。例外：如果它是一个多块语句的一部分(if/else 或 try/catch/finally) ，即使大括号内没内容，右大括号也要换行。</p>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doNothing</span><span class="params">()</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<h4 id="4-2-块缩进：2个空格"><a href="#4-2-块缩进：2个空格" class="headerlink" title="4.2 块缩进：2个空格"></a>4.2 块缩进：2个空格</h4><p>每当开始一个新的块，缩进增加2个空格，当块结束时，缩进返回先前的缩进级别。缩进级别适用于代码和注释。(见4.1.2节中的代码示例)</p>
<h4 id="4-3-一行一个语句"><a href="#4-3-一行一个语句" class="headerlink" title="4.3 一行一个语句"></a>4.3 一行一个语句</h4><p>每个语句后要换行。</p>
<h4 id="4-4-列限制：80或100"><a href="#4-4-列限制：80或100" class="headerlink" title="4.4 列限制：80或100"></a>4.4 列限制：80或100</h4><p>一个项目可以选择一行80个字符或100个字符的列限制，除了下述例外，任何一行如果超过这个字符数限制，必须自动换行。</p>
<p>例外：</p>
<ol>
<li>不可能满足列限制的行(例如，Javadoc中的一个长URL，或是一个长的JSNI方法参考)。</li>
<li>package和import语句(见3.2节和3.3节)。</li>
<li>注释中那些可能被剪切并粘贴到shell中的命令行。</li>
</ol>
<h4 id="4-5-自动换行"><a href="#4-5-自动换行" class="headerlink" title="4.5 自动换行"></a>4.5 自动换行</h4><p><strong>术语说明：</strong>一般情况下，一行长代码为了避免超出列限制(80或100个字符)而被分为多行，我们称之为自动换行(line-wrapping)。</p>
<p>我们并没有全面，确定性的准则来决定在每一种情况下如何自动换行。很多时候，对于同一段代码会有好几种有效的自动换行方式。</p>
<blockquote>
<p>Tip: 提取方法或局部变量可以在不换行的情况下解决代码过长的问题(是合理缩短命名长度吧)</p>
</blockquote>
<h5 id="4-5-1-从哪里断开"><a href="#4-5-1-从哪里断开" class="headerlink" title="4.5.1 从哪里断开"></a>4.5.1 从哪里断开</h5><p>自动换行的基本准则是：更倾向于在更高的语法级别处断开。</p>
<ol>
<li>如果在非赋值运算符处断开，那么在该符号前断开(比如+，它将位于下一行)。注意：这一点与Google其它语言的编程风格不同(如C++和JavaScript)。 这条规则也适用于以下“类运算符”符号：点分隔符(.)，类型界限中的&amp;（<t extends="" foo="" &="" bar="">)，catch块中的管道符号(catch (FooException | BarException e)</t></li>
<li>如果在赋值运算符处断开，通常的做法是在该符号后断开(比如=，它与前面的内容留在同一行)。这条规则也适用于foreach语句中的分号。</li>
<li>方法名或构造函数名与左括号留在同一行。</li>
<li>逗号(,)与其前面的内容留在同一行。</li>
</ol>
<h5 id="4-5-2-自动换行时缩进至少-4个空格"><a href="#4-5-2-自动换行时缩进至少-4个空格" class="headerlink" title="4.5.2 自动换行时缩进至少+4个空格"></a>4.5.2 自动换行时缩进至少+4个空格</h5><p>自动换行时，第一行后的每一行至少比第一行多缩进4个空格(注意：制表符不用于缩进。见2.3.1节)。</p>
<p>当存在连续自动换行时，缩进可能会多缩进不只4个空格(语法元素存在多级时)。一般而言，两个连续行使用相同的缩进当且仅当它们开始于同级语法元素。</p>
<p>第4.6.3水平对齐一节中指出，不鼓励使用可变数目的空格来对齐前面行的符号。</p>
<h4 id="4-6-空白"><a href="#4-6-空白" class="headerlink" title="4.6 空白"></a>4.6 空白</h4><h5 id="4-6-1-垂直空白"><a href="#4-6-1-垂直空白" class="headerlink" title="4.6.1 垂直空白"></a>4.6.1 垂直空白</h5><p>以下情况需要使用一个空行：</p>
<ol>
<li>类内连续的成员之间：字段，构造函数，方法，嵌套类，静态初始化块，实例初始化块。例外：两个连续字段之间的空行是可选的，用于字段的空行主要用来对字段进行逻辑分组。</li>
<li>在函数体内，语句的逻辑分组间使用空行。</li>
<li>类内的第一个成员前或最后一个成员后的空行是可选的(既不鼓励也不反对这样做，视个人喜好而定)。</li>
<li>要满足本文档中其他节的空行要求(比如3.3节：import语句)</li>
</ol>
<p>多个连续的空行是允许的，但没有必要这样做(我们也不鼓励这样做)。</p>
<h5 id="4-6-2-水平空白"><a href="#4-6-2-水平空白" class="headerlink" title="4.6.2 水平空白"></a>4.6.2 水平空白</h5><p>除了语言需求和其它规则，并且除了文字，注释和Javadoc用到单个空格，单个ASCII空格也出现在以下几个地方：</p>
<ol>
<li>分隔任何保留字与紧随其后的左括号(()(如if, for catch等)。</li>
<li>分隔任何保留字与其前面的右大括号(})(如else, catch)。</li>
<li>在任何左大括号前({)，两个例外：<ul>
<li>@SomeAnnotation({a, b})(不使用空格)。</li>
<li>String[][] x = foo;(大括号间没有空格，见下面的Note)。</li>
</ul>
</li>
<li>在任何二元或三元运算符的两侧。这也适用于以下“类运算符”符号：<ul>
<li>类型界限中的&amp;(<t extends="" foo="" &="" bar="">)。</t></li>
<li>catch块中的管道符号(catch (FooException | BarException e)。</li>
<li>foreach语句中的分号。</li>
</ul>
</li>
<li>在, : ;及右括号())后</li>
<li>如果在一条语句后做注释，则双斜杠(//)两边都要空格。这里可以允许多个空格，但没有必要。</li>
<li>类型和变量之间：List list。</li>
<li>数组初始化中，大括号内的空格是可选的，即new int[] {5, 6}和new int[] { 5, 6 }都是可以的。</li>
</ol>
<blockquote>
<p>Note：这个规则并不要求或禁止一行的开关或结尾需要额外的空格，只对内部空格做要求。</p>
</blockquote>
<h5 id="4-6-3-水平对齐：不做要求"><a href="#4-6-3-水平对齐：不做要求" class="headerlink" title="4.6.3 水平对齐：不做要求"></a>4.6.3 水平对齐：不做要求</h5><p><strong>术语说明：</strong>水平对齐指的是通过增加可变数量的空格来使某一行的字符与上一行的相应字符对齐。</p>
<p>这是允许的(而且在不少地方可以看到这样的代码)，但Google编程风格对此不做要求。即使对于已经使用水平对齐的代码，我们也不需要去保持这种风格。</p>
<p>以下示例先展示未对齐的代码，然后是对齐的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> x; <span class="comment">// this is fine</span></span><br><span class="line"><span class="keyword">private</span> Color color; <span class="comment">// this too</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span>   x;      <span class="comment">// permitted, but future edits</span></span><br><span class="line"><span class="keyword">private</span> Color color;  <span class="comment">// may leave it unaligned</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>Tip：对齐可增加代码可读性，但它为日后的维护带来问题。考虑未来某个时候，我们需要修改一堆对齐的代码中的一行。 这可能导致原本很漂亮的对齐代码变得错位。很可能它会提示你调整周围代码的空白来使这一堆代码重新水平对齐(比如程序员想保持这种水平对齐的风格)， 这就会让你做许多的无用功，增加了reviewer的工作并且可能导致更多的合并冲突。</p>
</blockquote>
<h4 id="4-7-用小括号来限定组：推荐"><a href="#4-7-用小括号来限定组：推荐" class="headerlink" title="4.7 用小括号来限定组：推荐"></a>4.7 用小括号来限定组：推荐</h4><p>除非作者和reviewer都认为去掉小括号也不会使代码被误解，或是去掉小括号能让代码更易于阅读，否则我们不应该去掉小括号。 我们没有理由假设读者能记住整个Java运算符优先级表。</p>
<h4 id="4-8-具体结构"><a href="#4-8-具体结构" class="headerlink" title="4.8 具体结构"></a>4.8 具体结构</h4><h5 id="4-8-1-枚举类"><a href="#4-8-1-枚举类" class="headerlink" title="4.8.1 枚举类"></a>4.8.1 枚举类</h5><p>枚举常量间用逗号隔开，换行可选。</p>
<p>没有方法和文档的枚举类可写成数组初始化的格式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">enum</span> Suit &#123; CLUBS, HEARTS, SPADES, DIAMONDS &#125;</span><br></pre></td></tr></table></figure>
<p>由于枚举类也是一个类，因此所有适用于其它类的格式规则也适用于枚举类。</p>
<h5 id="4-8-2-变量声明"><a href="#4-8-2-变量声明" class="headerlink" title="4.8.2 变量声明"></a>4.8.2 变量声明</h5><h6 id="4-8-2-1-每次只声明一个变量"><a href="#4-8-2-1-每次只声明一个变量" class="headerlink" title="4.8.2.1 每次只声明一个变量"></a>4.8.2.1 每次只声明一个变量</h6><p>不要使用组合声明，比如int a, b;。</p>
<h6 id="4-8-2-2-需要时才声明，并尽快进行初始化"><a href="#4-8-2-2-需要时才声明，并尽快进行初始化" class="headerlink" title="4.8.2.2 需要时才声明，并尽快进行初始化"></a>4.8.2.2 需要时才声明，并尽快进行初始化</h6><p>不要在一个代码块的开头把局部变量一次性都声明了(这是c语言的做法)，而是在第一次需要使用它时才声明。 局部变量在声明时最好就进行初始化，或者声明后尽快进行初始化。</p>
<h5 id="4-8-3-数组"><a href="#4-8-3-数组" class="headerlink" title="4.8.3 数组"></a>4.8.3 数组</h5><h6 id="4-8-3-1-数组初始化：可写成块状结构"><a href="#4-8-3-1-数组初始化：可写成块状结构" class="headerlink" title="4.8.3.1 数组初始化：可写成块状结构"></a>4.8.3.1 数组初始化：可写成块状结构</h6><p>数组初始化可以写成块状结构，比如，下面的写法都是OK的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="keyword">int</span>[] &#123;</span><br><span class="line">  <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="keyword">int</span>[] &#123;</span><br><span class="line">  <span class="number">0</span>,</span><br><span class="line">  <span class="number">1</span>,</span><br><span class="line">  <span class="number">2</span>,</span><br><span class="line">  <span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="keyword">int</span>[] &#123;</span><br><span class="line">  <span class="number">0</span>, <span class="number">1</span>,</span><br><span class="line">  <span class="number">2</span>, <span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br></pre></td></tr></table></figure>
<h6 id="4-8-3-2-非C风格的数组声明"><a href="#4-8-3-2-非C风格的数组声明" class="headerlink" title="4.8.3.2 非C风格的数组声明"></a>4.8.3.2 非C风格的数组声明</h6><p>中括号是类型的一部分：String[] args， 而非String args[]。</p>
<h5 id="4-8-4-switch语句"><a href="#4-8-4-switch语句" class="headerlink" title="4.8.4 switch语句"></a>4.8.4 switch语句</h5><p><strong>术语说明：</strong>switch块的大括号内是一个或多个语句组。每个语句组包含一个或多个switch标签(case FOO:或default:)，后面跟着一条或多条语句。</p>
<h6 id="4-8-4-1-缩进"><a href="#4-8-4-1-缩进" class="headerlink" title="4.8.4.1 缩进"></a>4.8.4.1 缩进</h6><p>与其它块状结构一致，switch块中的内容缩进为2个空格。</p>
<p>每个switch标签后新起一行，再缩进2个空格，写下一条或多条语句。</p>
<h6 id="4-8-4-2-Fall-through：注释"><a href="#4-8-4-2-Fall-through：注释" class="headerlink" title="4.8.4.2 Fall-through：注释"></a>4.8.4.2 Fall-through：注释</h6><p>在一个switch块内，每个语句组要么通过break, continue, return或抛出异常来终止，要么通过一条注释来说明程序将继续执行到下一个语句组， 任何能表达这个意思的注释都是OK的(典型的是用// fall through)。这个特殊的注释并不需要在最后一个语句组(一般是default)中出现。示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (input) &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">  <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">    prepareOneOrTwo();</span><br><span class="line">    <span class="comment">// fall through</span></span><br><span class="line">  <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">    handleOneTwoOrThree();</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    handleLargeNumber(input);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="4-8-4-3-default的情况要写出来"><a href="#4-8-4-3-default的情况要写出来" class="headerlink" title="4.8.4.3 default的情况要写出来"></a>4.8.4.3 default的情况要写出来</h6><p>每个switch语句都包含一个default语句组，即使它什么代码也不包含。</p>
<h5 id="4-8-5-注解-Annotations"><a href="#4-8-5-注解-Annotations" class="headerlink" title="4.8.5 注解(Annotations)"></a>4.8.5 注解(Annotations)</h5><p>注解紧跟在文档块后面，应用于类、方法和构造函数，一个注解独占一行。这些换行不属于自动换行(第4.5节，自动换行)，因此缩进级别不变。例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getNameIfPresent</span><span class="params">()</span> </span>&#123; ... &#125;</span><br></pre></td></tr></table></figure>
<p><strong>例外：</strong>单个的注解可以和签名的第一行出现在同一行。例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123; ... &#125;</span><br></pre></td></tr></table></figure>
<p>应用于字段的注解紧随文档块出现，应用于字段的多个注解允许与字段出现在同一行。例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Partial</span> <span class="meta">@Mock</span> DataLoader loader;</span><br></pre></td></tr></table></figure>
<p>参数和局部变量注解没有特定规则。</p>
<h5 id="4-8-6-注释"><a href="#4-8-6-注释" class="headerlink" title="4.8.6 注释"></a>4.8.6 注释</h5><h6 id="4-8-6-1-块注释风格"><a href="#4-8-6-1-块注释风格" class="headerlink" title="4.8.6.1 块注释风格"></a>4.8.6.1 块注释风格</h6><p>块注释与其周围的代码在同一缩进级别。它们可以是/<em> … </em>/风格，也可以是// …风格。对于多行的/<em> … </em>/注释，后续行必须从<em>开始， 并且与前一行的</em>对齐。以下示例注释都是OK的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * This is          // And so           /* Or you can</span></span><br><span class="line"><span class="comment"> * okay.            // is this.          * even do this. */</span></span><br><span class="line"> */</span><br></pre></td></tr></table></figure>
<p>注释不要封闭在由星号或其它字符绘制的框架里。</p>
<blockquote>
<p>Tip：在写多行注释时，如果你希望在必要时能重新换行(即注释像段落风格一样)，那么使用/<em> … </em>/。</p>
</blockquote>
<h5 id="4-8-7-Modifiers"><a href="#4-8-7-Modifiers" class="headerlink" title="4.8.7 Modifiers"></a>4.8.7 Modifiers</h5><p>类和成员的modifiers如果存在，则按Java语言规范中推荐的顺序出现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">protected</span> <span class="keyword">private</span> <span class="keyword">abstract</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">synchronized</span> <span class="keyword">native</span> <span class="keyword">strictfp</span></span><br></pre></td></tr></table></figure>
<hr>
<h3 id="命名约定"><a href="#命名约定" class="headerlink" title="命名约定"></a>命名约定</h3><h4 id="5-1-对所有标识符都通用的规则"><a href="#5-1-对所有标识符都通用的规则" class="headerlink" title="5.1 对所有标识符都通用的规则"></a>5.1 对所有标识符都通用的规则</h4><p>标识符只能使用ASCII字母和数字，因此每个有效的标识符名称都能匹配正则表达式\w+。</p>
<p>在Google其它编程语言风格中使用的特殊前缀或后缀，如name_, mName, s_name和kName，在Java编程风格中都不再使用。</p>
<h4 id="5-2-标识符类型的规则"><a href="#5-2-标识符类型的规则" class="headerlink" title="5.2 标识符类型的规则"></a>5.2 标识符类型的规则</h4><h5 id="5-2-1-包名"><a href="#5-2-1-包名" class="headerlink" title="5.2.1 包名"></a>5.2.1 包名</h5><p>包名全部小写，连续的单词只是简单地连接起来，不使用下划线。</p>
<h5 id="5-2-2-类名"><a href="#5-2-2-类名" class="headerlink" title="5.2.2 类名"></a>5.2.2 类名</h5><p>类名都以UpperCamelCase风格编写。</p>
<p>类名通常是名词或名词短语，接口名称有时可能是形容词或形容词短语。现在还没有特定的规则或行之有效的约定来命名注解类型。</p>
<p>测试类的命名以它要测试的类的名称开始，以Test结束。例如，HashTest或HashIntegrationTest。</p>
<h5 id="5-2-3-方法名"><a href="#5-2-3-方法名" class="headerlink" title="5.2.3 方法名"></a>5.2.3 方法名</h5><p>方法名都以lowerCamelCase风格编写。</p>
<p>方法名通常是动词或动词短语。</p>
<p>下划线可能出现在JUnit测试方法名称中用以分隔名称的逻辑组件。一个典型的模式是：test<methodundertest>_<state>，例如testPop_emptyStack。 并不存在唯一正确的方式来命名测试方法。</state></methodundertest></p>
<h5 id="5-2-4-常量名"><a href="#5-2-4-常量名" class="headerlink" title="5.2.4 常量名"></a>5.2.4 常量名</h5><p>常量名命名模式为CONSTANT_CASE，全部字母大写，用下划线分隔单词。那，到底什么算是一个常量？</p>
<p>每个常量都是一个静态final字段，但不是所有静态final字段都是常量。在决定一个字段是否是一个常量时， 考虑它是否真的感觉像是一个常量。例如，如果任何一个该实例的观测状态是可变的，则它几乎肯定不会是一个常量。 只是永远不打算改变对象一般是不够的，它要真的一直不变才能将它示为常量。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Constants</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NUMBER = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> ImmutableList&lt;String&gt; NAMES = ImmutableList.of(<span class="string">"Ed"</span>, <span class="string">"Ann"</span>);</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> Joiner COMMA_JOINER = Joiner.on(<span class="string">','</span>);  <span class="comment">// because Joiner is immutable</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> SomeMutableType[] EMPTY_ARRAY = &#123;&#125;;</span><br><span class="line"><span class="keyword">enum</span> SomeEnum &#123; ENUM_CONSTANT &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Not constants</span></span><br><span class="line"><span class="keyword">static</span> String nonFinal = <span class="string">"non-final"</span>;</span><br><span class="line"><span class="keyword">final</span> String nonStatic = <span class="string">"non-static"</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> Set&lt;String&gt; mutableCollection = <span class="keyword">new</span> HashSet&lt;String&gt;();</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> ImmutableSet&lt;SomeMutableType&gt; mutableElements = ImmutableSet.of(mutable);</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> Logger logger = Logger.getLogger(MyClass.getName());</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> String[] nonEmptyArray = &#123;<span class="string">"these"</span>, <span class="string">"can"</span>, <span class="string">"change"</span>&#125;;</span><br></pre></td></tr></table></figure>
<p>这些名字通常是名词或名词短语。</p>
<h5 id="5-2-5-非常量字段名"><a href="#5-2-5-非常量字段名" class="headerlink" title="5.2.5 非常量字段名"></a>5.2.5 非常量字段名</h5><p>非常量字段名以lowerCamelCase风格编写。</p>
<p>这些名字通常是名词或名词短语。</p>
<h5 id="5-2-6-参数名"><a href="#5-2-6-参数名" class="headerlink" title="5.2.6 参数名"></a>5.2.6 参数名</h5><p>参数名以lowerCamelCase风格编写。</p>
<p>参数应该避免用单个字符命名。</p>
<h5 id="5-2-7-局部变量名"><a href="#5-2-7-局部变量名" class="headerlink" title="5.2.7 局部变量名"></a>5.2.7 局部变量名</h5><p>局部变量名以lowerCamelCase风格编写，比起其它类型的名称，局部变量名可以有更为宽松的缩写。</p>
<p>虽然缩写更宽松，但还是要避免用单字符进行命名，除了临时变量和循环变量。</p>
<p>即使局部变量是final和不可改变的，也不应该把它示为常量，自然也不能用常量的规则去命名它。</p>
<h5 id="5-2-8-类型变量名"><a href="#5-2-8-类型变量名" class="headerlink" title="5.2.8 类型变量名"></a>5.2.8 类型变量名</h5><p>类型变量可用以下两种风格之一进行命名：</p>
<ul>
<li>单个的大写字母，后面可以跟一个数字(如：E, T, X, T2)。</li>
<li>以类命名方式(5.2.2节)，后面加个大写的T(如：RequestT, FooBarT)。</li>
</ul>
<h4 id="5-3-驼峰式命名法-CamelCase"><a href="#5-3-驼峰式命名法-CamelCase" class="headerlink" title="5.3 驼峰式命名法(CamelCase)"></a>5.3 驼峰式命名法(CamelCase)</h4><p>驼峰式命名法分大驼峰式命名法(UpperCamelCase)和小驼峰式命名法(lowerCamelCase)。 有时，我们有不只一种合理的方式将一个英语词组转换成驼峰形式，如缩略语或不寻常的结构(例如”IPv6”或”iOS”)。Google指定了以下的转换方案。</p>
<p>名字从散文形式(prose form)开始:</p>
<ol>
<li>把短语转换为纯ASCII码，并且移除任何单引号。例如：”Müller’s algorithm”将变成”Muellers algorithm”。</li>
<li>把这个结果切分成单词，在空格或其它标点符号(通常是连字符)处分割开。<ul>
<li>推荐：如果某个单词已经有了常用的驼峰表示形式，按它的组成将它分割开(如”AdWords”将分割成”ad words”)。 需要注意的是”iOS”并不是一个真正的驼峰表示形式，因此该推荐对它并不适用。</li>
</ul>
</li>
<li>现在将所有字母都小写(包括缩写)，然后将单词的第一个字母大写：<ul>
<li>每个单词的第一个字母都大写，来得到大驼峰式命名。</li>
<li>除了第一个单词，每个单词的第一个字母都大写，来得到小驼峰式命名。</li>
</ul>
</li>
<li>最后将所有的单词连接起来得到一个标识符。</li>
</ol>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Prose form                Correct               Incorrect</span><br><span class="line">------------------------------------------------------------------</span><br><span class="line"><span class="string">"XML HTTP request"</span>        XmlHttpRequest        XMLHTTPRequest</span><br><span class="line"><span class="string">"new customer ID"</span>         newCustomerId         newCustomerID</span><br><span class="line"><span class="string">"inner stopwatch"</span>         innerStopwatch        innerStopWatch</span><br><span class="line"><span class="string">"supports IPv6 on iOS?"</span>   supportsIpv6OnIos     supportsIPv6OnIOS</span><br><span class="line"><span class="string">"YouTube importer"</span>        YouTubeImporter</span><br><span class="line">                          YoutubeImporter*</span><br></pre></td></tr></table></figure>
<p>加星号处表示可以，但不推荐。</p>
<blockquote>
<p>Note：在英语中，某些带有连字符的单词形式不唯一。例如：”nonempty”和”non-empty”都是正确的，因此方法名checkNonempty和checkNonEmpty也都是正确的。</p>
</blockquote>
<hr>
<h3 id="编程实践"><a href="#编程实践" class="headerlink" title="编程实践"></a>编程实践</h3><h4 id="6-1-Override：能用则用"><a href="#6-1-Override：能用则用" class="headerlink" title="6.1 @Override：能用则用"></a>6.1 @Override：能用则用</h4><p>只要是合法的，就把@Override注解给用上。</p>
<h4 id="6-2-捕获的异常：不能忽视"><a href="#6-2-捕获的异常：不能忽视" class="headerlink" title="6.2 捕获的异常：不能忽视"></a>6.2 捕获的异常：不能忽视</h4><p>除了下面的例子，对捕获的异常不做响应是极少正确的。(典型的响应方式是打印日志，或者如果它被认为是不可能的，则把它当作一个AssertionError重新抛出。)</p>
<p>如果它确实是不需要在catch块中做任何响应，需要做注释加以说明(如下面的例子)。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="keyword">int</span> i = Integer.parseInt(response);</span><br><span class="line">  <span class="keyword">return</span> handleNumericResponse(i);</span><br><span class="line">&#125; <span class="keyword">catch</span> (NumberFormatException ok) &#123;</span><br><span class="line">  <span class="comment">// it's not numeric; that's fine, just continue</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> handleTextResponse(response);</span><br></pre></td></tr></table></figure>
<p><strong>例外：</strong>在测试中，如果一个捕获的异常被命名为expected，则它可以被不加注释地忽略。下面是一种非常常见的情形，用以确保所测试的方法会抛出一个期望中的异常， 因此在这里就没有必要加注释。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  emptyStack.pop();</span><br><span class="line">  fail();</span><br><span class="line">&#125; <span class="keyword">catch</span> (NoSuchElementException expected) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="6-3-静态成员：使用类进行调用"><a href="#6-3-静态成员：使用类进行调用" class="headerlink" title="6.3 静态成员：使用类进行调用"></a>6.3 静态成员：使用类进行调用</h4><p>使用类名调用静态的类成员，而不是具体某个对象或表达式。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Foo aFoo = ...;</span><br><span class="line">Foo.aStaticMethod(); <span class="comment">// good</span></span><br><span class="line">aFoo.aStaticMethod(); <span class="comment">// bad</span></span><br><span class="line">somethingThatYieldsAFoo().aStaticMethod(); <span class="comment">// very bad</span></span><br></pre></td></tr></table></figure>
<h4 id="6-4-Finalizers-禁用"><a href="#6-4-Finalizers-禁用" class="headerlink" title="6.4 Finalizers: 禁用"></a>6.4 Finalizers: 禁用</h4><p>极少会去重写Object.finalize。</p>
<blockquote>
<p>Tip：不要使用finalize。如果你非要使用它，请先仔细阅读和理解Effective Java 第7条款：“Avoid Finalizers”，然后不要使用它。</p>
</blockquote>
<hr>
<h3 id="Javadoc"><a href="#Javadoc" class="headerlink" title="Javadoc"></a>Javadoc</h3><h4 id="7-1-格式"><a href="#7-1-格式" class="headerlink" title="7.1 格式"></a>7.1 格式</h4><h5 id="7-1-1-一般形式"><a href="#7-1-1-一般形式" class="headerlink" title="7.1.1 一般形式"></a>7.1.1 一般形式</h5><p>Javadoc块的基本格式如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Multiple lines of Javadoc text are written here,</span></span><br><span class="line"><span class="comment"> * wrapped normally...</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">method</span><span class="params">(String p1)</span> </span>&#123; ... &#125;</span><br></pre></td></tr></table></figure>
<p>或者是以下单行形式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** An especially short bit of Javadoc. */</span></span><br></pre></td></tr></table></figure>
<p>基本格式总是OK的。当整个Javadoc块能容纳于一行时(且没有Javadoc标记@XXX)，可以使用单行形式。</p>
<h5 id="7-1-2-段落"><a href="#7-1-2-段落" class="headerlink" title="7.1.2 段落"></a>7.1.2 段落</h5><p>空行(即，只包含最左侧星号的行)会出现在段落之间和Javadoc标记(@XXX)之前(如果有的话)。 除了第一个段落，每个段落第一个单词前都有标签</p><p>，并且它和第一个单词间没有空格。</p>
<h5 id="7-1-3-Javadoc标记"><a href="#7-1-3-Javadoc标记" class="headerlink" title="7.1.3 Javadoc标记"></a>7.1.3 Javadoc标记</h5><p>标准的Javadoc标记按以下顺序出现：@param, @return, @throws, @deprecated, 前面这4种标记如果出现，描述都不能为空。 当描述无法在一行中容纳，连续行需要至少再缩进4个空格。</p>
<h4 id="7-2-摘要片段"><a href="#7-2-摘要片段" class="headerlink" title="7.2 摘要片段"></a>7.2 摘要片段</h4><p>每个类或成员的Javadoc以一个简短的摘要片段开始。这个片段是非常重要的，在某些情况下，它是唯一出现的文本，比如在类和方法索引中。</p>
<p>这只是一个小片段，可以是一个名词短语或动词短语，但不是一个完整的句子。它不会以A {@code Foo} is a…或This method returns…开头, 它也不会是一个完整的祈使句，如Save the record…。然而，由于开头大写及被加了标点，它看起来就像是个完整的句子。</p>
<blockquote>
<p>Tip：一个常见的错误是把简单的Javadoc写成/<strong> @return the customer ID */，这是不正确的。它应该写成/</strong> Returns the customer ID. */。</p>
</blockquote>
<h4 id="7-3-哪里需要使用Javadoc"><a href="#7-3-哪里需要使用Javadoc" class="headerlink" title="7.3 哪里需要使用Javadoc"></a>7.3 哪里需要使用Javadoc</h4><p>至少在每个public类及它的每个public和protected成员处使用Javadoc，以下是一些例外：</p>
<h5 id="7-3-1-例外：不言自明的方法"><a href="#7-3-1-例外：不言自明的方法" class="headerlink" title="7.3.1 例外：不言自明的方法"></a>7.3.1 例外：不言自明的方法</h5><p>对于简单明显的方法如getFoo，Javadoc是可选的(即，是可以不写的)。这种情况下除了写“Returns the foo”，确实也没有什么值得写了。</p>
<p>单元测试类中的测试方法可能是不言自明的最常见例子了，我们通常可以从这些方法的描述性命名中知道它是干什么的，因此不需要额外的文档说明。</p>
<blockquote>
<p>Tip：如果有一些相关信息是需要读者了解的，那么以上的例外不应作为忽视这些信息的理由。例如，对于方法名getCanonicalName， 就不应该忽视文档说明，因为读者很可能不知道词语canonical name指的是什么。</p>
</blockquote>
<h5 id="7-3-2-例外：重写"><a href="#7-3-2-例外：重写" class="headerlink" title="7.3.2 例外：重写"></a>7.3.2 例外：重写</h5><p>如果一个方法重写了超类中的方法，那么Javadoc并非必需的。</p>
<h5 id="7-3-3-可选的Javadoc"><a href="#7-3-3-可选的Javadoc" class="headerlink" title="7.3.3 可选的Javadoc"></a>7.3.3 可选的Javadoc</h5><p>对于包外不可见的类和方法，如有需要，也是要使用Javadoc的。如果一个注释是用来定义一个类，方法，字段的整体目的或行为， 那么这个注释应该写成Javadoc，这样更统一更友好。</p>
<h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3><p>本文档翻译自<a href="http://google-styleguide.googlecode.com/svn/trunk/javaguide.html" target="_blank" rel="noopener">Google Java Style</a>， 译者<a href="http://weibo.com/hawstein" target="_blank" rel="noopener">@Hawstein</a>。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/11/09/树及其操作（C语言版）/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="WeiQingcai">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/head_logo.png">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="程序小栈">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/11/09/树及其操作（C语言版）/" itemprop="url">树及其操作（C语言版）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-11-09T16:49:37+08:00">
                2018-11-09
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/数据结构及算法/" itemprop="url" rel="index">
                    <span itemprop="name">数据结构及算法</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="树及其操作（C语言版）"><a href="#树及其操作（C语言版）" class="headerlink" title="树及其操作（C语言版）"></a>树及其操作（C语言版）</h1><ul>
<li><a href="#%E6%A0%91%E5%8F%8A%E5%85%B6%E6%93%8D%E4%BD%9Cc%E8%AF%AD%E8%A8%80%E7%89%88">树及其操作（C语言版）</a><pre><code>- [树定义和性质：](#%E6%A0%91%E5%AE%9A%E4%B9%89%E5%92%8C%E6%80%A7%E8%B4%A8)
- [二叉树：](#%E4%BA%8C%E5%8F%89%E6%A0%91)
- [线索二叉树：](#%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91)
- [树的存储结构：](#%E6%A0%91%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84)
- [树的实现：](#%E6%A0%91%E7%9A%84%E5%AE%9E%E7%8E%B0)
</code></pre></li>
</ul>
<h3 id="树定义和性质："><a href="#树定义和性质：" class="headerlink" title="树定义和性质："></a>树定义和性质：</h3><ol>
<li><p><strong>树的定义：</strong> 树是n个（n&gt;=0）有限节点组成一个具有层次关系的集合。</p>
</li>
<li><p><strong>根及子树：</strong> 在任意一个非空树中，有且仅有一个特定的称为根的结点，当n&gt;1时，其余结点又可以分为m（m&gt;0）个互不相交的有限集$ T_1,T_2,…T_m$,其中每一个集合本身又是一颗树，并称为根的子树。</p>
</li>
<li><p><strong>基本操作：</strong></p>
<ul>
<li>InitTree(&amp;T):构造一颗空树</li>
<li>DestroyTree(&amp;T):销毁一颗树</li>
<li>ClearTree(&amp;T):清空一颗树</li>
<li>TreeDepth(&amp;T):求一颗树的深度</li>
<li>TraverseTree(&amp;T,Visit()):遍历树 </li>
</ul>
</li>
<li><p><strong>结点：</strong> 树中包含一个数据元素和若干指向其子树的分支的集合叫做树的结点</p>
</li>
<li><p><strong>度：</strong> 结点拥有的子树称为结点的度</p>
</li>
<li><p><strong>叶子(终端结点)：</strong> 度为0的结点称为终端结点或者是叶子</p>
</li>
<li><p><strong>分支结点(非终端结点)：</strong> 度不为0的结点称为分支结点或者是非终端结点。</p>
</li>
<li><p><strong>孩子/双亲/兄弟：</strong> 结点的子树称为该结点的孩子，相应的，该结点称为孩子的双亲，同一个双亲的孩子互称兄弟。</p>
</li>
<li><p><strong>祖先/子孙</strong> 结点的祖先是从根到该节点所经过的分支上的所有结点，反之，以某结点为根的子树中的任意结点都是该节点的子孙。</p>
</li>
<li><p><strong>结点的层次：</strong> 结点的层次从根开始算起，根为第一层，根的孩子为第二层…..</p>
</li>
<li><p><strong>树的深度：</strong> 树中结点的最大层次称为树的深度或者是高度</p>
</li>
<li><p><strong>有序树/无序树：</strong> 如果树中结点的各子树看成从左到右是有次序的（不能互换），则树称为有序树，否则称为无序树。</p>
</li>
<li><p><strong>森林：</strong> m（m&gt;=0）颗互不相交的树的集合</p>
</li>
</ol>
<h3 id="二叉树："><a href="#二叉树：" class="headerlink" title="二叉树："></a>二叉树：</h3><ol>
<li><p><strong>定义：</strong> 树中每个结点最多只有两颗子树（即结点的度不大于2），而且子树有左右之分（子树次序不能任意颠倒）的树称为二叉树。</p>
</li>
<li><p><strong>满二叉树：</strong>一颗深度为$k$且有$2^k-1$个结点的树称为满二叉树</p>
</li>
<li><p><strong>完全二叉树：</strong>深度为$k$，有n个结点的二叉树，当且仅当其每一个结点都与深度为$k$的满二叉树中编号从1至n的结点一一对应时，称之为完全二叉树。 </p>
</li>
<li><p><strong>二叉树性质</strong>：</p>
<ul>
<li>在二叉树的第$i$层上最多有$2^(i-1)$个结点（i&gt;=1）</li>
<li>深度为$k$的二叉树最多有$2^k-1$个结点（k&gt;=1）</li>
<li>对任何一个二叉树T，如果其终端结点数为$n_0$,度为2的结点数为$n_2$,则$n_0 = n_2+1$</li>
</ul>
</li>
<li><p><strong>完全二叉树的性质</strong></p>
<ul>
<li>具有n个结点的完全二叉树的深度为$\lfloor log_(2^n) \rfloor+1$</li>
</ul>
</li>
</ol>
<h3 id="线索二叉树："><a href="#线索二叉树：" class="headerlink" title="线索二叉树："></a>线索二叉树：</h3><ol>
<li>定义：若做如下规定：若结点有左子树，则其lchild域指示其左孩子，否则令其指向其前驱，同样的，若结点有右子树，则其rchild域指向其右孩子，否则令其指向其后继。为了区分，我们增设一个tag字段。</li>
</ol>
<p>$$  LTag =<br>\begin{cases}<br>0  &amp; \text{lchild域指示结点的左孩子} \<br>1 &amp; \text{lchild域指示结点的前驱}<br>\end{cases}$$<br>$$  RTag =<br>\begin{cases}<br>0  &amp; \text{lchild域指示结点的右孩子} \<br>1 &amp; \text{lchild域指示结点的后继}<br>\end{cases}$$<br>以这种结点结构构成的二叉链表表示的二叉树叫做线索二叉树，其中指向前驱和后继的指针叫做线索。</p>
<ol start="2">
<li>线索化：以某种遍历顺序使二叉树称为线索二叉树的过程叫做二叉树的线索化</li>
</ol>
<h3 id="树的存储结构："><a href="#树的存储结构：" class="headerlink" title="树的存储结构："></a>树的存储结构：</h3><ol>
<li>双亲表示法：</li>
</ol>
<p>以一组连续的空间存储树的结点，同时在每一个结点中附设一个指示器指示其双亲结点在链表中的位置</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_TREE_SIZE 100</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">PTNode</span>&#123;</span><span class="comment">//结点结构</span></span><br><span class="line">    TElemTye data;<span class="comment">//数据元素类型</span></span><br><span class="line">    <span class="keyword">int</span> parent;<span class="comment">//双亲结点域</span></span><br><span class="line">&#125;PTNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span><span class="comment">//树结构</span></span><br><span class="line">    PTNode nodes[MAX_TREE_SIZE];<span class="comment">//存储的结点</span></span><br><span class="line">    <span class="keyword">int</span> r,n;<span class="comment">//根的位置和节点数</span></span><br><span class="line">&#125;PTNode;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>孩子表示法：</li>
</ol>
<p>把每个结点的孩子结点排列起来，看成一个线性表，并且以单链表做存储结构，则n个结点有n个孩子链表（叶节点的孩子链表为空表），而n个头结点又组成一个线性表。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_TREE_SIZE 100</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">CTNode</span>&#123;</span><span class="comment">//孩子结点</span></span><br><span class="line">    <span class="keyword">int</span> child;<span class="comment">//孩子数</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">CTNode</span>* <span class="title">next</span>;</span><span class="comment">//下一个孩子结点指针</span></span><br><span class="line">&#125;* ChildPtr;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    TElemType data;<span class="comment">//数据域</span></span><br><span class="line">    ChildPtr firstChild;<span class="comment">//孩子链表头指针</span></span><br><span class="line">&#125;CTBox;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    CTBox nodes[MAX_TREE_SIZE];<span class="comment">//存储的结点</span></span><br><span class="line">    <span class="keyword">int</span> n,r;<span class="comment">//结点和根的位置</span></span><br></pre></td></tr></table></figure>
<ol start="3">
<li>孩子兄弟表示法：</li>
</ol>
<p>又称二叉树表示法，或者二叉链表表示法。链表中结点的两个链域分别指向该节点的第一个孩子结点和下一个兄弟结点</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">CSNode</span>&#123;</span></span><br><span class="line">    TElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">CSNode</span> *<span class="title">firstChild</span>, *<span class="title">nextSibling</span>;</span></span><br><span class="line">&#125;CSNode , *CSTree;</span><br></pre></td></tr></table></figure>
<h3 id="树的实现："><a href="#树的实现：" class="headerlink" title="树的实现："></a>树的实现：</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;malloc.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *定义的树节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span>&#123;</span></span><br><span class="line">    <span class="keyword">char</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> *<span class="title">Lchild</span>,*<span class="title">Rchild</span>;</span></span><br><span class="line">&#125;BiTNode, *BiTree;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">递归方式，先序遍历建立二叉树</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">createBiTree</span><span class="params">(BiTree *T)</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> ch;</span><br><span class="line">    <span class="comment">//读取字符</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%c"</span>,&amp;ch);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(ch == <span class="string">' '</span>)&#123;</span><br><span class="line">        *T = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">//申请新的结点空间</span></span><br><span class="line">        <span class="keyword">if</span>(!(*T = (BiTNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BiTNode))))&#123;</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        (*T)-&gt;data = ch;</span><br><span class="line">        createBiTree(&amp;((*T)-&gt;Lchild));</span><br><span class="line">        createBiTree(&amp;((*T)-&gt;Rchild));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*先序遍历*/</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">preOrderTraverse</span><span class="params">(BiTree T,<span class="keyword">bool</span> (*printElem)(<span class="keyword">char</span> elem))</span></span>&#123;</span><br><span class="line">    <span class="comment">//检验是否为空</span></span><br><span class="line">    <span class="keyword">if</span>(T)&#123;</span><br><span class="line">        <span class="keyword">if</span>(printElem(T-&gt;data))&#123;<span class="comment">//打印根元素的值</span></span><br><span class="line">            <span class="keyword">if</span>(preOrderTraverse(T-&gt;Lchild,printElem))&#123;<span class="comment">//打印左子树</span></span><br><span class="line">                <span class="keyword">if</span>(preOrderTraverse(T-&gt;Rchild,printElem))&#123;<span class="comment">//打印右子树</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 打印函数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">printElem</span><span class="params">(<span class="keyword">char</span> elem)</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%c\n"</span>,elem);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;   BiTree tree;</span><br><span class="line">    <span class="keyword">bool</span> res;</span><br><span class="line">    res = createBiTree(&amp;tree);</span><br><span class="line">    <span class="keyword">if</span>(res)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"建立成功\n"</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"建立失败\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//先序遍历打印树</span></span><br><span class="line">    preOrderTraverse(tree,printElem);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/11/09/图及其操作（C语言版）/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="WeiQingcai">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/head_logo.png">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="程序小栈">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/11/09/图及其操作（C语言版）/" itemprop="url">图及其操作（C语言版）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-11-09T16:49:37+08:00">
                2018-11-09
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/数据结构及算法/" itemprop="url" rel="index">
                    <span itemprop="name">数据结构及算法</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="图及其操作（C语言版）"><a href="#图及其操作（C语言版）" class="headerlink" title="图及其操作（C语言版）"></a>图及其操作（C语言版）</h1><h3 id="图的定义和性质："><a href="#图的定义和性质：" class="headerlink" title="图的定义和性质："></a><strong>图的定义和性质：</strong></h3><ol>
<li><p><strong>定义:</strong> 图是由顶点的有穷非空集合和顶点之间边的集合组成，通常表示为：G(V,R)，其中，G表示一个图，V是图G中顶点的集合，R是图G中边的集合。</p>
</li>
<li><p><strong>顶点：</strong> 在图中的数据元素通常叫做顶点。</p>
</li>
<li><p><strong>弧头/弧尾：</strong> 若$&lt;v,w&gt;\in VR$则$&lt;v,w&gt;$表示从$v$到 $w$的一条弧，且称$v$为弧尾或初始点，称$w$为弧头或终端点。</p>
</li>
<li><p><strong>有向图：</strong> 若图中的边是有向的，即$&lt;v,w&gt;\in VR \neq &lt;w,v&gt;\in VR$此时的图称为有向图。  </p>
</li>
<li><p><strong>无向图：</strong> 若$&lt;v,w&gt;\in VR$ 必有 $&lt;w,v&gt;\in VR$,即$VR$是对称的，则以无序对$(v,w)$代替两个有序对，表示v,w之间的一条边，此时的图称为无向图。</p>
</li>
<li><p><strong>完全图：</strong> 若用n表示图中的顶点数，用e表示图中弧或者边的数目，在下边的讨论中，我们不考虑顶点到其自身的边或者弧。</p>
<ul>
<li>对于无向图来说：$0\le e \le \frac{1}{2}n(n-1) $,有$\frac{1}{2}n(n-1)$条边的无向图称为完全图</li>
<li>对于有向图来说：$0\le e \le n(n-1) $,有$ n(n-1)$条弧的有向图称为有向安完全图。</li>
</ul>
</li>
<li><p><strong>稀疏图/稠密图：</strong> 有很多条边或者弧的图称为稠密图，反之称为稀疏图$例如：(e\lt n\log{n})$</p>
</li>
<li><p><strong>权：</strong> 有时边或者弧有和他相关的数，这种与图的边或者弧相关的数叫做权。这些权可以表示一个顶点到另一个顶点的距离或者消耗。</p>
</li>
<li><p><strong>网：</strong> 带权的图称为网。</p>
</li>
<li><p><strong>子图：</strong> 假设有两个图$G={V,{R} }$和$G^<code>=\{ V^</code>,{R^<code>\}\}$，如果$V^</code> \subseteq V $且$R^<code>\subseteq R  $,则称$G^</code>$为$G$的子图</p>
</li>
<li><p><strong>邻接点：</strong></p>
<ul>
<li>对于无向图：$G={V,{R} }$,如果边$(v,v^<code>) \in R$,则称顶点$v$ 和互为邻接点$v^</code>$，边$(v,v^<code>) $依附于顶点$v$和$v^</code>$。或者说边$(v,v^<code>) $和顶点$v$和$v^</code>$相关联。</li>
<li>对于有向图：$G={V,{A} }$,如果弧$&lt;v,v^1&gt; \in A$,则称顶点$v$邻接到顶点$v^<code>$，顶点$v^</code>$邻接到顶点$v$,弧$&lt;v,v^<code>&gt;$和顶点$v$，$v^</code>$相关联。</li>
</ul>
</li>
<li><p><strong>无向图顶点的度：</strong> 在无向图中，顶点v的度是和顶点v相关联的边的数目，记做$TD(v)$</p>
</li>
<li><p><strong>有向图顶点的度：</strong></p>
<ul>
<li>入度：在有向图中，顶点v的入度是指以顶点v为头的弧的数目</li>
<li>出度：在有向图中，顶点v的出度是指以顶点v为尾的弧的数目</li>
</ul>
</li>
<li><p><strong>顶点，边(弧)，度之间的关系：</strong> 一般的，如果顶点$v_i$的度记为$TD(v_i)$，那么一个有$n$个顶点，$e$条边或者弧的图，满足如下关系：$$e=\frac{1}{2} \sum_{i=1}^nTD(v_i)$$</p>
</li>
<li><p><strong>图的路径：</strong>无向图$G={V,{E } }$中从顶点$V$到顶点$V^<code>$的路径是一个顶点序列$(v=v_{i,0},v_{i,1},...,v_{i,m}=v^</code>)$其中$(v_{i,j-1},v_{i,j}) \in E,1 \le j \le m$。如果G是有向图，则路径也是有向的。</p>
</li>
<li><p><strong>路径的长度：</strong>路径上边或者弧的数目</p>
</li>
<li><p><strong>回路/环</strong>第一个顶点和最后一个顶点相同的路径称为回路或者环。除了第一个和最后一个顶点之外，其余顶点不重复出现的回路，称为简单回路或者简单环。</p>
</li>
<li><p><strong>连通图：</strong>在无向图G中，如果从顶点$v$到顶点$v^<code>$有路径，则称$v$和$v^</code>$是连通的。若对于图中任意两个顶点$v_i$、$v_j\in V$，$v_i$和$v_j$都连通，则称G是连通图。</p>
</li>
<li><p><strong>连通分量：</strong>无向图中的极大连通子图称为是该图的连通分量。</p>
</li>
<li><p><strong>强连通图：</strong>在有向图G中，如果对于每一对$v_i,v_j \in V ,v_i \neq v_j$ ,从对$v_i到v_j$和从$v_j到v_i$都存在路径，则称G是强连通图。</p>
</li>
<li><p><strong>强连通分量：</strong>有向图中的极大连通子图称作有向图的强连通分量。</p>
</li>
<li><p><strong>连通图的生成树：</strong>一个连通图的生成树是一个极小连通子图，他含有图中的全部顶点，但是只含有构成一颗树的$n-1$条边。</p>
</li>
<li><p><strong>性质：</strong></p>
<ul>
<li>一颗有n个顶点的生成树有且只有n-1条边</li>
<li>如果一个图有n个顶点和小于n-1条边，则是非连通图。若多于n-1条边，则一定有环。</li>
<li>如果一个有向图恰有一个顶点的入度为0，其余顶点的入度均为1，则是一颗有向树。</li>
</ul>
</li>
</ol>
<h3 id="图的存储结构："><a href="#图的存储结构：" class="headerlink" title="图的存储结构："></a><strong>图的存储结构：</strong></h3><ol>
<li><strong>数组表示法：</strong></li>
</ol>
<p>用两个数组分别存储数据元素(顶点)的信息和数据之间的关系(边或弧)的信息。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**数组表示法（邻接矩阵）**/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INFINITY INT_MAX<span class="comment">//整数类型最大值</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_VERTEX_NUM 20<span class="comment">//最大顶点个数</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span>&#123; DG,DN,uDG,UDN&#125; GraphKind;<span class="comment">//&#123;有向图，有向网，无向图，无向网&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ArcCell</span>&#123;</span></span><br><span class="line">    VRType adj;<span class="comment">//弧或者边的类型：对于无权图，用0或者1表示是否相邻</span></span><br><span class="line">               <span class="comment">//对带权图，则为权值类型</span></span><br><span class="line">    InfoType *inform;<span class="comment">//改弧相关的信息指针</span></span><br><span class="line">&#125;ArcCell, AdjMatrix[MAX_VERTEX_NUM][MAX_VERTEX_NUM];</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    VertexType vexs[MAX_VERTEX_NUM];<span class="comment">//顶点向量</span></span><br><span class="line">    AdjMatrix arcs;<span class="comment">//邻接矩阵</span></span><br><span class="line">    <span class="keyword">int</span> vexNum,arcNum;<span class="comment">//图的当前顶点数量，边或者弧数量</span></span><br><span class="line">    GraphKind kind;<span class="comment">//图类型</span></span><br><span class="line">&#125;MGraph;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li><strong>邻接表：</strong><br>邻接表是图的一种链式存储结构。在邻接表中，对图中的每个顶点建立一个单链表，第$i$个单链表中的结点表示依附于顶点$v_i$的边（对有向图是以顶点$v_i$为尾的弧）。每个结点由3个域组成，其中邻接点域（adjvex）指示指示与顶点$v_i$邻接的点在图中的位置，链域（nextarc）指示下一条边或者弧的结点，数据域（info）存储和边或者弧相关的信息(如权值等)。在表头结点中除了设有链域（firstarc），指向链表中的第一个结点外，还设有存储顶点$v_i$的名或者其他有关信息的数据域（data）。<br><img src="http://img.blog.csdn.net/20160923192701459" alt="表结点"><br><img src="http://img.blog.csdn.net/20160923192718912" alt="头结点"></li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/11/09/渗透测试--密码攻击初识/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="WeiQingcai">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/head_logo.png">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="程序小栈">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/11/09/渗透测试--密码攻击初识/" itemprop="url">渗透测试--密码攻击初识</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-11-09T16:49:37+08:00">
                2018-11-09
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/网络安全/" itemprop="url" rel="index">
                    <span itemprop="name">网络安全</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="渗透测试–密码攻击初识"><a href="#渗透测试–密码攻击初识" class="headerlink" title="渗透测试–密码攻击初识"></a>渗透测试–密码攻击初识</h2><h3 id="一-密码在线攻击"><a href="#一-密码在线攻击" class="headerlink" title="一.  密码在线攻击"></a><strong>一.  密码在线攻击</strong></h3><p><strong>1. Hydra工具</strong></p>
<p>Hydra支持几乎所有协议的在线破解密码，同时也提供命令行和GUI界面两种操作方式通过Hydra-gtk来启动图形化界面。</p>
<p><strong>2. Medusa工具</strong></p>
<p>Medusa通过并行登录暴力破解的方式来尝试获取远程验证服务访问权限。可以通过medusa命令直接启动工具</p>
<h3 id="二-分析密码"><a href="#二-分析密码" class="headerlink" title="二.  分析密码"></a><strong>二.  分析密码</strong></h3><p><strong>1.  Ettercap工具</strong></p>
<p>Ettercap是一个强大的欺骗工具，使用该工具可以快速的构建伪造的各类型数据包，实现从网络适配器到应用软件的各种级别的包，并绑定监听数据到本地端口等。通过对目标系统的信息收集，可以构建可能的密码字典。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>. 配置Ettercap的配置文件etter.conf</span><br><span class="line">	<span class="number">1</span>. 查找配置文件： locate etter.conf</span><br><span class="line">	<span class="number">2</span>. 修改配置文件： vim /etc/ettercap/etter.conf</span><br><span class="line">	<span class="number">3</span>. 将ec_uid 和 ec_gid配置项的值改为<span class="number">0</span>;将Linux部分附近的IPTABLES行的注释去掉</span><br><span class="line"><span class="number">2</span>. 启动Ettercap</span><br><span class="line">	ettercap -G    #-G参数可以启动图形化界面</span><br></pre></td></tr></table></figure>
<p><strong>2.  使用Metasploit中的模块</strong></p>
<p>Metasploit框架中的search_email_collector可以搜集一个组织相关的各种邮件，通过邮件信息可以构建一个密码字典，该模块位于auxiliary/gather/search_email_collector。</p>
<p><strong>3.  Hash值识别工具Hash Identity</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>. 启动Hash Identity</span><br><span class="line">	hash identifier</span><br><span class="line"><span class="number">2</span>. 输入Hash值，可以查出最可能的Hash加密算法</span><br></pre></td></tr></table></figure>
<p><strong>4.  findmyhash用于破解LM Hash</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">findmyhash [Encryption] -h hash</span><br><span class="line"></span><br><span class="line">注： [Encryption] 指定使用的Hash加密算法</span><br><span class="line">	-h		指定要破解的LM Hash值</span><br></pre></td></tr></table></figure>
<h3 id="三-创建密码字典"><a href="#三-创建密码字典" class="headerlink" title="三.  创建密码字典"></a><strong>三.  创建密码字典</strong></h3><p><strong>1.  Crunch工具</strong></p>
<p>Crunch工具是一种密码创建工具，其生成的密码可以发送到终端，文件或另一程序。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">crunch [minimun length] [maximum length] [character set][options]</span><br><span class="line"></span><br><span class="line">注: </span><br><span class="line">	[minimun length]	 密码最小长度</span><br><span class="line">	[maximum length]	 密码最大长度</span><br><span class="line">	[character set]  	 密码使用的字符集</span><br><span class="line">	[options]  		 可以选用的参数：</span><br><span class="line">    					-o：用于指定输出字典文件的位置</span><br><span class="line">						-b：指定写入文件的最大字节数，必须和-o选项一起使用</span><br><span class="line">                        -t：设置使用的特殊格式</span><br><span class="line">                        -l：该选项在-t选项指定@，%或^字符时，用来识别一些占位符</span><br></pre></td></tr></table></figure>
<p><strong>2.  rtgen工具</strong></p>
<p>rtgen工具用于生成彩虹表，可以针对各种算法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rtgen [加密算法] [彩虹表]</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/11/09/计算机网络基础汇总/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="WeiQingcai">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/head_logo.png">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="程序小栈">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/11/09/计算机网络基础汇总/" itemprop="url">计算机网络基础汇总</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-11-09T16:49:37+08:00">
                2018-11-09
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/网络安全/" itemprop="url" rel="index">
                    <span itemprop="name">网络安全</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="计算机网络体系分类："><a href="#计算机网络体系分类：" class="headerlink" title="计算机网络体系分类："></a>计算机网络体系分类：</h1><p>计算机网络整个体系有两个大的分类：一个是国际组织制定的OSI七层模型，一种是实际使用中的TCP/IP四层模型。</p>
<table>
<thead>
<tr>
<th>OSI七层模型</th>
<th>TCP/IP四层模型</th>
</tr>
</thead>
<tbody>
<tr>
<td>应用层</td>
</tr>
<tr>
<td>表示层</td>
<td>应用层</td>
</tr>
<tr>
<td>会话层</td>
</tr>
<tr>
<td>传输层</td>
<td>传输层</td>
</tr>
<tr>
<td>网络层</td>
<td>网络层</td>
</tr>
<tr>
<td>数据链路层</td>
<td>物理接入层</td>
</tr>
<tr>
<td>物理层</td>
</tr>
</tbody>
</table>
<h1 id="物理层："><a href="#物理层：" class="headerlink" title="物理层："></a>物理层：</h1><p>物理层主要是实现主机和网络之间的物理连接，规定一些与传输媒体接口有关的一些特性。</p>
<h2 id="通信方式："><a href="#通信方式：" class="headerlink" title="通信方式："></a>通信方式：</h2><ul>
<li><p><strong>单工通信：</strong> 只能由A主机向B主机发送消息，通信是单向的。</p>
</li>
<li><p><strong>半双工通信：</strong>同一时间只能是由A主机向B主机或者是B主机向A主机发送信息，不能同时发送消息。</p>
</li>
<li><p><strong>全双工通信：</strong> A主机和B主机可以实现在同一时间内既接收消息，又发送消息，极大的提升了通信效率。</p>
</li>
</ul>
<h2 id="常见引导型传输媒体："><a href="#常见引导型传输媒体：" class="headerlink" title="常见引导型传输媒体："></a>常见引导型传输媒体：</h2><h3 id="双绞线："><a href="#双绞线：" class="headerlink" title="双绞线："></a>双绞线：</h3><p>分为屏蔽双绞线（STP）和非屏蔽双绞线（UTP），屏蔽双绞线就是在非屏蔽双绞线外边又加了一层屏蔽层</p>
<p>tips：为什么双绞线要两根线绞起来，两个线绞起来可以有效的减少相互之间的电磁干扰。</p>
<h3 id="同轴电缆："><a href="#同轴电缆：" class="headerlink" title="同轴电缆："></a>同轴电缆：</h3><p>由内导体铜制芯线，绝缘层，网状编织的外导体屏蔽层，以及塑料保护外层组成。有良好的抗干扰性，被广泛用于较高速率的传输。</p>
<h3 id="光缆："><a href="#光缆：" class="headerlink" title="光缆："></a>光缆：</h3><p>由非常透明的石英玻璃拉成细丝，主要由纤芯和包层构成双层通讯柱。可以分为单模光纤和多模光纤。</p>
<h2 id="信道复用技术："><a href="#信道复用技术：" class="headerlink" title="信道复用技术："></a>信道复用技术：</h2><ul>
<li><p><strong>频分复用：</strong>根据传输的波的频率的不同，将不同频段的波用于不同的通信。</p>
</li>
<li><p><strong>时分复用：</strong>将时间分割为时间段，规定在某个时间段内发送什么样的信息，根据时间段来进行信息类别的区分。也称为<strong>同步时分复用</strong></p>
</li>
<li><p><strong>统计时分复用：</strong>基于时分复用的一种改进，由于基本的时分复用并没有考虑到每个时间段内是否有信息发出，例如说每个时间段是20，但是发送消息只占用其中的2，那么剩下的18就处于空闲时间。统计时分复用就是基于这种考虑而设计的，他允许用户有数据时就将数据发送到缓存中，然后会依次扫描输入缓存，把缓存中的数据放入到STMD帧中，若没有就跳过，每当一个帧满了就把这个帧发出去。STMD帧不是分配的固定时序，而是根据需要动态的分配时隙，也称之为<strong>异步时分复用</strong></p>
</li>
<li><p>光分复用：就是光的频分复用，根据光谱中频率的不同，用不同频率的光来携带不同的信息。</p>
</li>
</ul>
<h1 id="数据链路层："><a href="#数据链路层：" class="headerlink" title="数据链路层："></a>数据链路层：</h1><p>数据链路层主要是将上层的数据转化为数据帧发送到链路上，以及把接受到的帧中的数据取出并交给网络层。</p>
<h2 id="通信方式：-1"><a href="#通信方式：-1" class="headerlink" title="通信方式："></a>通信方式：</h2><ul>
<li><p><strong>点对点通信：</strong>通信方式是点到点的，也就是只能是两个点之间的通信。常见的就是PPP协议</p>
</li>
<li><p><strong>广播通信：</strong>广播通讯，也就是可以同时实现一对多的通信。常见的就是CSMA/CD（载波监听多点访问/冲突检测）</p>
</li>
</ul>
<h2 id="核心要解决的问题："><a href="#核心要解决的问题：" class="headerlink" title="核心要解决的问题："></a>核心要解决的问题：</h2><ul>
<li><p><strong>封装成帧：</strong>在一段数据的前后分别添加首部和尾部，这样就构成了一个帧。接收端在接受到后就可以方便准确的确定帧的首尾，也称为帧定界符。同时定义出了最大传输单元（MTU）–表示一次可以传输的最大长度上限。</p>
</li>
<li><p><strong>透明传输：</strong> 由于使用特定的字符来表示帧的开始和结束，所以传输的内容中不能出现和帧定界符相同的字符，但这显然是不可能的，为了解决这个办法，就可以在内容中和帧定界符一样的字符前边加上规定好的转义字符，这种方法称为字符填充或者是字节填充。</p>
</li>
<li><p><strong>差错检测：</strong> 比特在传输过程中可能产生差错，差错检测就是用于检测出现的差错，以便及时的重传，最常用的差错检测算法就是<a href="http://baike.sogou.com/v7730112.htm?fromTitle=CRC%E6%A0%A1%E9%AA%8C" target="_blank" rel="noopener">CRC（循环冗余检验）</a></p>
</li>
</ul>
<h1 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h1><p>网络层主要是向上只提供简单灵活的，无连接的，尽最大努力交付的数据报服务。</p>
<h2 id="IP协议（网际协议）："><a href="#IP协议（网际协议）：" class="headerlink" title="IP协议（网际协议）："></a>IP协议（网际协议）：</h2><p>IP协议是TCP/IP体系中最主要的协议之一，一切在IP之下，一切又在IP之上。我们常说的应该是IP协议族，还包含配套的协议：</p>
<ul>
<li><p>ARP（地址解析协议）：将网络的IP地址转化为实际的物理地址（MAC地址），并存储在MAC地址表中。</p>
</li>
<li><p>ICMP（网际控制报文协议）：用于进行差错情况和异常情况的反馈，分为询问报文和差错报告报文。</p>
</li>
<li><p>IGMP（网际组管理协议）：用于控制和管理多播和组播的协议。</p>
</li>
</ul>
<p>网络地址（IP地址）主要分为五类：</p>
<ul>
<li><p>A类：前8位为网络位，后24位为主机位，首位为0</p>
</li>
<li><p>B类：前16位为网络位，后16位为主机位，前两位为10</p>
</li>
<li><p>C类：前24位为网络位，后8位位主机位，前三位为110</p>
</li>
<li><p>D类：前四位为1110，用于多播地址</p>
</li>
<li><p>E类：前四位为1111，保留为以后使用</p>
</li>
</ul>
<h2 id="路由选择协议："><a href="#路由选择协议：" class="headerlink" title="路由选择协议："></a>路由选择协议：</h2><p>路由选择协议分为<strong>内部网关协议（IGP）</strong>和<strong>外部网关协议（EGP）</strong></p>
<h3 id="内部网关协议："><a href="#内部网关协议：" class="headerlink" title="内部网关协议："></a>内部网关协议：</h3><p>主要是有RIP协议和OSPF协议</p>
<ul>
<li><p><strong>RIP协议（路由信息协议）：</strong>基于距离矢量的协议</p>
</li>
<li><p><strong>OSPF（开放最短路径优先协议）：</strong>基于链路状态的协议</p>
</li>
</ul>
<h3 id="外部网关协议："><a href="#外部网关协议：" class="headerlink" title="外部网关协议："></a>外部网关协议：</h3><p>主要是<strong>边界网关协议（BGP）</strong>，将一个大的网络分为多个小的自治域，每个自治域内有一个网关路由负责和其他的自治域的网关进行通讯。</p>
<h1 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h1><p>网络层主要是为主机之间提供逻辑通讯，而传输层为应用程序之间提供端到端的逻辑通讯。主要是两种类型的通讯方式，面向连接的TCP协议和面向无连接的UDP。</p>
<h2 id="端口号："><a href="#端口号：" class="headerlink" title="端口号："></a>端口号：</h2><p>端口号按照使用地方的不同分为两大类：服务端端口号，客户端端口号。<br>按照占用时长又可以分为熟知端口号（0~1023），登记端口号（1024~49151），短暂端口号（49152~65535）</p>
<h3 id="常见端口："><a href="#常见端口：" class="headerlink" title="常见端口："></a>常见端口：</h3><ul>
<li><p>FTP（文件传输协议）：20，21——其中20端口用于传输数据，21端口用于命令控制</p>
</li>
<li><p>Telnet（远程登录协议）：23 </p>
</li>
<li><p>DNS（域名解析服务）：53</p>
</li>
<li><p>TFTP（简单文件传输协议）：69</p>
</li>
<li><p>HTTP（超文本传输协议）：80</p>
</li>
</ul>
<h2 id="两种协议："><a href="#两种协议：" class="headerlink" title="两种协议："></a>两种协议：</h2><ul>
<li><p><strong>UDP（用户数据报协议）：</strong> </p>
<ul>
<li>UDP是无连接的</li>
<li>UDP使用尽最大努力交付，但是不保证可靠交付</li>
<li>UDP是面向报文的</li>
<li>UDP没有拥塞控制</li>
<li>UDP支持一对一，一对多，多对一，多对一的交互通讯</li>
<li>UDP首部的开销小</li>
</ul>
</li>
<li><p><strong>TCP（传输控制协议）：</strong></p>
<ul>
<li>TCP是面向连接的</li>
<li>每一条TCP连接只能由两个端点，每一条TCP连接只能是点对点的$TCP连接：：= { socket_1,socket_2 } ={ (IP_1:port_1),(IP_2:port_2)}$</li>
<li>TCP提供可靠交付的服务</li>
<li>TCP提供全双工通信</li>
<li>面向字节流</li>
</ul>
</li>
</ul>
<h3 id="可靠传输的实现机制："><a href="#可靠传输的实现机制：" class="headerlink" title="可靠传输的实现机制："></a><strong>可靠传输的实现机制：</strong></h3><h4 id="停止等待协议："><a href="#停止等待协议：" class="headerlink" title="停止等待协议："></a><strong>停止等待协议：</strong></h4><p>每发完一个分组就停止发送，直到收到上一个分组的确认信息。若超过规定时间没有接收到确认信息，边认为是分组丢失，开始重传。</p>
<h4 id="连续ARQ协议："><a href="#连续ARQ协议：" class="headerlink" title="连续ARQ协议："></a><strong>连续ARQ协议：</strong></h4><p>发送方采用滑动窗口的形式，处于滑动窗口的分组可以直接发送出去；接收方一般采用累积确认的方式，也就是说接受方不必对接收到的每一个分组都进行确认，而是对按序到达的最后一个分组进行确认，而发送方每接收到一个确认，窗口就向前滑动一定距离。</p>
<h4 id="流量控制："><a href="#流量控制：" class="headerlink" title="流量控制："></a><strong>流量控制：</strong></h4><p>协调发送方和接收方的收发速率，利用滑动窗口来协调，使用探测报文来探测当前应该发送的速率，采用<a href="http://baike.sogou.com/v10500918.htm?fromTitle=Nagle%E7%AE%97%E6%B3%95" target="_blank" rel="noopener">Nagle算法</a></p>
<h4 id="拥塞控制："><a href="#拥塞控制：" class="headerlink" title="拥塞控制："></a><strong>拥塞控制：</strong></h4><p>当网络中某一资源的需求超出了该资源所能提供的可用部分，这时网络的性能就要开始变坏，这种情况就叫做拥塞。而拥塞控制就是为了减少或者避免拥塞对网络性能的影响而做出的一种控制手段。</p>
<ul>
<li><p><strong>拥塞控制思路：</strong> 发送方维持一个叫做<strong>拥塞窗口</strong>的状态变量，拥塞窗口的大小取决于网络的拥塞程度，并且在动态的变化。发送方让自己的发送窗口等于拥塞窗口，如果在考虑接收方的接收能力，一般发送窗口还要小于拥塞窗口。</p>
</li>
<li><p><strong>慢开始：</strong> 当主机开始发送数据的时候，由小到大的增大发送窗口，也就是由小到大的增大拥塞窗口。接收方接收到一个报文之后就回传一个确认报文，发送方每接收到一个确认报文，就将拥塞窗口加1，这样每经过一个传输轮次之后，拥塞窗口就增大一倍。</p>
</li>
<li><p><strong>拥塞避免：</strong> 思路是让拥塞窗口缓慢的增大，即每经过一个往返时间RTT就把发送方的拥塞窗口加1，而不是加倍，这样拥塞窗口就是线性缓慢增加，比慢开始的增长速率缓慢的多。</p>
</li>
<li><p><strong>慢开始门限：</strong> 为了防止拥塞窗口增长过大引起网络拥塞，还需要设置一个慢开始门限</p>
<ul>
<li>拥塞窗口&lt;慢开始门限时，使用慢开始算法</li>
<li>拥塞窗口&gt;慢开始门限时，使用拥塞避免算法</li>
<li>拥塞窗口=慢开始门限时，两种算法都可以</li>
</ul>
</li>
<li><p><strong>快重传：</strong> 要求收到方每收到一个时序的报文段之后就立即发出重复确认，而不要等到自己发送数据时才进行捎带确认。而发送方只要一连收到三个重复确认就应当立即重传对方尚未接受到的报文，而不必等待为报文设置的重传计时器到期。</p>
</li>
<li><p><strong>快回复：</strong> 与快重传配合使用，当发送方连续收到三个重复确认的时候，就执行“乘法减小”算法，将慢开始门限减半。将拥塞窗口设置为慢开始门限减半之后的值，并开始指向拥塞避免算法。</p>
</li>
</ul>
<h3 id="TCP的连接管理："><a href="#TCP的连接管理：" class="headerlink" title="TCP的连接管理："></a>TCP的连接管理：</h3><h4 id="连接三次握手："><a href="#连接三次握手：" class="headerlink" title="连接三次握手："></a>连接三次握手：</h4><ol>
<li>客户端请求建立连接：SYN=1，seq=x；</li>
<li>服务器对客户端的请求进行响应：SYN=1，ACK=1，seq=y，ack=x+1</li>
<li>客户端对服务器端的响应信息进行回应：ACK=1，seq=x+1，ack=y+1</li>
</ol>
<p><strong>注：</strong> SYN为同步信息，在建立连接过程中始终为1</p>
<h4 id="断开连接四次握手："><a href="#断开连接四次握手：" class="headerlink" title="断开连接四次握手："></a>断开连接四次握手：</h4><ol>
<li>客户端请求断开连接： FIN=1，seq = u；</li>
<li>服务端对客户端的请求应答：ACK=1，seq=v，ack=u+1；</li>
<li>服务端请求断开连接：FIN=1，ACK=1，seq=w，ack=u+1；</li>
<li>客户端对服务端的请求应答：ACK=1，seq=u+1，ack=w+1；</li>
</ol>
<h1 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h1><p>应用层有多种协议，常用到的就是HTTP以及HTTPS。<br><strong>HTTP协议报文格式</strong></p>
<table>
<thead>
<tr>
<th>请求报文</th>
<th>相应报文</th>
</tr>
</thead>
<tbody>
<tr>
<td>请求行（用于区分是请求报文还是响应报文，在响应报文中为状态行）</td>
<td>状态行</td>
</tr>
<tr>
<td>首部行（用来说明浏览器，服务器或者是报文主体的一些信息）</td>
<td>首部行</td>
</tr>
<tr>
<td>空行（用于隔开请求实体和首部行）</td>
<td>空行</td>
</tr>
<tr>
<td>实体主体（用于一些请求或者是响应的的参数内容等）</td>
<td>实体主体</td>
</tr>
</tbody>
</table>
<p><strong>常见状态码</strong></p>
<blockquote>
<p>1xx：表示通知信息，例如表示收到或者是正在处理<br>2xx：表示成功，例如表示接受或知道了<br>3xx：表示重定向，例如表示完成请求还需要采取进一步的行动<br>4xx：表示客户端的差错，例如表示请求中有语法错误或不能完成<br>5xx：表示服务器端的差错：例如表示服务器失效无法完成请求</p>
</blockquote>
<p>HTTPS协议就是对HTTP协议的加密，更加安全可靠，采用HTTP+SSL（安全套接字层）来保证数据的安全性。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/head_logo.png" alt="WeiQingcai">
            
              <p class="site-author-name" itemprop="name">WeiQingcai</p>
              <p class="site-description motion-element" itemprop="description">这是我的小栈，记录点滴</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">11</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">7</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">20</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">本文为博主原创文章，转载请注明出处。</span>

  
</div>









        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
