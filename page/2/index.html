<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta name="description" content="这是我的小栈，记录点滴">
<meta property="og:type" content="website">
<meta property="og:title" content="程序小栈">
<meta property="og:url" content="http://yoursite.com/page/2/index.html">
<meta property="og:site_name" content="程序小栈">
<meta property="og:description" content="这是我的小栈，记录点滴">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="程序小栈">
<meta name="twitter:description" content="这是我的小栈，记录点滴">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"right","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/page/2/">





  <title>程序小栈</title>
  








</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-right 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">程序小栈</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/11/09/面试中的 10 大排序算法总结/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="WeiQingcai">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/head_logo.png">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="程序小栈">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/11/09/面试中的 10 大排序算法总结/" itemprop="url">面试中的十大排序算法总结</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-11-09T16:49:37+08:00">
                2018-11-09
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/数据结构与算法/" itemprop="url" rel="index">
                    <span itemprop="name">数据结构与算法</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2> <b>本文转载自码农网：<a href="http://www.codeceo.com/article/10-sort-algorithm-interview.html#0-tsina-1-10490-397232819ff9a47a7b7e80a40613cfe1" target="_blank" rel="noopener">http://www.codeceo.com/article/10-sort-algorithm-interview.html#0-tsina-1-10490-397232819ff9a47a7b7e80a40613cfe1</a><br> </b></h2>


<p></p><p>查找和排序算法是算法的入门知识，其经典思想可以用于很多算法当中。因为其实现代码较短，应用较常见。所以在面试中经常会问到排序算法及其相关的问题。但万变不离其宗，只要熟悉了思想，灵活运用也不是难事。一般在面试中最常考的是快速排序和归并排序，并且经常有面试官要求现场写出这两种排序的代码。对这两种排序的代码一定要信手拈来才行。还有插入排序、冒泡排序、堆排序、基数排序、桶排序等。面试官对于这些排序可能会要求比较各自的优劣、各种算法的思想及其使用场景。还有要会分析算法的时间和空间复杂度。通常查找和排序算法的考察是面试的开始，如果这些问题回答不好，估计面试官都没有继续面试下去的兴趣都没了。所以想开个好头就要把常见的排序算法思想及其特点要熟练掌握，有必要时要熟练写出代码。</p><p></p>
<p></p><p>接下来我们就分析一下常见的排序算法及其使用场景。限于篇幅，某些算法的详细演示和图示请自行寻找详细的参考。</p><p></p>
<p></p><h2>冒泡排序</h2><p></p>
<p></p><p>冒泡排序是最简单的排序之一了，其大体思想就是通过与相邻元素的比较和交换来把小的数交换到最前面。这个过程类似于水泡向上升一样，因此而得名。举个栗子，对5,3,8,6,4这个无序序列进行冒泡排序。首先从后向前冒泡，4和6比较，把4交换到前面，序列变成5,3,8,4,6。同理4和8交换，变成5,3,4,8,6,3和4无需交换。5和3交换，变成3,5,4,8,6,3.这样一次冒泡就完了，把最小的数3排到最前面了。对剩下的序列依次冒泡就会得到一个有序序列。冒泡排序的时间复杂度为O(n^2)。</p><p></p>
<p></p><p>实现代码：</p><p></p>
<p><div></div></p>
<p><pre>/*<em>
 </em>@Description:&lt;p&gt;冒泡排序算法实现&lt;/p&gt;<br> <em>@author 王旭
 </em>@time 2016-3-3 下午8:54:27<br> */<br>public class BubbleSort {</pre></p>
<pre><code>public static void bubbleSort(int[] arr) {
    if(arr == null || arr.length == 0)
        return ;
    for(int i=0; i&amp;lt;arr.length-1; i++) {
        for(int j=arr.length-1; j&amp;gt;i; j--) {
            if(arr[j] &amp;lt; arr[j-1]) {
                swap(arr, j-1, j);
            }
        }
    }
}

public static void swap(int[] arr, int i, int j) {
    int temp = arr[i];
    arr[i] = arr[j];
    arr[j] = temp;
}
</code></pre><p>}<br></p>
<p></p><h2>选择排序</h2><p></p>
<p></p><p>选择排序的思想其实和冒泡排序有点类似，都是在一次排序后把最小的元素放到最前面。但是过程不同，冒泡排序是通过相邻的比较和交换。而选择排序是通过对整体的选择。举个栗子，对5,3,8,6,4这个无序序列进行简单选择排序，首先要选择5以外的最小数来和5交换，也就是选择3和5交换，一次排序后就变成了3,5,8,6,4.对剩下的序列一次进行选择和交换，最终就会得到一个有序序列。其实选择排序可以看成冒泡排序的优化，因为其目的相同，只是选择排序只有在确定了最小数的前提下才进行交换，大大减少了交换的次数。选择排序的时间复杂度为O(n^2)</p><p></p>
<p></p><p>实现代码：</p><p></p>
<p><div></div></p>
<p><pre>/*<em>
 </em>@Description:&lt;p&gt;简单选择排序算法的实现&lt;/p&gt;<br> <em>@author 王旭
 </em>@time 2016-3-3 下午9:13:35<br> */<br>public class SelectSort {</pre></p>
<pre><code>public static void selectSort(int[] arr) {
    if(arr == null || arr.length == 0)
        return ;
    int minIndex = 0;
    for(int i=0; i&amp;lt;arr.length-1; i++) { //只需要比较n-1次
        minIndex = i;
        for(int j=i+1; j&amp;lt;arr.length; j++) { //从i+1开始比较，因为minIndex默认为i了，i就没必要比了。
            if(arr[j] &amp;lt; arr[minIndex]) {
                minIndex = j;
            }
        }

        if(minIndex != i) { //如果minIndex不为i，说明找到了更小的值，交换之。
            swap(arr, i, minIndex);
        }
    }

}

public static void swap(int[] arr, int i, int j) {
    int temp = arr[i];
    arr[i] = arr[j];
    arr[j] = temp;
}
</code></pre><p>}<br></p>
<p></p><h2>插入排序</h2><p></p>
<p></p><p>插入排序不是通过交换位置而是通过比较找到合适的位置插入元素来达到排序的目的的。相信大家都有过打扑克牌的经历，特别是牌数较大的。在分牌时可能要整理自己的牌，牌多的时候怎么整理呢？就是拿到一张牌，找到一个合适的位置插入。这个原理其实和插入排序是一样的。举个栗子，对5,3,8,6,4这个无序序列进行简单插入排序，首先假设第一个数的位置时正确的，想一下在拿到第一张牌的时候，没必要整理。然后3要插到5前面，把5后移一位，变成3,5,8,6,4.想一下整理牌的时候应该也是这样吧。然后8不用动，6插在8前面，8后移一位，4插在5前面，从5开始都向后移一位。注意在插入一个数的时候要保证这个数前面的数已经有序。简单插入排序的时间复杂度也是O(n^2)。</p><p></p>
<p></p><p>实现代码：</p><p></p>
<p><div></div></p>
<p><pre>/*<em>
 </em>@Description:&lt;p&gt;简单插入排序算法实现&lt;/p&gt;<br> <em>@author 王旭
 </em>@time 2016-3-3 下午9:38:55<br> */<br>public class InsertSort {</pre></p>
<pre><code>public static void insertSort(int[] arr) {
    if(arr == null || arr.length == 0)
        return ;

    for(int i=1; i&amp;lt;arr.length; i++) { //假设第一个数位置时正确的；要往后移，必须要假设第一个。

        int j = i;
        int target = arr[i]; //待插入的

        //后移
        while(j &amp;gt; 0 &amp;amp;&amp;amp; target &amp;lt; arr[j-1]) {
            arr[j] = arr[j-1];
            j --;
        }

        //插入 
        arr[j] = target;
    }

}
</code></pre><p>}<br></p>
<p></p><h2>快速排序</h2><p></p>
<p></p><p>快速排序一听名字就觉得很高端，在实际应用当中快速排序确实也是表现最好的排序算法。冒泡排序虽然高端，但其实其思想是来自冒泡排序，冒泡排序是通过相邻元素的比较和交换把最小的冒泡到最顶端，而快速排序是比较和交换小数和大数，这样一来不仅把小数冒泡到上面同时也把大数沉到下面。</p><p></p>
<p></p><p>举个栗子：对5,3,8,6,4这个无序序列进行快速排序，思路是右指针找比基准数小的，左指针找比基准数大的，交换之。</p><p></p>
<p></p><p>5,3,8,6,4 用5作为比较的基准，最终会把5小的移动到5的左边，比5大的移动到5的右边。</p><p></p>
<p></p><p>5,3,8,6,4 首先设置i,j两个指针分别指向两端，j指针先扫描（思考一下为什么？）4比5小停止。然后i扫描，8比5大停止。交换i,j位置。</p><p></p>
<p></p><p>5,3,4,6,8 然后j指针再扫描，这时j扫描4时两指针相遇。停止。然后交换4和基准数。</p><p></p>
<p></p><p>4,3,5,6,8 一次划分后达到了左边比5小，右边比5大的目的。之后对左右子序列递归排序，最终得到有序序列。</p><p></p>
<p></p><p>上面留下来了一个问题为什么一定要j指针先动呢？首先这也不是绝对的，这取决于基准数的位置，因为在最后两个指针相遇的时候，要交换基准数到相遇的位置。一般选取第一个数作为基准数，那么就是在左边，所以最后相遇的数要和基准数交换，那么相遇的数一定要比基准数小。所以j指针先移动才能先找到比基准数小的数。</p><p></p>
<p></p><p>快速排序是不稳定的，其时间平均时间复杂度是O(nlgn)。</p><p></p>
<p></p><p>实现代码：</p><p></p>
<p><div></div></p>
<p><pre>/*<em>
 </em>@Description:&lt;p&gt;实现快速排序算法&lt;/p&gt;<br> <em>@author 王旭
 </em>@time 2016-3-3 下午5:07:29<br> */<br>public class QuickSort {<br>    //一次划分<br>    public static int partition(int[] arr, int left, int right) {<br>        int pivotKey = arr[left];<br>        int pivotPointer = left;</pre></p>
<pre><code>    while(left &amp;lt; right) {
        while(left &amp;lt; right &amp;amp;&amp;amp; arr[right] &amp;gt;= pivotKey)
            right --;
        while(left &amp;lt; right &amp;amp;&amp;amp; arr[left] &amp;lt;= pivotKey)
            left ++;
        swap(arr, left, right); //把大的交换到右边，把小的交换到左边。
    }
    swap(arr, pivotPointer, left); //最后把pivot交换到中间
    return left;
}

public static void quickSort(int[] arr, int left, int right) {
    if(left &amp;gt;= right)
        return ;
    int pivotPos = partition(arr, left, right);
    quickSort(arr, left, pivotPos-1);
    quickSort(arr, pivotPos+1, right);
}

public static void sort(int[] arr) {
    if(arr == null || arr.length == 0)
        return ;
    quickSort(arr, 0, arr.length-1);
}

public static void swap(int[] arr, int left, int right) {
    int temp = arr[left];
    arr[left] = arr[right];
    arr[right] = temp;
}
</code></pre><p>}<br></p>
<p></p><p>其实上面的代码还可以再优化，上面代码中基准数已经在pivotKey中保存了，所以不需要每次交换都设置一个temp变量，在交换左右指针的时候只需要先后覆盖就可以了。这样既能减少空间的使用还能降低赋值运算的次数。优化代码如下：</p><p></p>
<p><div></div></p>
<p><pre>/*<em>
 </em>@Description:&lt;p&gt;实现快速排序算法&lt;/p&gt;<br> <em>@author 王旭
 </em>@time 2016-3-3 下午5:07:29<br> */<br>public class QuickSort {</pre></p>
<pre><code>/**
 * 划分
 * @param arr
 * @param left
 * @param right
 * @return
 */
public static int partition(int[] arr, int left, int right) {
    int pivotKey = arr[left];

    while(left &amp;lt; right) {
        while(left &amp;lt; right &amp;amp;&amp;amp; arr[right] &amp;gt;= pivotKey)
            right --;
        arr[left] = arr[right]; //把小的移动到左边
        while(left &amp;lt; right &amp;amp;&amp;amp; arr[left] &amp;lt;= pivotKey)
            left ++;
        arr[right] = arr[left]; //把大的移动到右边
    }
    arr[left] = pivotKey; //最后把pivot赋值到中间
    return left;
}

/**
 * 递归划分子序列
 * @param arr
 * @param left
 * @param right
 */
public static void quickSort(int[] arr, int left, int right) {
    if(left &amp;gt;= right)
        return ;
    int pivotPos = partition(arr, left, right);
    quickSort(arr, left, pivotPos-1);
    quickSort(arr, pivotPos+1, right);
}

public static void sort(int[] arr) {
    if(arr == null || arr.length == 0)
        return ;
    quickSort(arr, 0, arr.length-1);
}
</code></pre><p>}<br></p>
<p></p><p>总结快速排序的思想：冒泡+二分+递归分治，慢慢体会。。。</p><p></p>
<p></p><h2>堆排序</h2><p></p>
<p></p><p>堆排序是借助堆来实现的选择排序，思想同简单的选择排序，以下以大顶堆为例。注意：如果想升序排序就使用大顶堆，反之使用小顶堆。原因是堆顶元素需要交换到序列尾部。</p><p></p>
<p></p><p>首先，实现堆排序需要解决两个问题：</p><p></p>
<p></p><p>1. 如何由一个无序序列键成一个堆？</p><p></p>
<p></p><p>2. 如何在输出堆顶元素之后，调整剩余元素成为一个新的堆？</p><p></p>
<p></p><p>第一个问题，可以直接使用线性数组来表示一个堆，由初始的无序序列建成一个堆就需要自底向上从第一个非叶元素开始挨个调整成一个堆。</p><p></p>
<p></p><p>第二个问题，怎么调整成堆？首先是将堆顶元素和最后一个元素交换。然后比较当前堆顶元素的左右孩子节点，因为除了当前的堆顶元素，左右孩子堆均满足条件，这时需要选择当前堆顶元素与左右孩子节点的较大者（大顶堆）交换，直至叶子节点。我们称这个自堆顶自叶子的调整成为筛选。</p><p></p>
<p></p><p>从一个无序序列建堆的过程就是一个反复筛选的过程。若将此序列看成是一个完全二叉树，则最后一个非终端节点是n/2取底个元素，由此筛选即可。举个栗子：</p><p></p>
<p></p><p>49,38,65,97,76,13,27,49序列的堆排序建初始堆和调整的过程如下：</p><p></p>
<p></p><p><img src="http://static.codeceo.com/images/2016/03/2614bce119263edcf9d18b6365b39197.png" alt=""></p><p></p>
<p></p><p><img src="http://static.codeceo.com/images/2016/03/ad373a589182dd1b7e443915c8775fcd.png" alt=""></p><p></p>
<p></p><p>实现代码：</p><p></p>
<p><div></div></p>
<p><pre>/*<em>
 </em>@Description:&lt;p&gt;堆排序算法的实现，以大顶堆为例。&lt;/p&gt;<br> <em>@author 王旭
 </em>@time 2016-3-4 上午9:26:02<br> */<br>public class HeapSort {</pre></p>
<pre><code>/**
 * 堆筛选，除了start之外，start~end均满足大顶堆的定义。
 * 调整之后start~end称为一个大顶堆。
 * @param arr 待调整数组
 * @param start 起始指针
 * @param end 结束指针
 */
public static void heapAdjust(int[] arr, int start, int end) {
    int temp = arr[start];

    for(int i=2*start+1; i&amp;lt;=end; i*=2) {
        //左右孩子的节点分别为2*i+1,2*i+2

        //选择出左右孩子较小的下标
        if(i &amp;lt; end &amp;amp;&amp;amp; arr[i] &amp;lt; arr[i+1]) {
            i ++; 
        }
        if(temp &amp;gt;= arr[i]) {
            break; //已经为大顶堆，=保持稳定性。
        }
        arr[start] = arr[i]; //将子节点上移
        start = i; //下一轮筛选
    }

    arr[start] = temp; //插入正确的位置
}

public static void heapSort(int[] arr) {
    if(arr == null || arr.length == 0)
        return ;

    //建立大顶堆
    for(int i=arr.length/2; i&amp;gt;=0; i--) {
        heapAdjust(arr, i, arr.length-1);
    }

    for(int i=arr.length-1; i&amp;gt;=0; i--) {
        swap(arr, 0, i);
        heapAdjust(arr, 0, i-1);
    }

}

public static void swap(int[] arr, int i, int j) {
    int temp = arr[i];
    arr[i] = arr[j];
    arr[j] = temp;
}
</code></pre><p>}<br></p>
<p></p><h2>希尔排序</h2><p></p>
<p></p><p>希尔排序是插入排序的一种高效率的实现，也叫缩小增量排序。简单的插入排序中，如果待排序列是正序时，时间复杂度是O(n)，如果序列是基本有序的，使用直接插入排序效率就非常高。希尔排序就利用了这个特点。基本思想是：先将整个待排记录序列分割成为若干子序列分别进行直接插入排序，待整个序列中的记录基本有序时再对全体记录进行一次直接插入排序。</p><p></p>
<p></p><p>举个栗子：</p><p></p>
<p></p><p><img src="http://static.codeceo.com/images/2016/03/aef03b0d2339be34627bcd81a3809e62.png" alt=""></p><p></p>
<p></p><p>从上述排序过程可见，希尔排序的特点是，子序列的构成不是简单的逐段分割，而是将某个相隔某个增量的记录组成一个子序列。如上面的例子，第一堂排序时的增量为5，第二趟排序的增量为3。由于前两趟的插入排序中记录的关键字是和同一子序列中的前一个记录的关键字进行比较，因此关键字较小的记录就不是一步一步地向前挪动，而是跳跃式地往前移，从而使得进行最后一趟排序时，整个序列已经做到基本有序，只要作记录的少量比较和移动即可。因此希尔排序的效率要比直接插入排序高。</p><p></p>
<p></p><p>希尔排序的分析是复杂的，时间复杂度是所取增量的函数，这涉及一些数学上的难题。但是在大量实验的基础上推出当n在某个范围内时，时间复杂度可以达到O(n^1.3)。</p><p></p>
<p></p><p>实现代码：</p><p></p>
<p><div></div></p>
<p><pre>/*<em>
 </em>@Description:&lt;p&gt;希尔排序算法实现&lt;/p&gt;<br> <em>@author 王旭
 </em>@time 2016-3-3 下午10:53:55<br> */<br>public class ShellSort {</pre></p>
<pre><code>/**
 * 希尔排序的一趟插入
 * @param arr 待排数组
 * @param d 增量
 */
public static void shellInsert(int[] arr, int d) {
    for(int i=d; i&amp;lt;arr.length; i++) {
        int j = i - d;
        int temp = arr[i];    //记录要插入的数据  
        while (j&amp;gt;=0 &amp;amp;&amp;amp; arr[j]&amp;gt;temp) {  //从后向前，找到比其小的数的位置   
            arr[j+d] = arr[j];    //向后挪动  
            j -= d;  
        }  

        if (j != i - d)    //存在比其小的数 
            arr[j+d] = temp;

    }
}

public static void shellSort(int[] arr) {
    if(arr == null || arr.length == 0)
        return ;
    int d = arr.length / 2;
    while(d &amp;gt;= 1) {
        shellInsert(arr, d);
        d /= 2;
    }
}
</code></pre><p>}<br></p>
<p></p><h2>归并排序</h2><p></p>
<p></p><p>归并排序是另一种不同的排序方法，因为归并排序使用了递归分治的思想，所以理解起来比较容易。其基本思想是，先递归划分子问题，然后合并结果。把待排序列看成由两个有序的子序列，然后合并两个子序列，然后把子序列看成由两个有序序列。。。。。倒着来看，其实就是先两两合并，然后四四合并。。。最终形成有序序列。空间复杂度为O(n)，时间复杂度为O(nlogn)。</p><p></p>
<p></p><p>举个栗子：</p><p></p>
<p></p><p><img src="http://static.codeceo.com/images/2016/03/df8478362d9b42913e022eff94d43eb4.png" alt=""></p><p></p>
<p></p><p>实现代码：</p><p></p>
<p><div></div></p>
<p><pre>/*<em>
 </em>@Description:&lt;p&gt;归并排序算法的实现&lt;/p&gt;<br> <em>@author 王旭
 </em>@time 2016-3-4 上午8:14:20<br> */<br>public class MergeSort {</pre></p>
<pre><code>public static void mergeSort(int[] arr) {
    mSort(arr, 0, arr.length-1);
}

/**
 * 递归分治
 * @param arr 待排数组
 * @param left 左指针
 * @param right 右指针
 */
public static void mSort(int[] arr, int left, int right) {
    if(left &amp;gt;= right)
        return ;
    int mid = (left + right) / 2;

    mSort(arr, left, mid); //递归排序左边
    mSort(arr, mid+1, right); //递归排序右边
    merge(arr, left, mid, right); //合并
}

/**
 * 合并两个有序数组
 * @param arr 待合并数组
 * @param left 左指针
 * @param mid 中间指针
 * @param right 右指针
 */
public static void merge(int[] arr, int left, int mid, int right) {
    //[left, mid] [mid+1, right]
    int[] temp = new int[right - left + 1]; //中间数组

    int i = left;
    int j = mid + 1;
    int k = 0;
    while(i &amp;lt;= mid &amp;amp;&amp;amp; j &amp;lt;= right) {
        if(arr[i] &amp;lt;= arr[j]) {
            temp[k++] = arr[i++];
        }
        else {
            temp[k++] = arr[j++];
        }
    }

    while(i &amp;lt;= mid) {
        temp[k++] = arr[i++];
    }

    while(j &amp;lt;= right) {
        temp[k++] = arr[j++];
    }

    for(int p=0; p&amp;lt;temp.length; p++) {
        arr[left + p] = temp[p];
    }

}
</code></pre><p>}<br></p>
<p></p><h2>计数排序</h2><p></p>
<p></p><p>如果在面试中有面试官要求你写一个O(n)时间复杂度的排序算法，你千万不要立刻说：这不可能！虽然前面基于比较的排序的下限是O(nlogn)。但是确实也有线性时间复杂度的排序，只不过有前提条件，就是待排序的数要满足一定的范围的整数，而且计数排序需要比较多的辅助空间。其基本思想是，用待排序的数作为计数数组的下标，统计每个数字的个数。然后依次输出即可得到有序序列。</p><p></p>
<p></p><p>实现代码：</p><p></p>
<p><div></div></p>
<p><pre>/*<em>
 </em>@Description:&lt;p&gt;计数排序算法实现&lt;/p&gt;<br> <em>@author 王旭
 </em>@time 2016-3-4 下午4:52:02<br> */<br>public class CountSort {</pre></p>
<pre><code>public static void countSort(int[] arr) {
    if(arr == null || arr.length == 0)
        return ;

    int max = max(arr);

    int[] count = new int[max+1];
    Arrays.fill(count, 0);

    for(int i=0; i&amp;lt;arr.length; i++) {
        count[arr[i]] ++;
    }

    int k = 0;
    for(int i=0; i&amp;lt;=max; i++) {
        for(int j=0; j&amp;lt;count[i]; j++) {
            arr[k++] = i;
        }
    }

}

public static int max(int[] arr) {
    int max = Integer.MIN_VALUE;
    for(int ele : arr) {
        if(ele &amp;gt; max)
            max = ele;
    }

    return max;
}
</code></pre><p>}<br></p>
<p></p><h2>桶排序</h2><p></p>
<p></p><p>桶排序算是计数排序的一种改进和推广，但是网上有许多资料把计数排序和桶排序混为一谈。其实桶排序要比计数排序复杂许多。</p><p></p>
<p></p><p>对桶排序的分析和解释借鉴这位兄弟的文章（有改动）：<a href="http://hxraid.iteye.com/blog/647759" target="_blank" rel="noopener">http://hxraid.iteye.com/blog/647759</a></p><p></p>
<p></p><p>桶排序的基本思想：</p><p></p>
<p></p><p>假设有一组长度为N的待排关键字序列K[1….n]。首先将这个序列划分成M个的子区间(桶) 。然后基于某种映射函数 ，将待排序列的关键字k映射到第i个桶中(即桶数组B的下标 i) ，那么该关键字k就作为B[i]中的元素(每个桶B[i]都是一组大小为N/M的序列)。接着对每个桶B[i]中的所有元素进行比较排序(可以使用快排)。然后依次枚举输出B[0]&#8230;.B[M]中的全部内容即是一个有序序列。bindex=f(key)   其中，bindex 为桶数组B的下标(即第bindex个桶), k为待排序列的关键字。桶排序之所以能够高效，其关键在于这个映射函数，它必须做到：如果关键字k1&lt;k2，那么f(k1)&lt;=f(k2)。也就是说B(i)中的最小数据都要大于B(i-1)中最大数据。很显然，映射函数的确定与数据本身的特点有很大的关系。</p><p></p>
<p></p><p>举个栗子：</p><p></p>
<p></p><p><img src="http://static.codeceo.com/images/2016/03/47bcf435950f64c848ce43d5ae5142aa.gif" alt=""></p><p></p>
<p></p><p>假如待排序列K= {49、 38 、 35、 97 、 76、 73 、 27、 49 }。这些数据全部在1—100之间。因此我们定制10个桶，然后确定映射函数f(k)=k/10。则第一个关键字49将定位到第4个桶中(49/10=4)。依次将所有关键字全部堆入桶中，并在每个非空的桶中进行快速排序后得到如图所示。只要顺序输出每个B[i]中的数据就可以得到有序序列了。</p><p></p>
<p></p><p>桶排序分析：</p><p></p>
<p></p><p>桶排序利用函数的映射关系，减少了几乎所有的比较工作。实际上，桶排序的f(k)值的计算，其作用就相当于快排中划分，希尔排序中的子序列，归并排序中的子问题，已经把大量数据分割成了基本有序的数据块(桶)。然后只需要对桶中的少量数据做先进的比较排序即可。</p><p></p>
<p></p><p>对N个关键字进行桶排序的时间复杂度分为两个部分：</p><p></p>
<p></p><p>(1) 循环计算每个关键字的桶映射函数，这个时间复杂度是O(N)。</p><p></p>
<p></p><p>(2) 利用先进的比较排序算法对每个桶内的所有数据进行排序，其时间复杂度为  ∑ O(Ni*logNi) 。其中Ni 为第i个桶的数据量。</p><p></p>
<p></p><p>很显然，第(2)部分是桶排序性能好坏的决定因素。尽量减少桶内数据的数量是提高效率的唯一办法(因为基于比较排序的最好平均时间复杂度只能达到O(N*logN)了)。因此，我们需要尽量做到下面两点：</p><p></p>
<p></p><p>(1) 映射函数f(k)能够将N个数据平均的分配到M个桶中，这样每个桶就有[N/M]个数据量。</p><p></p>
<p></p><p>(2) 尽量的增大桶的数量。极限情况下每个桶只能得到一个数据，这样就完全避开了桶内数据的“比较”排序操作。当然，做到这一点很不容易，数据量巨大的情况下，f(k)函数会使得桶集合的数量巨大，空间浪费严重。这就是一个时间代价和空间代价的权衡问题了。</p><p></p>
<p></p><p>对于N个待排数据，M个桶，平均每个桶[N/M]个数据的桶排序平均时间复杂度为：</p><p></p>
<p></p><p>O(N)+O(M<em>(N/M)</em>log(N/M))=O(N+N<em>(logN-logM))=O(N+N</em>logN-N*logM)</p><p></p>
<p></p><p>当N=M时，即极限情况下每个桶只有一个数据时。桶排序的最好效率能够达到O(N)。</p><p></p>
<p></p><p><strong>总结：</strong> 桶排序的平均时间复杂度为线性的O(N+C)，其中C=N*(logN-logM)。如果相对于同样的N，桶数量M越大，其效率越高，最好的时间复杂度达到O(N)。 当然桶排序的空间复杂度 为O(N+M)，如果输入数据非常庞大，而桶的数量也非常多，则空间代价无疑是昂贵的。此外，桶排序是稳定的。</p><p></p>
<p></p><p>实现代码：</p><p></p>
<p><div></div></p>
<p><pre>/*<em>
 </em>@Description:&lt;p&gt;桶排序算法实现&lt;/p&gt;<br> <em>@author 王旭
 </em>@time 2016-3-4 下午7:39:31<br> */<br>public class BucketSort {</pre></p>
<pre><code>public static void bucketSort(int[] arr) {
    if(arr == null &amp;amp;&amp;amp; arr.length == 0)
        return ;

    int bucketNums = 10; //这里默认为10，规定待排数[0,100)
    List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; buckets = new ArrayList&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt;(); //桶的索引

    for(int i=0; i&amp;lt;10; i++) {
        buckets.add(new LinkedList&amp;lt;Integer&amp;gt;()); //用链表比较合适
    }

    //划分桶
    for(int i=0; i&amp;lt;arr.length; i++) {
        buckets.get(f(arr[i])).add(arr[i]);
    }

    //对每个桶进行排序
    for(int i=0; i&amp;lt;buckets.size(); i++) {
        if(!buckets.get(i).isEmpty()) {
            Collections.sort(buckets.get(i)); //对每个桶进行快排
        }
    }

    //还原排好序的数组
    int k = 0;
    for(List&amp;lt;Integer&amp;gt; bucket : buckets) {
        for(int ele : bucket) {
            arr[k++] = ele;
        }
    }
}

/**
 * 映射函数
 * @param x
 * @return
 */
public static int f(int x) {
    return x / 10;
}
</code></pre><p>}<br></p>
<p></p><h2>基数排序</h2><p></p>
<p></p><p>基数排序又是一种和前面排序方式不同的排序方式，基数排序不需要进行记录关键字之间的比较。基数排序是一种借助多关键字排序思想对单逻辑关键字进行排序的方法。所谓的多关键字排序就是有多个优先级不同的关键字。比如说成绩的排序，如果两个人总分相同，则语文高的排在前面，语文成绩也相同则数学高的排在前面。。。如果对数字进行排序，那么个位、十位、百位就是不同优先级的关键字，如果要进行升序排序，那么个位、十位、百位优先级一次增加。基数排序是通过多次的收分配和收集来实现的，关键字优先级低的先进行分配和收集。</p><p></p>
<p></p><p>举个栗子：</p><p></p>
<p></p><p><img src="http://static.codeceo.com/images/2016/03/cb56ff40b1ade7e57d5aa9840fc1eba3.png" alt=""></p><p></p>
<p></p><p><img src="http://static.codeceo.com/images/2016/03/75d38cce23336e133dd8eac33eabf5ad.png" alt=""></p><p></p>
<p></p><p>实现代码：</p><p></p>
<p><div></div></p>
<p><pre>/*<em>
 </em>@Description:&lt;p&gt;基数排序算法实现&lt;/p&gt;<br> <em>@author 王旭
 </em>@time 2016-3-4 下午8:29:52<br> */<br>public class RadixSort {</pre></p>
<pre><code>public static void radixSort(int[] arr) {
    if(arr == null &amp;amp;&amp;amp; arr.length == 0)
        return ;

    int maxBit = getMaxBit(arr);

    for(int i=1; i&amp;lt;=maxBit; i++) {

        List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; buf = distribute(arr, i); //分配
        collecte(arr, buf); //收集
    }

}

/**
 * 分配
 * @param arr 待分配数组
 * @param iBit 要分配第几位
 * @return
 */
public static List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; distribute(int[] arr, int iBit) {
    List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; buf = new ArrayList&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt;();
    for(int j=0; j&amp;lt;10; j++) {
        buf.add(new LinkedList&amp;lt;Integer&amp;gt;());
    }
    for(int i=0; i&amp;lt;arr.length; i++) {
        buf.get(getNBit(arr[i], iBit)).add(arr[i]);
    }
    return buf;
}

/**
 * 收集
 * @param arr 把分配的数据收集到arr中
 * @param buf 
 */
public static void collecte(int[] arr, List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; buf) {
    int k = 0;
    for(List&amp;lt;Integer&amp;gt; bucket : buf) {
        for(int ele : bucket) {
            arr[k++] = ele;
        }
    }

}

/**
 * 获取最大位数
 * @param x
 * @return
 */
public static int getMaxBit(int[] arr) {
    int max = Integer.MIN_VALUE;
    for(int ele : arr) {
        int len = (ele+&quot;&quot;).length();
        if(len &amp;gt; max)
            max = len;
    }
    return max;
}

/**
 * 获取x的第n位，如果没有则为0.
 * @param x
 * @param n
 * @return
 */
public static int getNBit(int x, int n) {

    String sx = x + &quot;&quot;;
    if(sx.length() &amp;lt; n)
        return 0;
    else
        return sx.charAt(sx.length()-n) - &apos;0&apos;;
}
</code></pre><p>}<br></p>
<p></p><h2>总结</h2><p></p>
<p></p><p>在前面的介绍和分析中我们提到了冒泡排序、选择排序、插入排序三种简单的排序及其变种快速排序、堆排序、希尔排序三种比较高效的排序。后面我们又分析了基于分治递归思想的归并排序还有计数排序、桶排序、基数排序三种线性排序。我们可以知道排序算法要么简单有效，要么是利用简单排序的特点加以改进，要么是以空间换取时间在特定情况下的高效排序。但是这些排序方法都不是固定不变的，需要结合具体的需求和场景来选择甚至组合使用。才能达到高效稳定的目的。没有最好的排序，只有最适合的排序。</p><p></p>
<p></p><p>下面就总结一下排序算法的各自的使用场景和适用场合。</p><p></p>
<p></p><p><img src="http://static.codeceo.com/images/2016/03/2f0f5c6b5c7b007b00f0d33427a70db0.png" alt=""></p><p></p>
<p></p><p>1. 从平均时间来看，快速排序是效率最高的，但快速排序在最坏情况下的时间性能不如堆排序和归并排序。而后者相比较的结果是，在n较大时归并排序使用时间较少，但使用辅助空间较多。</p><p></p>
<p></p><p>2. 上面说的简单排序包括除希尔排序之外的所有冒泡排序、插入排序、简单选择排序。其中直接插入排序最简单，但序列基本有序或者n较小时，直接插入排序是好的方法，因此常将它和其他的排序方法，如快速排序、归并排序等结合在一起使用。</p><p></p>
<p></p><p>3. 基数排序的时间复杂度也可以写成O(d*n)。因此它最使用于n值很大而关键字较小的的序列。若关键字也很大，而序列中大多数记录的最高关键字均不同，则亦可先按最高关键字不同，将序列分成若干小的子序列，而后进行直接插入排序。</p><p></p>
<p></p><p>4. 从方法的稳定性来比较，基数排序是稳定的内排方法，所有时间复杂度为O(n^2)的简单排序也是稳定的。但是快速排序、堆排序、希尔排序等时间性能较好的排序方法都是不稳定的。稳定性需要根据具体需求选择。</p><p></p>
<p></p><p>5. 上面的算法实现大多数是使用线性存储结构，像插入排序这种算法用链表实现更好，省去了移动元素的时间。具体的存储结构在具体的实现版本中也是不同的。</p><p></p>
<p></p><p>附：基于比较排序算法时间下限为O(nlogn)的证明：</p><p></p>
<p></p><p>基于比较排序下限的证明是通过决策树证明的，决策树的高度Ω（nlgn），这样就得出了比较排序的下限。</p><p></p>
<p></p><p><img src="http://static.codeceo.com/images/2016/03/b4d51a192d469b833a46695c0a7668f6.jpg" alt=""></p><p></p>
<p></p><p>首先要引入决策树。 首先决策树是一颗二叉树，每个节点表示元素之间一组可能的排序，它予以京进行的比较相一致，比较的结果是树的边。 先来说明一些二叉树的性质，令T是深度为d的二叉树，则T最多有2^片树叶。 具有L片树叶的二叉树的深度至少是logL。 所以，对n个元素排序的决策树必然有n!片树叶（因为n个数有n!种不同的大小关系），所以决策树的深度至少是log(n!)，即至少需要log(n!)次比较。 而 log(n!)=logn+log(n-1)+log(n-2)+&#8230;+log2+log1 &gt;=logn+log(n-1)+log(n-2)+&#8230;+log(n/2) &gt;=(n/2)log(n/2) &gt;=(n/2)logn-n/2 =O(nlogn) 所以只用到比较的排序算法最低时间复杂度是O(nlogn)。</p><p></p>
<p></p><p><strong>参考资料：</strong></p><p></p>
<p><ul></ul></p>
<p><li>《数据结构》 严蔚敏 吴伟民 编著</li></p>
<p><li>桶排序分析：<a href="http://hxraid.iteye.com/blog/647759" target="_blank" rel="noopener">http://hxraid.iteye.com/blog/647759</a></li></p>
<p><li>部分排序算法分析与介绍：<a href="http://www.cnblogs.com/weixliu/archive/2012/12/23/2829671.html" target="_blank" rel="noopener">http://www.cnblogs.com/weixliu/archive/2012/12/23/2829671.html</a></li><br></p>
<script type="text/javascript">
var strBatchView = 37731</script>

<p><a id="soft-link" name="soft-link"></a></p>
<p><div style="width:336px;height:280px;margin:40px auto"></div></p>
<p><script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><br><!-- codeceo-bottom-big --><br><ins class="adsbygoogle" style="display:inline-block;width:336px;height:280px" data-ad-client="ca-pub-3171310320403916" data-ad-slot="5138981789"></ins></p>
<script>
</script>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/11/09/Material Design使用总结/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="WeiQingcai">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/head_logo.png">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="程序小栈">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/11/09/Material Design使用总结/" itemprop="url">Material Design使用总结</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-11-09T16:49:37+08:00">
                2018-11-09
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index">
                    <span itemprop="name">Android</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Material-Design使用总结"><a href="#Material-Design使用总结" class="headerlink" title="Material Design使用总结"></a>Material Design使用总结</h1><p>Material Design是在Android5.0时新推出的一种设计规范，现在绝大部分的app都已经使用这种新的设计规范来进行界面设计。其主要是强调材质和层次感在设计中的应用，Android中也做了一些原生态的支持，但是要使用这些都必须最小兼容到Android5.0，也就是API  21，或者是添加Material Design的一个支持库。关于详细的Material Design的解释和说明，可以参考这本书：</p>
<p><a href="http://download.csdn.net/detail/wqc_csdn/9516039" target="_blank" rel="noopener">电子书下载地址</a><br>推荐两个Material Design的配色和图标网站：</p>
<p>一个是可以在线进行配色方案的查看：<a href="http://www.materialpalette.com/" target="_blank" rel="noopener"><strong>Materia l Palette</strong></a></p>
<p><img src="http://img.blog.csdn.net/20160515213603298" alt="网站界面"></p>
<p>一个是提供Material Design风格的图标：<a href="https://materialdesignicons.com/" target="_blank" rel="noopener"><strong>Materia l Design Icons</strong></a></p>
<p><img src="http://img.blog.csdn.net/20160515214744111" alt="网站界面"></p>
<h2 id="主题："><a href="#主题：" class="headerlink" title="主题："></a>主题：</h2><p><img src="http://img.blog.csdn.net/20160519113211572" alt="颜色分布"><br>最基本的主题有三个：<br>@android:style/Theme.Material<br>@android:style/Theme.Material.Light<br>@android:style/Theme.Material.Light.DarkActionBar<br>这几个是基本的主题，也是分别代表三种风格的主题，更多的需要我们自己根据自己的需要来进行定制。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--actionBar颜色--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"colorPrimary"</span>&gt;</span>@android:color/holo_green_light<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--状态栏颜色--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"colorPrimaryDark"</span>&gt;</span>@android:color/holo_green_light<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--控件颜色--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"colorAccent"</span>&gt;</span>#464545<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>主要由几部分组成，colorPrimary，colorPrimaryDark，colorAccent，textColorPrimary，windowPrimary，navigationBarColor这个值可以使用系统已经提供的颜色值，也可以直接自己定制。</p>
<h2 id="基本使用方式："><a href="#基本使用方式：" class="headerlink" title="基本使用方式："></a>基本使用方式：</h2><p>Android中为我们提供了一个便捷的提取相应主题的工具—Palette。其能根据传入的Bitmap来获取到一系列特定风格的颜色值，使得当前主题和传入的图片更为的贴切。使用该工具能很方便的创建出各种风格的主题。</p>
<ul>
<li><p>要使用需要导入相应的包–com.android.support:palette-v7。如果是AS，则直接打开module setting，在dependencies中进行添加即可。如果是Eclipse，这需要去sdk文件夹—–extras—android–support—v7文件夹中将palette项目导入工作空间，并作为主工程的依赖项目。</p>
</li>
<li><p>导入完成后直接在代码中使用。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//声明一个Bitmap对象</span></span><br><span class="line">Bitmap bitmap = BitmapFactory.decodeResource(MainActivity.<span class="keyword">this</span>.getResources(), R.drawable.study55);</span><br><span class="line"><span class="comment">// 声明一个palette对象</span></span><br><span class="line">Palette.Builder palette = Palette.from(bitmap);</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取到相应的色调，并设置个相应的组件。</span></span><br><span class="line">Palette.Swatch  darkMutedSwatch = palette.generate().getDarkMutedSwatch();</span><br><span class="line">MainActivity.<span class="keyword">this</span>.getWindow().setStatusBarColor(darkMutedSwatch.getRgb());</span><br></pre></td></tr></table></figure>
<p>效果如下：<br><em>点击前：</em><br><img src="http://img.blog.csdn.net/20160520160704957" alt="点击前"></p>
<p><em>点击后：</em><br><img src="http://img.blog.csdn.net/20160520160742255" alt="点击后"></p>
<p>常见的一些提取的色调：</p>
<p>getDarkMutedColor(int defaultColor)——获取一个柔和的，深色的颜色</p>
<p>getLightMutedColor(int defaultColor)——获取一个柔和的，亮色的颜色</p>
<p>getDarkVibrantColor(int defaultColor)——获取一个有活力的，深色的颜色</p>
<p>getLightVibrantColor(int defaultColor)——获取一个有活力的，浅色的颜色</p>
<p>getMutedColor(int defaultColor)——获取一个柔和的颜色</p>
<p>getVibrantColor(int defaultColor)——获取最为有活力的颜色</p>
<h2 id="视图与阴影："><a href="#视图与阴影：" class="headerlink" title="视图与阴影："></a>视图与阴影：</h2><p>在Material Design中新添加了一个布局属性，除了原本的X，Y之外，新添加了Z轴（包含静态的高度和动态的高度），使得视图在垂直与手机屏幕的方向上也有了属性，也就是产生了视图和阴影效果，而不像是之前所有的视图都在同一个平面上。</p>
<p>一张图来说明在Material Design中视图的推荐高度：<br><img src="http://img.blog.csdn.net/20160518214813904" alt="图片说明"></p>
<p><strong>阴影效果：</strong>Z轴由两部分组成，静态高度和动态高度。静态高度常用于视图的固定布局，动态高度则常用于实现动画效果。即  <strong>Z =elevation + translationZ</strong></p>
<p>elevation=0<br><img src="http://img.blog.csdn.net/20160518220847552" alt="elevation=0"></p>
<p>elevation = 100<br><img src="http://img.blog.csdn.net/20160518220929704" alt="elevation = 100"></p>
<p>我们可以使用SeekBar在代码里动态的修改阴影的高度，更多的还是将其作为动画来使用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">mSeekBarElevation.setOnSeekBarChangeListener(<span class="keyword">new</span> SeekBar.OnSeekBarChangeListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onProgressChanged</span><span class="params">(SeekBar seekBar, <span class="keyword">int</span> progress, <span class="keyword">boolean</span> fromUser)</span> </span>&#123;</span><br><span class="line">                mCardView.setCardElevation(progress);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onStartTrackingTouch</span><span class="params">(SeekBar seekBar)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onStopTrackingTouch</span><span class="params">(SeekBar seekBar)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure>
<h2 id="裁剪与着色："><a href="#裁剪与着色：" class="headerlink" title="裁剪与着色："></a>裁剪与着色：</h2><p><strong>1.  着色：</strong><br>新添加的一种对图像的修改方式，通过修改图像中的Alpha遮罩来修改图像。<br><strong>基本使用方式：</strong></p>
<ul>
<li>在xml文件中：直接为需要的图片设置着色颜色和着色的模式即可。</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--原图--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ImageView</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:src</span>=<span class="string">"@mipmap/ic_launcher"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span> /&gt;</span></span><br><span class="line"><span class="comment">&lt;!--默认模式--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ImageView</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:tint</span>=<span class="string">"#3759f4"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:src</span>=<span class="string">"@mipmap/ic_launcher"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span> /&gt;</span></span><br><span class="line"><span class="comment">&lt;!--add--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ImageView</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:tint</span>=<span class="string">"#3759f4"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:tintMode</span>=<span class="string">"add"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:src</span>=<span class="string">"@mipmap/ic_launcher"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span> /&gt;</span></span><br><span class="line"><span class="comment">&lt;!--multiply--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ImageView</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:tint</span>=<span class="string">"#3759f4"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:tintMode</span>=<span class="string">"multiply"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:src</span>=<span class="string">"@mipmap/ic_launcher"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span> /&gt;</span></span><br><span class="line"><span class="comment">&lt;!--screen--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ImageView</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:tint</span>=<span class="string">"#3759f4"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:tintMode</span>=<span class="string">"screen"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:src</span>=<span class="string">"@mipmap/ic_launcher"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span> /&gt;</span></span><br><span class="line"><span class="comment">&lt;!--src_atop--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ImageView</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:tint</span>=<span class="string">"#3759f4"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:tintMode</span>=<span class="string">"src_atop"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:src</span>=<span class="string">"@mipmap/ic_launcher"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">    /&gt;</span></span><br><span class="line"><span class="comment">&lt;!--src_over--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ImageView</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:tint</span>=<span class="string">"#3759f4"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:tintMode</span>=<span class="string">"src_over"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:src</span>=<span class="string">"@mipmap/ic_launcher"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">    /&gt;</span></span><br><span class="line"><span class="comment">&lt;!--src_in--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ImageView</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:tint</span>=<span class="string">"#3759f4"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:tintMode</span>=<span class="string">"src_in"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:src</span>=<span class="string">"@mipmap/ic_launcher"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">    /&gt;</span></span><br></pre></td></tr></table></figure>
<p><img src="http://img.blog.csdn.net/20160518222854717" alt="效果图"></p>
<p><strong>2.   裁剪：</strong> Clipping裁剪可以使我们能够为控件的外形绘制指定类型的形状，和之前的shape有相同的效果，只是这是直接修改外形，而不是作为一个背景。<br><strong>基本使用方式：</strong></p>
<ul>
<li>在布局文件中放置一个需要用到的控件，无需有额外的设置。</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ImageView</span></span></span><br><span class="line"><span class="tag">       <span class="attr">android:layout_margin</span>=<span class="string">"10dp"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">android:layout_alignParentRight</span>=<span class="string">"true"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">android:layout_alignParentBottom</span>=<span class="string">"true"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">android:id</span>=<span class="string">"@+id/fab_add"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">android:src</span>=<span class="string">"@mipmap/ic_launcher"</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>在Java代码中获取到这个控件并使用ViewOutlineProvider来为其设置外形。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//声明一个ViewOutlineProvider实例，并设置需要的类型，有多种图形可以选择，只需要重写其getOutline方法即可。</span></span><br><span class="line">ViewOutlineProvider outlineProvider = <span class="keyword">new</span> ViewOutlineProvider()&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getOutline</span><span class="params">(View view, Outline outline)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> fabSize = <span class="number">100</span>;</span><br><span class="line">        outline.setOval(-<span class="number">4</span>,-<span class="number">4</span>,fabSize+<span class="number">2</span>,fabSize+<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//调用View的setOutlineProvider（）方法为控件设置外形。</span></span><br><span class="line">View fabView = findViewById(R.id.fab_add);</span><br><span class="line">fabView.setOutlineProvider(outlineProvider);</span><br></pre></td></tr></table></figure>
<ul>
<li>这样就做出了一个圆形的按钮（类似于FloatingActionBar）：</li>
</ul>
<p><img src="http://img.blog.csdn.net/20160520151846222" alt="效果展示"></p>
<h2 id="控件："><a href="#控件：" class="headerlink" title="控件："></a>控件：</h2><p><strong>1.RecyclerView :</strong><br>RecyclerView 是对ListView进行的一次提升和拓展，同时考虑到了布局的重用问题，通过内部的ViewHolder来提升效率，同时提供了更多新的特性和定制细节，有更大的定制功能。<br><strong>基本使用方式：</strong></p>
<ul>
<li>首先和ListView一样，做一个Item中要用到的布局，这个根据自己额业务需要来自由定制（演示只使用一个TextView）。</li>
</ul>
<p><strong>recycle_view_item.xml</strong></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">LinearLayout</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:orientation</span>=<span class="string">"vertical"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:fontFamily</span>=<span class="string">"monospace"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:padding</span>=<span class="string">"10dp"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:textSize</span>=<span class="string">"20sp"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">"@+id/id_show_text_view"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">"0dp"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_weight</span>=<span class="string">"1"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>然后和ListView相似，也是定制自己的Adapter，这里一般需要重新复写的方法有三个，并实现一个自己的ViewHolder（继承自RecyclerView.ViewHolder）</li>
</ul>
<p><strong>RecycleViewAdapter.java</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.wei.designsupportlibrarystudy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.support.v7.widget.RecyclerView;</span><br><span class="line"><span class="keyword">import</span> android.view.LayoutInflater;</span><br><span class="line"><span class="keyword">import</span> android.view.View;</span><br><span class="line"><span class="keyword">import</span> android.view.ViewGroup;</span><br><span class="line"><span class="keyword">import</span> android.widget.TextView;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by WQC</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RecycleViewAdapter</span> <span class="keyword">extends</span> <span class="title">RecyclerView</span>.<span class="title">Adapter</span>&lt;<span class="title">RecycleViewAdapter</span>.<span class="title">ViewHolder</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">//保存数据的Java Bean</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ArrayList&lt;DataModel&gt; mDatas;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RecycleViewAdapter</span><span class="params">(ArrayList&lt;DataModel&gt; mDatas)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.mDatas = mDatas;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当ViewHolder被创建时调用</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> parent 父控件</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> viewType View类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> ViewHolder的实例</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ViewHolder <span class="title">onCreateViewHolder</span><span class="params">(ViewGroup parent, <span class="keyword">int</span> viewType)</span> </span>&#123;</span><br><span class="line">        View itemView = LayoutInflater.from(parent.getContext()).inflate(R.layout.recycle_view_item, parent, <span class="keyword">false</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ViewHolder(itemView);</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当数据和View进行绑定时被调用</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> holder ViewHolder实例</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> position 当前View的Item位置</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onBindViewHolder</span><span class="params">(ViewHolder holder, <span class="keyword">int</span> position)</span> </span>&#123;</span><br><span class="line">	    <span class="comment">//根据Position来获取相应的数据</span></span><br><span class="line">        <span class="keyword">final</span> DataModel rowData = mDatas.get(position);</span><br><span class="line">		<span class="comment">//数据显示到视图上</span></span><br><span class="line">	    holder.showTextView.setText(rowData.getShowText());</span><br><span class="line">        holder.showTextView.setTag(rowData);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	 <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取列表项的长度</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 列表的长度</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getItemCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mDatas.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 实现ViewHolder的内部类，用于布局的重用</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ViewHolder</span> <span class="keyword">extends</span> <span class="title">RecyclerView</span>.<span class="title">ViewHolder</span> </span>&#123;</span><br><span class="line">	    <span class="comment">//这里只有一个TextView，和recycle_view_item.xml布局里边是对应的，都是根据自己的业务需要进行修改。</span></span><br><span class="line">	    </span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> TextView showTextView;</span><br><span class="line">		<span class="comment">//通过itemView 来进行重用</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">ViewHolder</span><span class="params">(View itemView)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>(itemView);</span><br><span class="line">            showTextView = (TextView) itemView.findViewById(R.id.id_show_text_view);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>然后就是在主布局中加入RecyclerView控件进行使用：</li>
</ul>
<p><strong>activity_recycleview.xml</strong></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">RelativeLayout</span></span></span><br><span class="line"><span class="tag"><span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag"><span class="attr">xmlns:tools</span>=<span class="string">"http://schemas.android.com/tools"</span></span></span><br><span class="line"><span class="tag"><span class="attr">android:orientation</span>=<span class="string">"vertical"</span></span></span><br><span class="line"><span class="tag"><span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag"><span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">android.support.v7.widget.RecyclerView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:elevation</span>=<span class="string">"1dp"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">"@+id/id_recycle_view"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line">         &lt;!--在这里进行滚动条方向的声明--&gt;</span><br><span class="line">        android:scrollbars="vertical"</span><br><span class="line">        <span class="comment">&lt;!--在这里进行item布局的声明--&gt;</span></span><br><span class="line">        tools:listitem="@layout/recycle_view_item"&gt;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">android.support.v7.widget.RecyclerView</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">RelativeLayout</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>接着在Java代码中使用RecyclerView：</li>
</ul>
<p><strong>RecycleViewActivity.java</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.wei.designsupportlibrarystudy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.graphics.Outline;</span><br><span class="line"><span class="keyword">import</span> android.os.Bundle;</span><br><span class="line"><span class="keyword">import</span> android.support.v7.app.AppCompatActivity;</span><br><span class="line"><span class="keyword">import</span> android.support.v7.widget.LinearLayoutManager;</span><br><span class="line"><span class="keyword">import</span> android.support.v7.widget.RecyclerView;</span><br><span class="line"><span class="keyword">import</span> android.view.View;</span><br><span class="line"><span class="keyword">import</span> android.view.ViewOutlineProvider;</span><br><span class="line"><span class="keyword">import</span> android.widget.LinearLayout;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by WQC.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RecycleViewActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line">    RecyclerView mRecyclerView;</span><br><span class="line">    LinearLayoutManager linearLayoutManager;</span><br><span class="line">    RecycleViewAdapter recycleViewAdapter;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_recycleview);</span><br><span class="line">        <span class="comment">//获取到布局中声明的RecyclerView</span></span><br><span class="line">        mRecyclerView =(RecyclerView)findViewById(R.id.id_recycle_view);</span><br><span class="line">		<span class="comment">//为RecyclerView指定一个布局管理器，可以是GridLayoutManager，LinearLayoutManager等，搭配使用有多种的表现形式。</span></span><br><span class="line">        linearLayoutManager = <span class="keyword">new</span> LinearLayoutManager(<span class="keyword">this</span>);</span><br><span class="line">		<span class="comment">//设置布局管理器</span></span><br><span class="line">        mRecyclerView.setLayoutManager(linearLayoutManager);</span><br><span class="line">        <span class="comment">//声明一个适配器实例，并传入数据。</span></span><br><span class="line"></span><br><span class="line">        recycleViewAdapter = <span class="keyword">new</span> RecycleViewAdapter(initData(<span class="number">20</span>));</span><br><span class="line">		<span class="comment">//将适配器绑定到RecyclerView上</span></span><br><span class="line">        mRecyclerView.setAdapter(recycleViewAdapter);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 准备初始化数据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;DataModel&gt; <span class="title">initData</span><span class="params">(<span class="keyword">int</span> size)</span></span>&#123;</span><br><span class="line">        ArrayList&lt;DataModel&gt; datas = <span class="keyword">new</span> ArrayList&lt;&gt;(size);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;size;i++) &#123;</span><br><span class="line">            datas.add(<span class="keyword">new</span> DataModel(<span class="string">"初始化数据"</span> + <span class="string">"&lt;"</span> + i + <span class="string">"&gt;"</span>));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> datas;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>ps：DataModel.java文件（JavaBean）</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.wei.designsupportlibrarystudy;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by WQC   用于承载数据的Bean</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DataModel</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String showText;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DataModel</span><span class="params">(String showText)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.showText = showText;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getShowText</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> showText;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setShowText</span><span class="params">(String showText)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.showText = showText;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>至此RecyclerView的简单使用就完成了，可以尝试修改其列表方向，布局管理器的种类，不同的搭配产生不一样的效果，例如列表项，图墙，画廊效果，都可以自定义实现。</p>
<p><strong>关于RecycleView中的分隔线的问题：</strong></p>
<p>最开始Google推出的RecycleVIew并没有给出默认的分隔线实现，只是提供了一个RecyclerView.ItemDecoration类共供我们自定义实现，后来推出的版本中就给出了默认实现的分隔线。</p>
<p><strong>使用默认实现的分割线：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mRecyclerView.addItemDecoration(<span class="keyword">new</span> DividerItemDecoration(<span class="keyword">this</span>, DividerItemDecoration.HORIZONTAL));</span><br></pre></td></tr></table></figure>
<p><strong>使用自定义实现的分割线：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by WQC on 2016/5/12.</span></span><br><span class="line"><span class="comment"> * 自定义的item分隔符</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleDivider</span> <span class="keyword">extends</span> <span class="title">RecyclerView</span>.<span class="title">ItemDecoration</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span>[] attrs = &#123;android.R.attr.listDivider&#125;;</span><br><span class="line">    <span class="keyword">private</span> Drawable mDivider;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SimpleDivider</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        TypedArray typedArray = context.obtainStyledAttributes(attrs);</span><br><span class="line">        mDivider = typedArray.getDrawable(<span class="number">0</span>);</span><br><span class="line">        typedArray.recycle();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 重写该方法来绘制自定义的分隔线，这里绘制的是一条直线（矩形）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> canvas</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> parent</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> state</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDrawOver</span><span class="params">(Canvas canvas, RecyclerView parent, RecyclerView.State state)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//左下角的点</span></span><br><span class="line">        <span class="keyword">int</span> left = parent.getPaddingLeft();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//右下角的点</span></span><br><span class="line">        <span class="keyword">int</span> right = parent.getWidth() - parent.getPaddingRight();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取总共的item个数</span></span><br><span class="line">        <span class="keyword">int</span> childCount = parent.getChildCount();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; childCount; i ++) &#123;</span><br><span class="line">            View child = parent.getChildAt(i);</span><br><span class="line"></span><br><span class="line">            RecyclerView.LayoutParams layoutParams = (RecyclerView.LayoutParams) child.getLayoutParams();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> top = child.getBottom() + layoutParams.bottomMargin;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> bottom = top + mDivider.getIntrinsicHeight();</span><br><span class="line"></span><br><span class="line">            mDivider.setBounds(left, top, right, bottom);</span><br><span class="line"></span><br><span class="line">            mDivider.draw(canvas);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDraw</span><span class="params">(Canvas c, RecyclerView parent, RecyclerView.State state)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onDraw(c, parent, state);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getItemOffsets</span><span class="params">(Rect outRect, View view, RecyclerView parent, RecyclerView.State state)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.getItemOffsets(outRect, view, parent, state);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>附：鸿洋大神关于RecyclerView的文章：<a href="http://blog.csdn.net/lmj623565791/article/details/45059587" target="_blank" rel="noopener">http://blog.csdn.net/lmj623565791/article/details/45059587</a></strong></p>
<p><strong>附：慕课网上有一个RecyclerView的使用视频教程：<a href="http://www.imooc.com/learn/424" target="_blank" rel="noopener">视频地址</a></strong></p>
<p><strong>2. GardView</strong><br>CardView其实就是一个像其名字一样，是一个卡片布局，并且继承自Framelayout所以其也可以作为布局容器使用。</p>
<p><strong>基本使用方式：</strong></p>
<ul>
<li>首先要导入其所在的jar包：<br>android.support.v7.widget.CardView。在Android Studio中直接可以找到。右键Module，选择Open Module Setting,选择Dependencies，点右边的加号，直接输入CardView搜索即可。<br><img src="http://img.blog.csdn.net/20160516230208330" alt="指引图片"></li>
</ul>
<ul>
<li>在布局文件中直接使用CardView：</li>
</ul>
<p><strong>content_card.xml</strong></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">LinearLayout</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:app</span>=<span class="string">"http://schemas.android.com/apk/res-auto"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:tools</span>=<span class="string">"http://schemas.android.com/tools"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:orientation</span>=<span class="string">"vertical"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:paddingBottom</span>=<span class="string">"@dimen/activity_vertical_margin"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:paddingLeft</span>=<span class="string">"@dimen/activity_horizontal_margin"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:paddingRight</span>=<span class="string">"@dimen/activity_horizontal_margin"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:paddingTop</span>=<span class="string">"@dimen/activity_vertical_margin"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:layout_behavior</span>=<span class="string">"@string/appbar_scrolling_view_behavior"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">tools:context</span>=<span class="string">"com.wei.designsupportlibrarystudy.CardActivity"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">tools:showIn</span>=<span class="string">"@layout/activity_card"</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--上边的都是AS自动生成的，不用理会--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">android.support.v7.widget.CardView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">"@+id/id_card_view"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">"160dp"</span></span></span><br><span class="line">        &lt;!--控件的高度，影响阴影的效果--&gt;</span><br><span class="line">        android:elevation="200dp"</span><br><span class="line">        android:layout_marginRight="@dimen/activity_horizontal_margin"</span><br><span class="line">        android:layout_marginLeft="@dimen/activity_horizontal_margin"</span><br><span class="line">        app:cardBackgroundColor="@color/cardview_dark_background"</span><br><span class="line">        <span class="comment">&lt;!--控件矩形边框的角度--&gt;</span></span><br><span class="line">        app:cardCornerRadius="10dp"&gt;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">android.support.v7.widget.CardView</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>然后在Java文件中通过findViewById()使用即可</li>
</ul>
<p><strong>CardViewActivity.java</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mCardView = (CardView) findViewById(R.id.id_card_view);</span><br></pre></td></tr></table></figure>
<p>就是一个卡片的效果<br><img src="http://img.blog.csdn.net/20160516232610723" alt="控件效果"></p>
<p><strong>3.  FloatingActionButton</strong><br>FloatingActionButton名为浮动圆形按钮，在android.support.design.widget.FloatingActionButton包下。这个兼容包主要是为了向低版本的Android设备兼容Material Design。上边图片中的邮件小图标便是FloatingActionButton的效果，其用法和ImageView相似，只是更加符合Material Design的设计规范，同时加入了阴影效果。</p>
<p><strong>基本使用方法：</strong></p>
<ul>
<li>首先要添加上android.support.design这个库，AS中方法和之前一样，Eclipse中则需要进入sdk中，选择extra，选择android，选择support，将里边的design项目导入工作空间并作为主工程依赖的项目。</li>
</ul>
<p><img src="http://img.blog.csdn.net/20160517102104670" alt="路径图片"></p>
<ul>
<li>其次就是在布局文件中直接使用FloatingActionButton</li>
</ul>
<p><strong>布局文件中的使用：</strong></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">android.support.design.widget.FloatingActionButton</span></span></span><br><span class="line"><span class="tag">       <span class="attr">android:id</span>=<span class="string">"@+id/fab"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">android:layout_gravity</span>=<span class="string">"bottom|end"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">android:layout_margin</span>=<span class="string">"@dimen/fab_margin"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">android:src</span>=<span class="string">"@android:drawable/ic_dialog_info"</span></span></span><br><span class="line"><span class="tag"></span></span><br><span class="line">       &lt;!--以下是该控件新增加的xml属性--&gt;</span><br><span class="line">       <span class="comment">&lt;!--设置背景颜色--&gt;</span></span><br><span class="line">       app:backgroundTint="#ff77"</span><br><span class="line">       <span class="comment">&lt;!--设置大小--&gt;</span></span><br><span class="line">       app:fabSize="mini"</span><br><span class="line">       <span class="comment">&lt;!--设置静态的高度--&gt;</span></span><br><span class="line">       app:elevation="20dp"</span><br><span class="line">       <span class="comment">&lt;!--点击时的颜色--&gt;</span></span><br><span class="line">       app:rippleColor="#FFF4D6D6"/&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>在Java代码中获取使用：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FloatingActionButton fab = (FloatingActionButton) findViewById(R.id.fab);</span><br></pre></td></tr></table></figure>
<p>该控件其实就是一个特定的ImageButton，也可以设置自己的事件监听，实现需要的业务逻辑。</p>
<p>该片段为FloatingActionButton设置了业务逻辑，点击时弹出一个Snackbar显示消息。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">fab.setOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View view)</span> </span>&#123;</span><br><span class="line">                Snackbar.make(view, <span class="string">"Replace with your own action"</span>, Snackbar.LENGTH_LONG)</span><br><span class="line">                        .setAction(<span class="string">"Action"</span>, <span class="keyword">null</span>).show();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure>
<p><strong>4.TextInputLayout</strong></p>
<p>TextInputLayout 其实是一个对于EditText进行拓展的新控件，原本的EditText的默认提示文本hint在点击输入时就会消失，而TextInputLayout使得点击输入后也依然显示提示信息。</p>
<p><strong>基本使用方式：</strong></p>
<ul>
<li>首先也是导入android.support.design这个包，然后在布局文件中直接进行使用，将EditText放入TextInputLayout中。</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">android.support.design.widget.TextInputLayout</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_below</span>=<span class="string">"@+id/tabLayout"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">"@+id/textInput"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">EditText</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">android.support.design.widget.TextInputLayout</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>然后在Java文件中进行使用</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取布局中的控件</span></span><br><span class="line">        <span class="keyword">final</span> TextInputLayout textInputLayout = (TextInputLayout) findViewById(R.id.textInput);</span><br><span class="line">        <span class="comment">//设置Hint信息</span></span><br><span class="line">        textInputLayout.setHint(<span class="string">"请输入用户名"</span>);</span><br><span class="line">        <span class="comment">//获取放在textInputLayout中的EditText</span></span><br><span class="line">        EditText editText = textInputLayout.getEditText();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (editText != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//为EditText设置事件监听，用于处理输入事件</span></span><br><span class="line">            editText.addTextChangedListener(<span class="keyword">new</span> TextWatcher() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">beforeTextChanged</span><span class="params">(CharSequence s, <span class="keyword">int</span> start, <span class="keyword">int</span> count, <span class="keyword">int</span> after)</span> </span>&#123;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onTextChanged</span><span class="params">(CharSequence s, <span class="keyword">int</span> start, <span class="keyword">int</span> before, <span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (s.length() &gt; <span class="number">10</span>) &#123;</span><br><span class="line">                        <span class="comment">//使用textInputLayout进行消息提示</span></span><br><span class="line">                        textInputLayout.setError(<span class="string">"输入的用户名不能超出10位"</span>);</span><br><span class="line">                        textInputLayout.setErrorEnabled(<span class="keyword">true</span>);</span><br><span class="line">                    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                        textInputLayout.setErrorEnabled(<span class="keyword">false</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterTextChanged</span><span class="params">(Editable s)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>效果：<br><img src="http://img.blog.csdn.net/20160520161205766" alt="效果"></p>
<p><strong>5. Tablayout</strong></p>
<p>新出来的一个布局，可以很便捷的帮我们实现选项卡的功能。要使用需要导入android.support.design.widget.TabLayout包</p>
<p><strong>基本使用方式：</strong></p>
<ul>
<li>首先导入包，然后直接在布局文件中添加上即可。</li>
</ul>
<p><strong>布局文件</strong></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">android.support.design.widget.TabLayout</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_alignParentTop</span>=<span class="string">"true"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:tabMode</span> = <span class="string">"scrollable"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">"@+id/tabLayout"</span>&gt;</span><span class="tag">&lt;/<span class="name">android.support.design.widget.TabLayout</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>然后在Java代码中获取到，进行设置：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">TabLayout tabs = (TabLayout)findViewById(R.id.tabLayout);</span><br><span class="line">tabs.addTab(tabs.newTab().setText(<span class="string">"tab1"</span>));</span><br><span class="line">tabs.addTab(tabs.newTab().setText(<span class="string">"tab2"</span>));</span><br><span class="line">tabs.addTab(tabs.newTab().setText(<span class="string">"tab3"</span>));</span><br><span class="line">tabs.addTab(tabs.newTab().setText(<span class="string">"tab4"</span>));</span><br><span class="line">tabs.addTab(tabs.newTab().setText(<span class="string">"tab4"</span>));</span><br><span class="line">tabs.addTab(tabs.newTab().setText(<span class="string">"tab4"</span>));</span><br><span class="line">tabs.addTab(tabs.newTab().setText(<span class="string">"tab4"</span>));</span><br><span class="line">tabs.addTab(tabs.newTab().setText(<span class="string">"tab4"</span>));</span><br></pre></td></tr></table></figure>
<p>这样就可以做出选项卡的效果了<br><img src="http://img.blog.csdn.net/20160520165809066" alt="选项卡效果"></p>
<p><strong>6.  SnackBar：</strong></p>
<p>SncakBar是新出来的一款控件，他提供了一个特贴轻量级的反馈，作用类似于Toast，但是又和Toast有所区别。</p>
<p>官方文档的内容：</p>
<blockquote>
<p>Snackbars provide lightweight feedback about an operation. They show a brief message at the bottom of the screen on mobile and lower left on larger devices. Snackbars appear above all other elements on screen and only one can be displayed at a time. </p>
</blockquote>
<blockquote>
<p>Snackbars can contain an action which is set via setAction(CharSequence, android.view.View.OnClickListener).</p>
</blockquote>
<blockquote>
<p>To be notified when a snackbar has been shown or dismissed, you can provide a Snackbar.Callback via setCallback(Callback).</p>
</blockquote>
<p>翻译：</p>
<blockquote>
<p>SnackBar为一个操作提供了一个轻量级的回馈。它在手机屏幕的底部或者是在大屏幕设备的左下方显示一个简短的消息。SnackBar位于屏幕上所有元素的上方，并且只能显示一段时间</p>
</blockquote>
<blockquote>
<p>SnackBar可以通过setAction(CharSequence, android.view.View.OnClickListener)方法来包含一个动作</p>
</blockquote>
<blockquote>
<p>可以通过提供setCallback(Callback)接口来获取SnackBar显示和消失时的通知</p>
</blockquote>
<p><strong>基本使用方式：</strong></p>
<ul>
<li>类似于Toast，直接在程序中使用：</li>
</ul>
<p><strong>Java代码：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Snackbar snackbar = Snackbar.make(actionButton, <span class="string">"你点击了按钮"</span>, Snackbar.LENGTH_LONG);</span><br><span class="line"></span><br><span class="line">snackbar.setAction(<span class="string">"知道了"</span>, <span class="keyword">new</span> View.OnClickListener() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">      snackbar.dismiss();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">snackbar.show();</span><br></pre></td></tr></table></figure>
<p>当然了Material Design中新出现的各种特性，新控件，新布局还有很多，这只是我自己使用的一个总结，欢迎交流和分享。</p>
<hr>
<h2 id="2016-11-28更新："><a href="#2016-11-28更新：" class="headerlink" title="2016.11.28更新："></a>2016.11.28更新：</h2><p><strong>7.  ToolBar：</strong></p>
<p>ToolBar已经开始取代ActionBar作为主要的标题栏的实现方式，使用toolBar也很简单，首先同样是在XML布局文件中声明好，然后在Java代码中获取使用即可。需要注意的是使用toolBar时要声明app使用的theme为android:theme=”@style/AppTheme.NoActionBar”,否则容易引起ActionBar和ToolBar的冲突。</p>
<p>//在xml布局文件中定义好</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">android.support.v7.widget.Toolbar</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:id</span>=<span class="string">"@+id/toolbar"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_height</span>=<span class="string">"?attr/actionBarSize"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:background</span>=<span class="string">"?attr/colorPrimary"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">app:popupTheme</span>=<span class="string">"@style/AppTheme.PopupOverlay"</span>/&gt;</span></span><br><span class="line"> //其中popupTheme是用于指定菜单选项弹出的样式的</span><br></pre></td></tr></table></figure>
<p>//在Java代码中获取并使用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Toolbar toolbar = (Toolbar) findViewById(R.id.toolbar);</span><br><span class="line">        setSupportActionBar(toolbar);</span><br></pre></td></tr></table></figure>
<p>这样就把ActionBar替换成了ToolBar，同时需要实现ToolBar对应的方法，包括menu菜单创建时和menu菜单项被点击时：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建菜单时</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> menu</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onCreateOptionsMenu</span><span class="params">(Menu menu)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Inflate the menu; this adds items to the action bar if it is present.</span></span><br><span class="line">        getMenuInflater().inflate(R.menu.main, menu);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 菜单项被点击时</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> item</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onOptionsItemSelected</span><span class="params">(MenuItem item)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Handle action bar item clicks here. The action bar will</span></span><br><span class="line">        <span class="comment">// automatically handle clicks on the Home/Up button, so long</span></span><br><span class="line">        <span class="comment">// as you specify a parent activity in AndroidManifest.xml.</span></span><br><span class="line">        <span class="keyword">int</span> id = item.getItemId();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//noinspection SimplifiableIfStatement</span></span><br><span class="line">        <span class="keyword">if</span> (id == R.id.action_settings) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.onOptionsItemSelected(item);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p><strong>8.  AppBarLayout：</strong></p>
<p>参考自：<a href="http://blog.csdn.net/solo_talk/article/details/52222269" target="_blank" rel="noopener">http://blog.csdn.net/solo_talk/article/details/52222269</a></p>
<p>AppBarLayout可以将其布局里边所有的View都作为标题栏存在，例如可以在AppBarLayout中放一个ToolBar和一个ImageView，这样能丰富标题栏的类型。更主要的是使用AppBarLayout可以设置里边控件的滑动属性，实现滑动时AppBarLayout布局里边的控件隐藏或者是显示。</p>
<p>控制属性：</p>
<ul>
<li><p>scroll：表示向下滚动的时候，设置了这个属性的View会被滚出屏幕范围，直到消失，想要实现滑动隐藏的话必须要有这个属性</p>
</li>
<li><p>enterAlways：表示向上滚动的时候，设置了这个属性的View会随着滚动手势逐渐出现，直到恢复原来设置的位置</p>
</li>
<li><p>enterAlwaysCollapsed：是enterAlways的附加选项，一般跟enterAlways一起使用，它是指，View在往下“出现”的时候，首先是enterAlways效果，当View的高度达到最小高度时，View就暂时不去往下滚动，直到ScrollView滑动到顶部不再滑动时，View再继续往下滑动，直到滑到View的顶部结束。</p>
</li>
<li><p>exitUntilCollapsed：值设为exitUntilCollapsed的View，当这个View要往上逐渐“消逝”时，会一直往上滑动，直到剩下的的高度达到它的最小高度后，再响应ScrollView的内部滑动事件。</p>
</li>
</ul>
<p>使用方式：</p>
<p>AppBarLayout需要有一个和它同层次的滚动布局来配合使用，同时要以CoordinatorLayout作为根布局（因为只有CoordinatorLayout布局为根布局，不同的布局之间才能相互联系起来）</p>
<p>伪代码表示使用方式：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">CoordinatorLayout</span>&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="tag">&lt;<span class="name">AppBarLayout</span>&gt;</span></span><br><span class="line">		</span><br><span class="line">		<span class="tag">&lt;<span class="name">ToolBar</span></span></span><br><span class="line"><span class="tag">			 <span class="attr">app:layout_scrollFlags</span>=<span class="string">"scroll|exitUntilCollapsed"</span>&gt;</span></span><br><span class="line">	    <span class="tag">&lt;/<span class="name">ToolBar</span>&gt;</span></span><br><span class="line">		</span><br><span class="line">		<span class="tag">&lt;<span class="name">ImageView</span></span></span><br><span class="line"><span class="tag">			<span class="attr">app:layout_scrollFlags</span>=<span class="string">"scroll|exitUntilCollapsed"</span>/&gt;</span></span><br><span class="line">		</span><br><span class="line">	<span class="tag">&lt;/<span class="name">AppBarLayout</span>&gt;</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">&lt;!--和AppBarLayout同层级的滚动视图，如ScrollView等，同时设置app:layout_behavior属性--&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">ScrollView</span></span></span><br><span class="line"><span class="tag">	<span class="attr">app:layout_behavior</span>=<span class="string">"@string/appbar_scrolling_view_behavior"</span>&gt;</span></span><br><span class="line">	</span><br><span class="line">	<span class="tag">&lt;/<span class="name">ScrollView</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">CoordinatorLayout</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这样当下边的ScrollView向上滑动时，AppBarLayout中的控件会全部隐藏，向下滑动时会显示出来。</p>
<p><strong>9. CoordinatorLayout：</strong><br>参考自<a href="http://blog.csdn.net/u010687392/article/details/46906657" target="_blank" rel="noopener">http://blog.csdn.net/u010687392/article/details/46906657</a><br>CoordinatorLayout可以组织多个子View之间相互协作，使用时同样需要引入design.support支持库。</p>
<p>在CoordinatorLayout布局中可以为其他的子View添加app:layout_behavior这个属性。若View添加上这个属性，那么当其产生响应的行为时CoordinatorLayout布局中的其他子View就可以获知这个消息，这时若是属性中设置了app:layout_scrollFlags这个属性的View就可以根据接受到的事件产生相应的动作。</p>
<p>使用方法：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">android.support.design.widget.CoordinatorLayout</span>  </span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span>  </span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:app</span>=<span class="string">"http://schemas.android.com/apk/res-auto"</span>  </span></span><br><span class="line"><span class="tag">    <span class="attr">android:id</span>=<span class="string">"@+id/coordinator_layout"</span>  </span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span>  </span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span>&gt;</span>  </span><br><span class="line">  </span><br><span class="line">    <span class="tag">&lt;<span class="name">android.support.design.widget.AppBarLayout</span>  </span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">"@+id/appbar_layout"</span>  </span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span>  </span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span>  </span></span><br><span class="line"><span class="tag">        <span class="attr">android:fitsSystemWindows</span>=<span class="string">"true"</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">android.support.v7.widget.Toolbar</span>  </span></span><br><span class="line"><span class="tag">            <span class="attr">android:id</span>=<span class="string">"@+id/toolBar"</span>  </span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span>  </span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_height</span>=<span class="string">"?attr/actionBarSize"</span>  </span></span><br><span class="line"><span class="tag">            <span class="attr">android:background</span>=<span class="string">"#30469b"</span>  </span></span><br><span class="line"><span class="tag">            <span class="attr">app:layout_scrollFlags</span>=<span class="string">"scroll|enterAlways"</span> /&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;/<span class="name">android.support.design.widget.AppBarLayout</span>&gt;</span>  </span><br><span class="line"></span><br><span class="line"> <span class="tag">&lt;<span class="name">LinearLayout</span>  </span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span>  </span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span>  </span></span><br><span class="line"><span class="tag">        <span class="attr">android:orientation</span>=<span class="string">"vertical"</span>  </span></span><br><span class="line"><span class="tag">        <span class="attr">android:scrollbars</span>=<span class="string">"none"</span>    <span class="attr">app:layout_behavior</span>=<span class="string">"@string/appbar_scrolling_view_behavior"</span>&gt;</span>    </span><br><span class="line">        <span class="comment">&lt;!--为LinearLayout设置了behavior属性，当其滑动时，CoordinatorLayout就会通知其他设置了app:layout_scrollFlags属性的View产生变化 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span>  </span><br><span class="line">  </span><br><span class="line"><span class="tag">&lt;/<span class="name">android.support.design.widget.CoordinatorLayout</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>10. CollapsingToolbarLayout：</strong></p>
<p>这是一个可以折叠的ToolBarLayout布局，可以用它来包裹ToolBar，指定当滑动时CollapsingToolbarLayout发生折叠，而ToolBar可以保留下来，这样就可以实现当滑动时，顶部的控件都折叠了，独留下Toolbar。</p>
<p>使用方式：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">android.support.design.widget.AppBarLayout</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">"@+id/app_bar"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">"@dimen/app_bar_height"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:fitsSystemWindows</span>=<span class="string">"true"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:theme</span>=<span class="string">"@style/AppTheme.AppBarOverlay"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">android.support.design.widget.CollapsingToolbarLayout</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:id</span>=<span class="string">"@+id/toolbar_layout"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:fitsSystemWindows</span>=<span class="string">"true"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">app:contentScrim</span>=<span class="string">"?attr/colorPrimary"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">app:layout_scrollFlags</span>=<span class="string">"scroll|exitUntilCollapsed"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="tag">&lt;<span class="name">android.support.v7.widget.Toolbar</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:id</span>=<span class="string">"@+id/toolbar"</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:layout_height</span>=<span class="string">"?attr/actionBarSize"</span></span></span><br><span class="line"><span class="tag">                <span class="attr">app:layout_collapseMode</span>=<span class="string">"pin"</span></span></span><br><span class="line"><span class="tag">                <span class="attr">app:popupTheme</span>=<span class="string">"@style/AppTheme.PopupOverlay"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;/<span class="name">android.support.design.widget.CollapsingToolbarLayout</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">android.support.design.widget.AppBarLayout</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>另附：</p>
<ul>
<li><p>Git-Hub上的一个UI测试库，遵循Material Design原则：<a href="https://github.com/yhsj0919/YHUI" target="_blank" rel="noopener">github地址</a></p>
</li>
<li><p>Material Design控件demo：<a href="https://github.com/chenyangcun/MaterialDesignExample" target="_blank" rel="noopener">github地址</a></p>
</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/head_logo.png" alt="WeiQingcai">
            
              <p class="site-author-name" itemprop="name">WeiQingcai</p>
              <p class="site-description motion-element" itemprop="description">这是我的小栈，记录点滴</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">12</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">7</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">22</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">本文为博主原创文章，转载请注明出处。</span>

  
</div>









        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


  

  

</body>
</html>
