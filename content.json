{"meta":{"title":"程序小栈","subtitle":null,"description":"这是我的小栈，记录点滴","author":"WeiQingcai","url":"http://yoursite.com"},"pages":[{"title":"关于我","date":"2018-11-09T08:49:37.000Z","updated":"2019-07-12T02:10:01.627Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"现已停止求职个人信息 卫清才/男 研究生（在读）/中北大学/计算机科学与技术（网络安全方向） Email:wqc_work@163.com 技术博客:WQC_CSDN(访问量90000+，多篇文章被CSDN知识库收录) Git-Hub地址:weiqingcai(参与LearningNotes开源项目) 项目经验萧帮主 2016.7-2016.9 Android主程（内测运营，注册人数500+）APP下载地址 一款校园信息服务类APP(二手交易，代取快递，校园活动门票等)，已成为本校迎新晚会合作平台 采用MVP架构，使用Retrofit+Picaso+GreenDao等开源框架 自定义实现了首页的顶部轮播图和底部的导航栏的上滑显示，下滑隐藏特性 无线测量 2015.12-2016.3 Android主程（已投入工地试运行） 一款用于实时监测吊车吊钩倾角的硬件+APP产品（倾角实时监测及绘制，语音播报数据等） 通过监听系统广播，实现了蓝牙PIN码的匹配，同时自定义了通讯协议，完成数据包的封装解析 使用自定义 SurfaceView展示倾角状态，通过Handler+Looper+MessageQueue完成线程间通讯 同窗 2015.7-2015.10 Android主程APP参赛演示视频 方便大学生宿舍生活的App(集体闹钟，共同相册等)，获华北五省计算机应用大赛全国三等奖 负责整个框架的搭建，使用TabHost+ViewPager+Fragment、SlidingMenu实现APP主体页面布局 自定义实现ImageLoader，使用LruCache+DiskLruCache完成图片的三级缓存 专业技能 Java 熟练使用Java编程，理解面向对象编程，了解常见的数据结构 了解单例模式，观察者模式，适配器模式等基础的设计模式 Android 熟练Android四大组件，常见基础控件，自定义View和View的事件分发机制 熟悉Handler机制和多线程、线程池技术 对MVC，MVP，MVVM框架有一定了解 了解并能使用响应式编程（RxJava，RxAndroid） 了解并能熟练使用okHttp，Picasso，Retrofit，DataBinding等流行的开源框架 其他 思科网络工程师认证（CCNA），有良好的计算机网络基础，了解TCP/IP，Socket相关知识 有后台服务器搭建经验，了解JavaEE，GoLang等后端开发技术 了解前端HTML+CSS3+JavaScript技术 良好的英语阅读能力，通过英语四级 实习经验2016.7-2016.10 黑白小生科技 Android研发在该初创型公司中主要负责萧帮主Android客户端功能模块的研讨和开发，同时熟悉商业开发流程，熟悉多人协作开发规范 2014.8-2016.3 Android创新实验室 成员定期参与实验室内的技术交流活动，同时负责为实验室新成员讲解Java，Android基础知识 获奖情况 思科网络工程师认证（CCNA） 2016.5 单项奖学金，综合素质三等奖学金两次 2015.12 华北五省计算机应用大赛全国三等奖 2014.11 校级综合素质奖学金"},{"title":"分类","date":"2018-11-10T14:27:19.000Z","updated":"2019-07-12T02:10:01.627Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2018-11-10T14:23:49.000Z","updated":"2019-07-12T02:10:01.631Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"统计学习方法--支持向量机","slug":"《统计学习方法》笔记--支持向量机","date":"2019-07-12T08:49:37.000Z","updated":"2019-07-12T02:10:01.627Z","comments":true,"path":"2019/07/12/《统计学习方法》笔记--支持向量机/","link":"","permalink":"http://yoursite.com/2019/07/12/《统计学习方法》笔记--支持向量机/","excerpt":"","text":"支持向量机概述支持向量机是一种二类分类模型，它的基本模型是定义在特征空间上的间隔最大的线性分类器。支持向量机由简至繁依次可分为：线性可分支持向量机，线性支持向量机，非线性支持向量机。当数据线性可分时，通过硬间隔最大化的约束来学习一个分类器，称为线性可分支持向量机；当数据近似线性可分时，通过软间隔最大化的约束来学习一个分类器，称为线性支持向量机；当数据线性不可分时通过使用核技巧及软间隔最大化，学习非线性支持向量机。故此，支持向量机可以简化的描述为通过训练数据集来寻找一个能够将数据正确分类的超平面，此分离超平面满足数据集中的数据点距此超平面的间隔（软间隔/硬间隔）最大化。 基础前提函数间隔和几何间隔间隔最大化是贯穿于整个支持向量机模型的最核心的部分。一般来说，一个点距离分离超平面的远近可以表示分类预测的确信程度，在分离超平面确定的情况下，若一个点离超平面越远则分类正确的可信度越高。故此，支持向量机寻求间隔最大化的意义在于分离超平面不仅可以正确分类数据点，而且对于最难分的实例（距离超平面最近的点）也有较大的分类可信度，因此该模型再对未知数据分类时应该也具有较好的性能。 函数间隔 对于给定的训练数据集$T$和超平面$(\\omega,b)$， 定义超平面$(\\omega,b)$关于样本点$(x_i,y_i)$的函数间隔为\\hat{\\gamma_i}=y_i(\\omega\\cdot x_i+b)定义超平面$(\\omega,b)$关于训练数据集$T$的函数间隔为超平面$(\\omega,b)$关于$T$中所有样本点$(x_i,y_i)$的函数间隔最小值，即\\hat{\\gamma}=\\min_{i=1,2,..,N}\\hat{\\gamma_i} 几何间隔由于函数间隔在当$\\omega$和$b$成比例的改变时候，得到的分离超平面并没有变化，但是函数间隔却也成比例的改变，故此自然想到应该对其进行规范化处理，令$||\\omega||=1$，这样就得到了几何间隔的定义。 对于给定的训练数据集$T$和超平面$(\\omega,b)$ 定义超平面$(\\omega,b)$关于样本点$(x_i,y_)i$的几何间隔为\\gamma_i=y_i(\\frac{\\omega}{||\\omega||}\\cdot x_i+\\frac{b}{||\\omega||})定义超平面$(\\omega,b)$关于训练数据集$T$的几何间隔为超平面$(\\omega,b)$关于$T$中所有样本点$(x_i,y_i)$的几何间隔最小值，即\\gamma=\\min_{1,2,...,N}\\gamma_i 线性可分支持向量机与硬间隔最大化给定线性可分训练数据集，通过间隔最大化(几何间隔最大化)或等价的求解相应的凸二次规划问题得到的分离超平面为$\\omega^\\cdot x+b^=0$,相应的分类决策函数为$f(x)=sign(\\omega^\\cdot x+b^)$。线性可分支持向量机可以表述为下列形式：\\max_{\\omega,b}\\gamma s.t. y_i(\\frac{\\omega}{||\\omega||}\\cdot x_i+\\frac{b}{||\\omega||})\\geq\\gamma,i=1,2...,N即转化为了一个约束最优化问题。依据函数间隔和几何间隔的关系及约束最优化的求解方式，可以将上述求解最大值的问题转化为求解最小值的问题，即：\\min_{\\omega,b}\\frac{1}{2}||\\omega||^2 s.t. y_i(\\omega\\cdot x_i+b)-1\\geq 1,i=1,2...,N 故此可以有线性可分支持向量机算法为： 输入：线性可分训练数据集$T=\\{(x_1,y_2),(x_2,y_2),…,(x_N,y_N)\\}$,其中$x_i\\in X=R^n,y_i\\in Y=\\{+1,-1\\},i=1,2,…,N$ 输出：最大间隔分离超平面及分类决策函数 (1) 构造并求解约束最优化问题：\\min_{\\omega,b}\\frac{1}{2}||\\omega||^2 s.t. y_i(\\omega\\cdot x_i+b)-1\\geq 1,i=1,2...,N得到最优解$\\omega^$,$b^$(2) 由此得到分离超平面：\\omega^* \\cdot x+b^* = 0,分类决策函数f(x)=sign(\\omega^* \\cdot x+b^*) 线性支持向量机与软间隔最大化当数据集线性不可分时表明对于数据集中的一些实例，上述约束方法中的约束不等式不能都成立，即存在一些实例，无法满足函数间隔大于等于1的约束要求。为了解决这个问题，可以对每个样本点引入一个松弛变量$\\zeta_i\\geq0$,使得函数间隔加上松弛变量大于等于1，即约束条件放宽为:$y_i(\\omega\\cdot x_i+b)\\geq 1-\\zeta_i$,同时对每个松弛变量支付一个代价$\\zeta_i$。目标函数则变为$\\frac{1}{2}||\\omega||^2+C \\sum_{i=1}^{N}\\zeta_i$，这里$C&gt;0$称为惩罚参数，$C$值大时对误分类的惩罚增大，$C$值小时对误分类的惩罚小。故由此可得到线性支持向量机算法的原始表达形式为：\\min_{\\omega,b,\\zeta} \\frac{1}{2}||\\omega||^2+C\\sum_{i=1}^N\\zeta_i s.t. y_i(\\omega\\cdot x_i+b)\\geq 1-\\zeta_i,i=1,2,...,N \\zeta_i\\geq 0,i=1,2,...,N这样根据原始问题求解得到$\\omega^$,$b^$即可得到分离超平面以及分类决策函数 非线性支持向量机与核函数对于线性分类问题，线性支持向量机是一种非常有效的方法。但是有时要解决的是非线性问题，此时就需要收盘每个非线性支持向量机，其重点在于利用核技巧。核技巧不仅应用于支持向量机，而且也可以应用于其他统计学问题中。核技巧就是通过首先使用一个变换将原空间的数据映射到新的空间，然后在新空间里用线性分类学习方法从训练数据中学习分类模型。 核技巧的基本想法是通过一个非线性变换将输入空间（欧式空间$R^n$或离散集合）对应于一个特征空间（希尔伯特空间$\\mathrm{H}$），使得在输入空间$R^n$中的超曲面模型对应于特征空间$\\mathrm{H}$中的超平面模型（支持向量机）。这样，分类问题的学习任务通过在特征空间中求解线性支持向量机就可以完成。 核函数 设$\\chi$是输入空间（欧式空间$R^n$的子集或离散集合），又设$\\mathrm{H}$为特征空间（希尔伯特空间），如果存在一个从$\\chi$到$\\mathrm{H}$的映射\\phi(x):\\chi \\to \\mathrm{H}使得对所有$x,z\\in\\chi$,函数$K(x,z)$满足条件K(x,z)=\\phi(x)\\cdot\\phi(z)则称$K(x,z)$为核函数，$\\phi(x)$为映射函数，式中$\\phi(x)\\cdot\\phi(z)$为$\\phi(x)$和$\\phi(z)$的內积 非线性支持向量机从非线性分类训练集，通过核函数与软间隔最大化学习得到的分类决策函数f(x)=sign(\\sum_{i=1}^N\\alpha_i^*y_iK(x,x_i)+b^ *)称为非线性支持向量机，$K(x,z)$是正定核函数 输入：训练数据集$T=\\{(x_1,y_1),(x_2,y_2),…,(x_N,y_N)\\}$其中$x_i\\in\\chi=R^n,y_i\\in Y=\\{-1,+1\\},i=1,2,…,N$ 输出：分类决策函数 (1) 选取适当的核函数$K(x,z)$和适当的参数$C$，构造并求解最优化问题\\min_\\alpha \\frac{1}{2}\\sum_{i=1}^N\\sum_{j=1}^N\\alpha_i\\alpha_j y_iy_jK(x_i,x_j)-\\sum_{i=1}^N\\alpha_i s.t. \\sum_{i=1}^N\\alpha_iy_i=0 0\\leq\\alpha_i\\leq C,i=1,2,...,N求出最优解$\\alpha^=(\\alpha_1^,\\alpha_2^,…,\\alpha_N^)^T$(2) 选择$\\alpha^$的一个正分量$0&lt;\\alpha_j^&lt;C$，计算b^*=y_j-\\sum_{i=1}^N\\alpha_i^ *y_iK(x_i,x_j)(3) 构造决策函数：f(x)=sign(\\sum_{i=1}^N\\alpha_i^*y_iK(x,x_i)+b^ *)","categories":[{"name":"大数据与网络安全","slug":"大数据与网络安全","permalink":"http://yoursite.com/categories/大数据与网络安全/"}],"tags":[{"name":"统计学习","slug":"统计学习","permalink":"http://yoursite.com/tags/统计学习/"},{"name":"机器学习","slug":"机器学习","permalink":"http://yoursite.com/tags/机器学习/"}],"keywords":[{"name":"大数据与网络安全","slug":"大数据与网络安全","permalink":"http://yoursite.com/categories/大数据与网络安全/"}]},{"title":"统计学习方法--最大熵模型","slug":"《统计学习方法》笔记--最大熵模型","date":"2019-07-12T08:49:37.000Z","updated":"2019-07-12T02:10:01.627Z","comments":true,"path":"2019/07/12/《统计学习方法》笔记--最大熵模型/","link":"","permalink":"http://yoursite.com/2019/07/12/《统计学习方法》笔记--最大熵模型/","excerpt":"","text":"最大熵模型概述最大熵模型是将最大熵原理应用于分类任务中得到的模型。认为在全部可能的模型中，熵最大的模型是最好的模型。 最大熵原理最大熵原理认为，学习概率模型时，在所有可能的概率模型分布中，熵最大的模型就是最好的模型。由于通常用约束条件来确定概率模型的集合，因此最大熵原理也可以表述为在满足约束条件的模型集合中选取熵最大的模型。熵，最大熵原理都最初演变自热力学领域。关于信息论中的熵可以参考之前的文章中的介绍 《统计学习方法》—决策树 最大熵模型 在要求解的问题中，假设满足所有约束条件的模型集合为 C\\equiv \\{P \\in \\mathcal{P}|E_P(f_i)=E_{P^{\\thicksim}}(f_i)\\}其中$i=1,2,…,n$。定义在条件概率分布$P(Y|X)$上的条件熵为 H(P)=-\\sum_{x,y}P^{\\thicksim}(x)P(y|x)\\log P(y|x)其中$P^{\\thicksim}(x)$表示边缘分布$P(x)$的经验分布，$E_{P^{\\thicksim}}(f_i)$表示特征函数$f(x,y)$关于经验分布$P^{\\thicksim}(x,y)$的期望。则模型集合$C$中条件熵$H(P)$最大的模型称为最大熵模型。 最大熵模型的学习最大熵模型的学习过程就是求解最大熵模型的过程。一般可以将其形式化为约束最优化问题。对于给定的训练数据集$T=\\{(x_1,y_1),(x_2,y_2),…,(x_N,y_N)\\}$,以及特征函数$f_i(x,y),i=1,2,…,n$,最大熵模型的学习等价于约束最优化问题： \\max_{P\\in C} H(P)=-\\sum_{x,y}P^{\\thicksim}(x)P(y|x)\\log P(y|x)s.t. E_P(f_i)=E_{P^\\thicksim}(fi),i=1,2,...,n\\sum_yP(y|x)=1","categories":[{"name":"大数据与网络安全","slug":"大数据与网络安全","permalink":"http://yoursite.com/categories/大数据与网络安全/"}],"tags":[{"name":"统计学习","slug":"统计学习","permalink":"http://yoursite.com/tags/统计学习/"},{"name":"机器学习","slug":"机器学习","permalink":"http://yoursite.com/tags/机器学习/"}],"keywords":[{"name":"大数据与网络安全","slug":"大数据与网络安全","permalink":"http://yoursite.com/categories/大数据与网络安全/"}]},{"title":"统计学习方法--逻辑斯谛回归","slug":"《统计学习方法》笔记--逻辑斯谛回归与最大熵模型","date":"2019-07-12T08:49:37.000Z","updated":"2019-07-12T02:10:01.627Z","comments":true,"path":"2019/07/12/《统计学习方法》笔记--逻辑斯谛回归与最大熵模型/","link":"","permalink":"http://yoursite.com/2019/07/12/《统计学习方法》笔记--逻辑斯谛回归与最大熵模型/","excerpt":"","text":"逻辑斯谛回归概述逻辑斯谛回归的主要思想是：根据现有数据对分类边界线建立回归公式，以此进行分类。这里的“回归”一词源于最佳拟合，表示要找到最佳拟合参数。而最佳拟合参数就是在训练分类器时，通过最优化算法获得。 逻辑斯谛分布 设$X$是连续随机变量，$X$服从逻辑斯谛分布是指$X$具有以下分布函数和概率密度函数：F(x)=P(X\\leq x)=\\frac{1}{1+e^{-(x-\\mu)/\\gamma}} f(x)=F'(x)=\\frac{e^{-(x-\\mu)/\\gamma}}{\\gamma(1+e^{-(x-\\mu)/\\gamma})^2}其中$\\mu$为位置参数，$\\gamma \\gt 0$为形状参数 二项式逻辑斯谛回归模型 P(Y=1|x) = \\frac{exp(\\omega\\cdot x+b)}{1+exp(\\omega\\cdot x+b)}$$$$P(Y=0|x) = \\frac{1}{1+exp(\\omega\\cdot x+b)}这里$x\\in R^n$是输入，$Y\\in\\{0,1\\}$是输出，$\\omega\\in R^n$和$b\\in R^n$是参数，$\\omega$称为权值向量，$b$称为偏置，$\\omega\\cdot x$是$\\omega$和$X$的內积 对于给定的输入实例$X$，按照上式可以求得实例属于两种类别的概率，逻辑斯谛回归模型比较两个概率的大小，将实例归入概率较大的那一类中。 模型参数估计 对于给定的训练数据集$T=\\{(x_1,y_1),(x_2,y_2)…(x_N,y_N)\\}$其中$x_i\\in R^n,y_i\\in \\{0,1\\}$可以应用极大似然估计来得到模型的参数，从而得到逻辑斯谛回归模型。 设P(Y=1|x)=\\pi(x),P(Y=0|x)=1-\\pi(x)则可得似然函数\\prod_{i=1}^N[\\pi(x_i)]^{y_i}[1-\\pi(x_i)]^{1-y_i}对数似然函数为：L(\\omega)=\\sum_{i=1}^N[y_i\\log\\pi(x)+(1-y_i\\log(1-\\pi(x_i)))]即最终变成求解$L(\\omega)$极大值的问题。一般可以采用梯度下降或者是拟牛顿法求解 最后求出$\\omega$的极大似然估计值即可得到逻辑斯谛回归模型。 多项式逻辑斯谛回归二项式逻辑斯谛回归应用于二类分类问题，将其推广到多项式逻辑斯谛回归就可以应用于多类分类问题。 假设离散型随机变量$Y$的取值集合是$\\{1,2,…,K\\}$则多项式逻辑斯谛回归模型是P(Y=k|x)=\\frac{\\exp(\\omega_k\\cdot x)}{1+\\sum_{k=1}^{K-1}\\exp(\\omega_k \\cdot x)}, k=1,2,3...,K-1 P(Y=K|x)=\\frac{1}{1+\\sum_{k=1}^{K-1}\\exp(\\omega_k \\cdot x)}这里$x\\in R^{n+1},\\omega_k\\in R^{n+1}$这是将偏置项拓展到权值向量$\\omega$和输入向量$x$中。 逻辑斯谛回归模型和线性回归模型，SVM模型的异同总体而言，三者都属于线性模型，只是通过计算得到的线性平面的用法不同。逻辑斯谛回归和SVM是分类模型，线性回归属于回归模型。 关于三种模型异同的相关文章： 线性模型（线性回归、感知机和逻辑斯谛回归） SVM简介、SVM与感知机、逻辑回归LR的区别 逻辑斯蒂回归和感知机模型、支持向量机模型对比","categories":[{"name":"大数据与网络安全","slug":"大数据与网络安全","permalink":"http://yoursite.com/categories/大数据与网络安全/"}],"tags":[{"name":"统计学习","slug":"统计学习","permalink":"http://yoursite.com/tags/统计学习/"},{"name":"机器学习","slug":"机器学习","permalink":"http://yoursite.com/tags/机器学习/"}],"keywords":[{"name":"大数据与网络安全","slug":"大数据与网络安全","permalink":"http://yoursite.com/categories/大数据与网络安全/"}]},{"title":"统计学习方法--决策树","slug":"《统计学习方法》笔记--决策树","date":"2019-06-16T08:49:37.000Z","updated":"2019-07-12T02:10:01.627Z","comments":true,"path":"2019/06/16/《统计学习方法》笔记--决策树/","link":"","permalink":"http://yoursite.com/2019/06/16/《统计学习方法》笔记--决策树/","excerpt":"","text":"决策树概述决策树模型呈树形结构，在分类过程中表示基于特征对实例进行分类的过程。决策树模型可以视为if-then规则的集合，也可以视为是定义在特征空间与类别空间上的条件改了分布。主要优点是模型具有很好的可解释性，分类速度快，缺点是构建决策树时用的特征序列对分类效果有较大的影响。决策树学习过程通常包括三个步骤：特征选择，决策树的生成，决策树的修剪 决策树模型分类决策树模型是一种描述对实例进行分类的树形结构。决策树由节点和有向边组成。节点包括两种类型：内部节点和叶节点。内部节点表示一个特征或属性，叶节点表示一个类。 决策树学习的本质是从给定的训练数据集中依据属性或特征归纳出一组分类规则。与给定的训练数据集相符合的分类规则可能有多个，决策树模型就是需要从多个符合的分类规则中找到损失最小的，泛化能力最好的一组分类规则。决策树常用的损失函数是正则化的极大似然函数，决策树的学习策略是以损失函数为目标函数的最小化。由于所有可能的决策树组成的解空间较大，从中找到最优的决策树是NP完全问题，因此一般多采用启发式算法来近似求解。 决策树学习的算法通常是一个递归的选择最优特征的过程。从可选的特征集合中选出最优的特征（即依据该特征能最有效的将训练数据集分类），按照这一特征将数据集分割成子集，该特征作为这些子集的根节点。如果这些子集已经基本可以正确分类，那么构建叶节点，并将这些子集分到所对应的的叶节点中去。如果还有子集不能被正确分类，那么对这些子集选取新的最优特征，继续对其进行分割，直至所有训练数据都被正确分类。至此就构建出来一颗决策树。 通过上述步骤构建的决策树可以对训练数据集进行很好的分类，但是并不一定有很好的泛化能力，即可能发生过拟合现象。为了增强其泛化能力，我们需要对构建好的决策树进行自底向上的剪枝，即将树变得更简单一点。通过去掉决策树中过于细分的叶节点，使其回退到父节点甚至更高节点，用父节点或更高节点作为新的叶节点。 特征选择特征选择在于选取对训练数据具有良好分类能力的特征，这样可以提高决策树的学习效率。通常特征选择的准则是信息增益或信息增益比。 熵在信息论和概率统计中，熵是表示随机变量不确定性的度量。设$X$是一个取有限个值得离散随机变量，其概率分布为:P(X=x_i)=p_i, i=1,2,3...,n,则随机变量$X$的熵定义为:H(X)=-\\sum_{i=1}^np_i\\log p_i或(从定义可知和X的取值无关，只和其分布有关)H(p)=-\\sum_{i=1}^np_i\\log p_i熵有两种单位：（1）当公式中的对数以2为底时，单位为比特(bit)；（2）当公式中的对数以e为底时，单位为纳特(nat)。熵越大，随机变量的不确定性就越大。 条件熵设有随机变量$(X,Y)$其联合概率分布为:P(X=x_i,Y=y_j)=p_{ij},i=1,2,...n,j=1,2,...m条件熵$H(Y|X)$表示在已知随机变量$X$的条件下随机变量$Y$的不确定性，定义为$X$给定条件下$Y$的条件概率分布的熵对$X$的数学期望：H(Y|X)=\\sum_{i=1}^np_iH(Y|X=x_i) p_i=P(X=x_i),i=1,2,...,n 经验熵和经验条件熵当熵和条件熵中的概率由数据估计（特别是极大似然估计）得到时，对应的熵与条件熵分别称为经验熵和经验条件熵若有概率为0的，则令$0\\log0=0$ 信息增益（互信息）信息增益（也称为互信息）表示得知特征$X$的信息后特征$Y$的信息不确定性减少的程度，反应了特征$X$对于其他特征不确定性的影响程度。 特征$A$对训练数据集$D$的信息增益$g(D,A)$定义为集合$D$的经验熵$H(D)$与特征$A$在给定条件下$D$的经验条件熵$H(D|A)$之差，即g(D,A)=H(D)-H(D|A) 信息增益大的特征具有更强的分类能力（即表示在已知该特征的情况下，整个集合的不确定降低最多） 信息增益比以信息增益作为选择特征的准则，存在偏向于选择取值较多的特征的问题。即当一个特征可能的取值较多时，其计算出来的信息增益可能会较高，但是并不一定就一定是一个更有效的分类特征。采用信息增益比可以对这一问题进行校正，这是特征选择的另一准则。 特征$A$对训练数据集$D$的信息增益比$gR(D,A)$定义为其信息增益$g(D,A)$与训练数据集$D$关于特征$A$的值的熵$H_A(D)$之比，即：gR(D,A)=\\frac{g(D,A)}{H_A(D)},其中,$H_A(D)=-\\sum_{i=1}^n\\frac{|D_i|}{|D|}\\log_2\\frac{|D_i|}{|D|},n$是特征$A$取值的个数 决策树生成ID3算法(基于信息增益)ID3算法的核心是在决策树各个节点上应用信息增益准则选择特征，递归的构建决策树。 输入：训练数据集$D$，特征集$A$阈值$\\epsilon$ 输出：决策树$T$ (1)若$D$中实例属于同一类$C_k$，则$T$为单节点树。并将类$C_k$作为该节点的类标记，返回$T$ (2)若$A=\\phi$，则$T$为单节点树，并将$D$中实例数最大的类$C_k$作为该节点的类标记，返回$T$ (3)否则，按照求解信息增益的算法，计算$A$中各特征对$D$的信息增益，选择信息增益最大的特征$A_g$ (4)如果$A_g$的信息增益小于阈值$\\epsilon$,则置$T$为单节点树，并将$D$中实例数最大的类$C_k$作为该节点的类标记，返回$T$ (5)否则，对$A_g$的每一可能值$a_i$,依$A_g=a_i$将$D$分割为若干非空子集$D_i$，将$D_i$中实例数最大的类作为标记，构建子节点，由节点及其子节点构成树$T$,返回$T$ (6)对第$i$个子节点，以$D_i$为训练集，以$A-\\{A_g\\}$为特征集，递归调用步骤(1)~(5)，得到子树$T_i$,返回$T_i$ C4.5算法(基于信息增益比)C4.5算法本质上和ID3算法是一样的，只是采用信息增益比作为特征选择的评价准则。 输入：训练数据集$D$，特征集$A$阈值$\\epsilon$ 输出：决策树$T$ (1)若$D$中实例属于同一类$C_k$，则$T$为单节点树。并将类$C_k$作为该节点的类标记，返回$T$ (2)若$A=\\phi$，则$T$为单节点树，并将$D$中实例数最大的类$C_k$作为该节点的类标记，返回$T$ (3)否则，按照求解信息增益比的算法，计算$A$中各特征对$D$的信息增益，选择信息增益比最大的特征$A_g$ (4)如果$A_g$的信息增益比小于阈值$\\epsilon$,则置$T$为单节点树，并将$D$中实例数最大的类$C_k$作为该节点的类标记，返回$T$ (5)否则，对$A_g$的每一可能值$a_i$,依$A_g=a_i$将$D$分割为若干非空子集$D_i$，将$D_i$中实例数最大的类作为标记，构建子节点，由节点及其子节点构成树$T$,返回$T$ (6)对第$i$个子节点，以$D_i$为训练集，以$A-\\{A_g\\}$为特征集，递归调用步骤(1)~(5)，得到子树$T_i$,返回$T_i$ 决策树的剪枝通过前边决策树生成算法的步骤生成的决策树可能对训练数据有很好的拟合效果，但是由于分支过细，可能会包含太多训练集中的信息，导致泛化能力很差，对未知的数据没有准确的分类。解决这个问题的办法是考虑决策树的复杂度，对已生成的决策树进行简化。 输入：生成算法产生的整个决策树$T$,参数$\\alpha$ 输出：修剪后的子树$T_\\alpha$ (1)计算每个节点的经验熵(2)递归的从树的叶节点向上回缩。设一组叶节点回缩到其父节点之前与之后的整体树分别为$T_B,T_A$，其对应的损失函数分别是$C_\\alpha(T_B)$与$C_\\alpha(T_A)$,如果C_\\alpha(T_A)\\leq C_\\alpha(T_B)则进行剪枝，将父节点变为新的叶节点。(3)返回(2)，直至不能继续为止，得到损失函数最小的子树$T_\\alpha$","categories":[{"name":"大数据与网络安全","slug":"大数据与网络安全","permalink":"http://yoursite.com/categories/大数据与网络安全/"}],"tags":[{"name":"统计学习","slug":"统计学习","permalink":"http://yoursite.com/tags/统计学习/"},{"name":"机器学习","slug":"机器学习","permalink":"http://yoursite.com/tags/机器学习/"}],"keywords":[{"name":"大数据与网络安全","slug":"大数据与网络安全","permalink":"http://yoursite.com/categories/大数据与网络安全/"}]},{"title":"统计学习方法--朴素贝叶斯","slug":"《统计学习方法》笔记--朴素贝叶斯","date":"2019-06-09T08:49:37.000Z","updated":"2019-07-12T02:10:01.627Z","comments":true,"path":"2019/06/09/《统计学习方法》笔记--朴素贝叶斯/","link":"","permalink":"http://yoursite.com/2019/06/09/《统计学习方法》笔记--朴素贝叶斯/","excerpt":"","text":"朴素贝叶斯概述朴素贝叶斯法是基于贝叶斯定理与特征条件独立假设的分类方法。通过给定的训练数据集，首先基于特征条件独立的假设学习输入输出的联合概率分布，然后基于此模型，对于给定的$x$，利用贝叶斯定理求出后验概率最大的输出$y$ 朴素贝叶斯法 输入：训练数据$T=\\{(x_1,y_1),(x_2,y_2)…(x_N,y_N)\\};$其中$x_i=(x_i^{(1)},x_i^{2)},…,x_i^{(n)})^T;$$x_i{(j)}是第i个样本的第j个特征，x_i{(j)}\\in \\{a_{j1},a_{j2},…,a_{jS_j}\\},a_{jl}是第j个特征可能取得第l个值，j=1,2,3…,n;l=1,2,…S_j;y_i\\in\\{c_1,c_2,…,c_K\\};实例x$ 输出：实例$x$的分类 (1) 根据给出的训练集计算先验概率和条件概率P(Y=c_k)=\\frac{\\sum_{i=1}^{N}I(y_i=c_k)}{N},k=1,2,...,K----在给定训练集中c_k类的概率 P(X^{(j)}=a_{jl}|Y=c_k)=\\frac{\\sum_{i=1}^{N}I(x_i^{(j)}=a_{jl},y_i=c_k)}{\\sum_{i=1}^NI(y_i=c_k)}----在给定训练集中，已知为c_k类时，第j个特征取值为a_{jl}的概率 j=1,2,...,n;l=1,2,...,S_j;k=1,2...,K(2) 对于给定实例$x=(x^{(1)},x^{(2)},…,x^{(n)})^T,$计算P(Y=c_k)\\prod_{j=1}^nP(X^{(j)}=x^{(j)}|Y=c_k),k=1,2,...,K----对于给定的实例，计算在不同类别下其特征序列(x^{(1)},x^{(2)},...,x^{(n)})出现的概率(3)确定实例$x$所属的类y=\\arg\\max_{c_k}P(Y=c_k)\\prod_{j=1}^nP(X^{(j)}=x^{(j)}|Y=c_k)----将实例x归入特征序列出现概率最大的那一类 参数估计朴素贝叶斯法主要是通过训练集计算出每个类别$c_k$的先验概率，然后通过贝叶斯公式，计算出相应特征的条件概率，即在已知类别$c_k$的条件下各个特征出现的概率，最后通过求出在给定类别时出现概率最大的类别作为实例的类别。 极大似然估计在朴素贝叶斯法中，学习意味着估计$P(Y=c_k)$和$P(X^{j}=x^{(j)}|Y=c_k)$由于前提假设是特征条件相互，因此可以用极大似然估计法来估计相应的概率。 先验概率$P(Y=c_k)$的极大似然估计是P(Y=c_k)=\\frac{\\sum_{i=1}^{N}I(y_i=c_k)}{N},k=1,2,...,K 条件概率$P(X^{(j)}=a_{jl}|Y=c_k)$的极大似然估计是P(X^{(j)}=a_{jl}|Y=c_k)=\\frac{\\sum_{i=1}^{N}I(x_i^{(j)}=a_{jl},y_i=c_k)}{\\sum_{i=1}^NI(y_i=c_k)}----在给定训练集中，已知为c_k类时，第j个特征取值为a_{jl}的概率 j=1,2,...,n;l=1,2,...,S_j;k=1,2...,K 贝叶斯估计考虑到用极大似然估计可能会出现会估计的概率值为0的情况，可以采用贝叶斯估计来代替极大似然估计。具体的， 先验概率的贝叶斯估计为P_\\lambda(Y=c_k)=\\frac{\\sum_{i=1}^{N}I(y_i=c_k)+\\lambda}{N+K\\lambda} 条件概率的贝叶斯估计为P_\\lambda(X^{(j)}=a_{jl}|Y=c_k)=\\frac{\\sum_{i=1}^NI(x_i^{(j)=a_{jl}},y_i=c_k)+\\lambda}{\\sum_{i=1}^NI(y_i=c_k)+S_j\\lambda} 上式中$\\lambda\\geq0$等价于在随机变量各个取值的频数上赋予一个正数$\\lambda&gt;0$,当$\\lambda=0$时就是极大似然估计。常取$\\lambda=1$，这时称为拉普拉斯平滑。显然对于任何的$l=1,2,…S_j;k=1,2,…,K$有：P_\\lambda(X^{(j)}=a_{jl}|Y=c_k)>0 \\sum_{l=1}^{S_j}P_\\lambda(X^{(j)}=a_{jl}|Y=c_k)=1","categories":[{"name":"大数据与网络安全","slug":"大数据与网络安全","permalink":"http://yoursite.com/categories/大数据与网络安全/"}],"tags":[{"name":"统计学习","slug":"统计学习","permalink":"http://yoursite.com/tags/统计学习/"},{"name":"机器学习","slug":"机器学习","permalink":"http://yoursite.com/tags/机器学习/"}],"keywords":[{"name":"大数据与网络安全","slug":"大数据与网络安全","permalink":"http://yoursite.com/categories/大数据与网络安全/"}]},{"title":"统计学习方法--K近邻","slug":"《统计学习方法》笔记-K近邻","date":"2019-06-02T08:40:00.000Z","updated":"2019-07-12T02:10:01.627Z","comments":true,"path":"2019/06/02/《统计学习方法》笔记-K近邻/","link":"","permalink":"http://yoursite.com/2019/06/02/《统计学习方法》笔记-K近邻/","excerpt":"","text":"K近邻概述K近邻算法是一种基本分类与回归模型，该算法假定给定一个实例已经标定的训练数据集，在分类或回归时对新的实例，根据其K个最近邻的训练实例的类别，通过多数表决的方式进行预测，属于判别模型。K值得选择，距离度量，分类决策规则是K近邻算法的三个基本要素。 K近邻算法 输入：训练数据集$T=\\{(x_1,y_1),(x_2,y_2)…(x_N,y_N)\\};$其中 $x_i \\in \\chi \\subseteq R^n$为实例的特征向量 $y_i \\in \\gamma=\\{ c_1,c_2,…c_K\\}$为实例的类别$i=1,2,…N$;实例特征向量$x$ 输出：实例$x$所属的类$y$ (1) 根据给定的距离度量，在给定训练集$T$中找到与$x$最近邻的K个点，涵盖这K个点的$x$的邻域记做$N_k(x)$(2) 在$N_k(x)$中根据分类决策规则（如多数表决）决定$x$的类别$y$ y=\\arg max_{c_j}\\sum_{x_i\\in N_k(x)}I(y_i=c_j),i=1,2,...,N;j=1,2,3,...,K其中$I$为指示函数，即当$y_i=c_j$时$I$为$1$，否则$I$为$0$ 注: K近邻模型的特殊情况是当K=1时，即对于输入实例，选取最训练集中与其最近的点作为输入实例的类别。 距离度量在K近邻算法中需要通过距离这一度量单位来评价两个实例点之间的距离，如何选取合适的距离度量方式依据于具体的应用背景。 K近邻中关于距离的一般定义为:设特征空间$\\chi$是$n$维实数向量空间$R^n,x_i,x_j\\in \\chi,x_i=(x_i^{(1)},x_i^{(2)},…,x_i^{(n)})^T,x_j=(x_j^{(1)},x_j^{(2)},…,x_j^{(n)})^T,x_i,x_j$的$L_p$距离定义为：L_p(x_i,x_j)=(\\sum_{l=1}^{n}|x_i^{(l)}-x_j^{(l)}|^p)^{\\frac{1}{p}},p\\ge 1 当$p=2$时，称为欧氏距离，即$L_2(x_i,x_j)=(\\sum_{l=1}^{n}|x_i^{(l)}-x_j^{(l)}|^2)^{\\frac{1}{2}}$ 当$p=1$时，称为曼哈顿距离，即$L_1(x_i,x_j)=\\sum_{l=1}^{n}|x_i^{(l)}-x_j^{(l)}|$ 当$p=\\infty$时，$L_p$为各个坐标距离的最大值$L_\\infty(x_i,x_j)=\\max_l|x_i^{(l)}-x_j^{(l)}|$ K值的选择如果选取较小的K值，相当于用较小的邻域中的训练实例进行预测，预测结果会对近邻的实例点非常敏感。即K值得减小会使整体模型变得复杂，容易发生过拟合。 如果选取较大的K值，相当于用较大的领域中的训练实例进行预测，这时与输入实例较远的训练实例也会对预测产生影响。即K值得增大会使整体模型变得简单。 在应用中，K值一般选取一个较小的数值，通常采用交叉验证发来选取最优的K值。 分类决策规则多数表决规则K近邻法中常采用的是分类决策规则是多数表决，即由输入实例的K个近邻的训练实例中的多数类决定输入实例的类别。多数表决规则有如下解释：如果分类的损失函数为0-1算是函数，分类函数为f:R^n\\to\\{c_1,c_2,...,c_K\\},那么误分类的概率就是P(Y\\ne f(X))=1-P(Y=f(X)),对于给定的输入实例$x\\in\\chi$,其最近邻的K个训练实例点构成集合$N_k(x)$如果涵盖$N_k(x)$的区域的类别是$c_j$那么误分类率是\\frac{1}{k}\\sum_{x_i\\in N_k(x)}I(y_i\\ne c_j)=1-\\frac{1}{k}\\sum_{x_i\\in N_k(x)}I(y_i=c_j)由公式可知，要使误分类率（经验风险）最小，就要使$\\sum_{x_i\\in N_k(x)}I(y_i=c_j)$最大，即就要选取$N_k(x)$集合中实例最多的类作为输入实例的类别。","categories":[{"name":"大数据与网络安全","slug":"大数据与网络安全","permalink":"http://yoursite.com/categories/大数据与网络安全/"}],"tags":[{"name":"统计学习","slug":"统计学习","permalink":"http://yoursite.com/tags/统计学习/"},{"name":"机器学习","slug":"机器学习","permalink":"http://yoursite.com/tags/机器学习/"}],"keywords":[{"name":"大数据与网络安全","slug":"大数据与网络安全","permalink":"http://yoursite.com/categories/大数据与网络安全/"}]},{"title":"统计学习方法--感知机","slug":"《统计学习方法》笔记--感知机","date":"2019-05-28T08:49:37.000Z","updated":"2019-07-12T02:10:01.627Z","comments":true,"path":"2019/05/28/《统计学习方法》笔记--感知机/","link":"","permalink":"http://yoursite.com/2019/05/28/《统计学习方法》笔记--感知机/","excerpt":"","text":"感知机概述感知机是二类分类的线性模型，输入为实例的特征向量，输出为实例的类别，取+1和-1两个值。感知机本质对应于输入空间的一个超平面，通过将正负两类通过一个超平面划分开来，属于判别式模型。 感知机模型 假设输入空间（特征空间）是 $\\chi \\subseteqq R^n$ 输出空间是 $y=\\{+1,-1\\}$ 。输入$x\\in \\chi$表示实例的特征向量，对应于输入空间的点；输出$ y \\in Y$表示实例的类别。由输入空间到输出空间的如下函数 f(x)=sign(w \\cdot x +b) 称为感知机。其中 $w$ 和$b$称为感知机模型参数， $w\\in R^n$ 叫做权值或者权重向量，$b\\in R$ 叫做偏置，$w\\cdot x$ 表示$w$和$x$的内积，$sign$是符号函数,即sign(x)=\\left\\{\\begin{array}{cc}+1, & x \\geqslant0 \\\\-1, & \\ x","categories":[{"name":"大数据与网络安全","slug":"大数据与网络安全","permalink":"http://yoursite.com/categories/大数据与网络安全/"}],"tags":[{"name":"统计学习","slug":"统计学习","permalink":"http://yoursite.com/tags/统计学习/"},{"name":"机器学习","slug":"机器学习","permalink":"http://yoursite.com/tags/机器学习/"}],"keywords":[{"name":"大数据与网络安全","slug":"大数据与网络安全","permalink":"http://yoursite.com/categories/大数据与网络安全/"}]},{"title":"统计学习方法--概述","slug":"《统计学习方法》笔记--概述","date":"2019-05-28T08:49:37.000Z","updated":"2019-07-12T02:10:01.627Z","comments":true,"path":"2019/05/28/《统计学习方法》笔记--概述/","link":"","permalink":"http://yoursite.com/2019/05/28/《统计学习方法》笔记--概述/","excerpt":"","text":"统计学习概述统计学习是关于计算机基于数据构建概率统计模型并运用模型对数据进行预测与分析的学科。目的是使得计算机系统通过运用数据及统计学习方法提高系统性能。 统计学习方法可以概述如下： 从给定的，有限的用于训练的数据集合出发，假设数据是独立同分布产生的；并且假设要学习的模型属于某个函数的集合，称为假设空间；应用某个评价准则，从假设模型中选取一个最优模型，使它对已知的训练数据及未知的测试数据在给定的评定准则下有最优的预测；最优模型的选取由算法实现。 统计学习分类基本分类 监督学习：从标注数据中学习预测模型的机器学习问题，本质是学习输入到输出的映射统计规律 无监督学习：从无标注的数据中学习预测模型的机器学习问题，本质是学习数据中的统计规律或潜在结构 强化学习：智能系统在与环境的连续交互中学习最后最优行为策略的机器学习问题，本质是学习最优的序贯决策。智能系统的目的不是短期奖励的最大化，二十长期累积奖励的最大化。 半监督学习：指利用标注数据和未标注数据学习预测模型的机器学习问题。主要是通过未标注的数据中的信息，辅助标注数据进行监督学习。 主动学习：指机器不断主动给出具有较高区分度的实例进行标注，然后利用标注数据学习预测模型的机器学习问题。 按照模型分类 概率模型/非概率模型：两者的区别不在于输入和输出之间的映射，而在于模型的内在结构。概率模型一定可以表示为联合概率分布的形式，而非概率模型则不一定存在这样的联合概率分布。 线性模型/非线性模型：根据模型的函数表达形式是否是线性函数分为线性模型和非线性模型。 参数化模型/非参数化模型：参数化模型假设模型参数的维度固定，模型可以由有限维参数完全刻画，非参数化模型假设模型参数的维度不固定，随着训练数据量的增加而不断增大。 按照算法分类 在线学习：每次接受一个样本，进行预测，之后学习模型，并不断重复该循环步骤的机器学习问题。 批量学习：一次接受全部的数据，学习模型之后进行预测。 按照技巧分类 贝叶斯学习：在概率模型的学习和推理中，利用贝叶斯定理，计算在给定数据条件下模型的条件概率，并应用这个定理进行模型的估计以及数据的预测。 核方法：使用核函数表示和学习非线性模型的一种机器学习方法。 统计学习方法三要素模型模型就是要学习的条件概率分布或者决策函数 策略策略就是学习或者选择模型的准则 损失函数度量模型一次预测的好坏 风险函数度量平均意义下模型预测的好坏，也称为期望损失 期望风险是模型关于联合分布的的期望损失 经验风险是模型关于训练样本集的平均损失 结构风险是在经验风险上加上表示模型复杂度的正则化项或罚项 训练误差是指模型关于训练集的平均损失 测试误差是指模型关于测试集的平均损失 过拟合是指学习时选择的模型所包含的参数过多，以至于模型对已知的数据预测的很好，而对未知的数据预测的很差的现象。 交叉验证： 简单交叉验证（流出交叉验证）： 随机将数据分为两部分，一部分用于训练集，一部分用于验证集。 K折交叉验证： 随机将数据切分为K个互不交互，大小相等的数据集，每次用其中的K-1个数据集进行训练，用余下的子集测试模型，这样进行K次，用K次的平均值作为模型评价指标 留一交叉验证： K折交叉验证的特例，取K折数等于数据集容量N 泛化误差：模型对未知数据预测的误差的期望 生成模型/判别模型： 生成模型通过数据学习联合概率分布 $P(X,Y)$ 然后求出条件概率分布 $P(X|Y)$ 作为预测的模型。它表示了给定输入$X$输出 $Y$的生成关系。 判别模型通过数据直接学习决策函数 $f(X)$ 或者条件概率分布 $P(X|Y)$ 作为预测模型。它关心的是对给定的输入$X$，应该预测什么样的输出$Y$算法算法就是学习模型的具体计算方法","categories":[{"name":"大数据与网络安全","slug":"大数据与网络安全","permalink":"http://yoursite.com/categories/大数据与网络安全/"}],"tags":[{"name":"统计学习","slug":"统计学习","permalink":"http://yoursite.com/tags/统计学习/"},{"name":"机器学习","slug":"机器学习","permalink":"http://yoursite.com/tags/机器学习/"}],"keywords":[{"name":"大数据与网络安全","slug":"大数据与网络安全","permalink":"http://yoursite.com/categories/大数据与网络安全/"}]},{"title":"社会工程学学习笔记概述","slug":"社会工程学简述","date":"2019-05-09T08:49:37.000Z","updated":"2019-07-12T02:10:01.627Z","comments":true,"path":"2019/05/09/社会工程学简述/","link":"","permalink":"http://yoursite.com/2019/05/09/社会工程学简述/","excerpt":"","text":"社会工程学学习笔记概述什么是社会工程学 广义的说，社会工程学的定义是：通过建立理论并通过自然的，社会和制度上的途径且特别强调根据现实的双向计划和设计经验来一步一步的解决各种社会问题。在网络安全领域则更多的指的是通过欺骗，欺诈来操纵他人采取特定行动或泄露机密信息的行为。 社会工程攻击总览整个计算机领域的社会工程学攻击，大体上可以分为两大部分。 其一为非接触的信息收集，通过各种手段收集尽可能多的攻击目标的信息，提高后续攻击成功的可能性。 其二为与人交流的社会工程学攻击，通过在于相关人员交流的过程中套取感兴趣的信息，或者操纵有关人员实施某些特定的行为。 常见攻击方式 结合实际环境渗透针对特定环境进行渗透攻击，通常会根据观察被攻击者的一些日常行为习惯，如邮件的使用频率，重视程度，社交软件的使用频率和时间段等信息，结合获取的一些个人信息来综合判断，从而获取敏感信息甚至猜解出被攻击者的账户密码等重要信息。 伪装欺骗被攻击者电子邮件伪造攻击，网络钓鱼攻击等攻击手法都可以伪造欺骗被攻击者，从而使其进入指定的页面或者进行特定的操作。黑客主要利用被攻击者的猎奇，贪婪，疏于防范的心理引诱用户进而实现伪装欺骗的目的。 说服被攻击者说服是对网络安全影响较大的一种社工攻击手法。它要求黑客与被攻击者达成某种一致，进而使被攻击者主动为黑客攻击过程提供某种便利，如在僵尸网络的发展传播过程中就有主动志愿成为“肉鸡”的主机，从而从BotMaster手中获取一定利益的被攻击者。当被攻击者的利益与黑客没有冲突甚至是一致使，这种手段会非常有效。 恐吓被攻击者黑客在开展社工攻击过程中，常常会利用被攻击目标管理人员对目标系统安全的敏感性，以权威机构的身份出现，散步以安全警告，系统风险等恐吓性的手段迫使管理人员进行制定的操作，进而实现对目标信息的获取 反向社会工程学反向社会工程学是指黑客通过技术或非技术手段给网络或者计算机造成故障，使得被攻击者深信问题的存在，诱使工作人员主动将信息提供给黑客。 常见的信息搜集 爬虫爬虫是按照一定规则自动抓取网络信息的程序或脚本，网络搜索引擎就是某种形式的爬虫，我们可以通过爬虫来获取和关键词有关的信息并进行下载。 搜索引擎语法我们可以使用搜索引擎专用的各种语法来进行准确高效的搜索，常见的语法有“*”替代符，“inurl”搜索包含特定字符的URL，“intitle”搜索网页标题中包含有特定字符的网页，“filetype”搜索指定类型的文件。 Nmap（网络映射器）Namp是一款用于网络发现和安全审计的网络安全工具。它可以枚举网络主机清单，监控主机或服务运行状态，探测端口开放情况等。 DNS分析使用DNS分析可以收集有关DNS服务器和测试目标的相应记录信息。常用的有DNSenum，Maltego等。 NessusNessus是世界上最流行的漏洞扫描程序，它支持同时在本机或远端上遥控，进行系统的漏洞分析扫描,是社会工程学攻击中必不可少的工具。其他方面的攻击恶意插件浏览器恶意插件主要是通过引诱用户安装有一定功能的恶意插件，从而盗取用户的Cookie信息进行CSRF攻击（跨站请求伪造攻击）敲诈勒索软件按照危害程度可以分为影响使用，恐吓用户，绑架数据这三类。一般都是通过伪装成正常软件来诱使用户下载，当用户下载运行之后就直接执行指定的操作。社会工程学攻击的防范 保护个人信息资料不外泄在网络上注册信息时需要查看网站是否提供了对个人隐私信息的保护功能，尽可能的不要使用真实信息，提高注册过程中使用密码的复杂程度，以防止个人信息被黑客暴力破解。 时刻提高警惕在网络环境中，利用社会工程学攻击的手段复杂多变，网页的造伪很容易实现，收发的邮件中的收件人的地址也很容易造伪，因此不要轻易相信网络中看到的信息。 保持理性思维很多黑客在攻击时利用的方式大多数是人感性的弱点，进而施加影响。我们在与陌生人沟通时，应尽量保持理性思维，减少上当受骗的概率。 不要随意丢弃废物日常生活中我们的很多废弃物中都包含很多个人信息，如发票，取款机凭证等，这些看似无用的信息可能被有心的黑客利用实施社会工程学攻击，因此在丢弃废弃物时应小心谨慎，将其完全销毁在丢弃到垃圾桶中，防止个人信息的泄露。","categories":[{"name":"大数据与网络安全","slug":"大数据与网络安全","permalink":"http://yoursite.com/categories/大数据与网络安全/"}],"tags":[{"name":"渗透测试","slug":"渗透测试","permalink":"http://yoursite.com/tags/渗透测试/"},{"name":"密码攻击","slug":"密码攻击","permalink":"http://yoursite.com/tags/密码攻击/"}],"keywords":[{"name":"大数据与网络安全","slug":"大数据与网络安全","permalink":"http://yoursite.com/categories/大数据与网络安全/"}]},{"title":"Android自动化测试","slug":"Android自动化测试","date":"2018-11-09T08:49:37.000Z","updated":"2019-07-12T02:10:01.627Z","comments":true,"path":"2018/11/09/Android自动化测试/","link":"","permalink":"http://yoursite.com/2018/11/09/Android自动化测试/","excerpt":"","text":"Android自动化测试 adb shell monkey -p package [事件数] 用于对指定包名的应用进行压力测试 adb logcat | find “标签字符串” 用于将logcat中的命令输出到控制台 adb shell monkey —throttle [milliseconds] 每步操作之间间隔时长为 milliseconds adb shell monkey -s seed [event-count] 指定一个随机生成的值，每一个随机值确定一组相同的随机操作 adb shell monkey —ptc-touch [percent] 设定一组monkey事件组中触摸事件所占百分比 adb shell monkey —ptc-motion [percent] 设定一组monkey事件组中动作事件所占百分比 adb shell monkey —ptc-trackball [percent] 设定一组monkey事件组中轨迹球事件所占百分比 adb shell monkey —ptc-nav [percent] 设定一组monkey事件组中基本导航事件所占百分比 adb shell monkey —ptc-majornav [percent] 设定一组monkey事件组中主要导航事件所占百分比 adb shell monkey —ptc-syskeys [percent] 设定一组monkey事件组中系统导航事件所占百分比 adb shell monkey —ptc-appswitch [percent] 设定一组monkey事件组中启动Activity事件所占百分比 adb shell monkey —ptc-anyevent [percent] 设定一组monkey事件组中不常用事件所占百分比 adb shell monkey —ignore-crashs [event-count] 忽略崩溃事件继续进行测试 adb shell monkey —ignore-timeout [event-count] 忽略ANR事件继续进行测试 adb shell monkey -f [scriptfile] [event-count] 执行monkey脚本","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/tags/Android/"},{"name":"自动化测试","slug":"自动化测试","permalink":"http://yoursite.com/tags/自动化测试/"}],"keywords":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}]},{"title":"CCNA考试复习总结","slug":"CCNA考试复习总结","date":"2018-11-09T08:49:37.000Z","updated":"2019-07-12T02:10:01.627Z","comments":true,"path":"2018/11/09/CCNA考试复习总结/","link":"","permalink":"http://yoursite.com/2018/11/09/CCNA考试复习总结/","excerpt":"","text":"CCNA考试复习总结 设置默认网关：ip default-network [网关IP地址]或者是：ip route [源ip地址] [ 子 网 掩码] [下一跳ip地址] 为需要远程管理的交换机进行配置： ip default-getway [网关地址] interface vlan 1 ip address [需要远程管理的交换机的ip] [掩码] no shutdown 网络不可连接时的检查步骤： 检查网络连接是否正常 验证网卡配置 验证IP配置 检查URL是否正确 四种不同的线： 同种设备使用交叉反线（crossover） 异种设备间使用直通线（straight through） PC的COM口连接交换机的console口使用全反电缆（rollover cable） 连接带有串口的串行线（serial） 名词解释： CIR：约定信息速率 DCE：数据通讯设备 DTE：数据终端设备 LMI：本地管理接口 PVC：永久虚拟电路 SVC：虚电路 DLCI：数据链路标识符 PVST+：增强的按VLAN生成树 几种协议的管理距离： RIP：120 OSPF：110 静态路由：1 内部EIGRP：90 外部EIGRP：170 内部BGP：200 EGP：140 EIGRP路由汇总：5 外部BGP：20 IGRP：100 IS-IS自制系统：115 EGP：140 直连网络：0 组播地址： IPV4：224.0.0.2 IPV6：FF02：：2 本地地址： IPV4:127.0.0.1 IPV6： FE80开头 + {本地的MAC地址} 查看CPU使用率：show process 查看trunk端口： show interface trunk show interface switchport 交换机在trunk模式下的模式： auto：不会主动发送DTP信息 on：强制称为trunk，也会主动发送信息 desireable：DTP主动模式，发DTP和对方协商 STP（802.1d）端口状态： 阻塞(blocking)该端口被阻塞，不可以转发或接收数据包 监听(listening)该端口正在等待接收bpdu数据包，bpdu可能告知该端口重新回到阻塞状态 学习(learning)该端口正在向其转发数据库中添加地址，但是，并不转发数据包 转发(forwarding)该端口正在转发数据包 失效(disabled)该端口只是相应网管消息，并且必须先转到阻塞状态 RSTP（802.1w）端口状态： 禁止（Discarding） 学习（Learning） 转发（Forwarding） IPV6任播的三个特点： 数据包传送到该组接口，转发到最近结点 同组中多个接口公用一个地址 发送到任播地址的接口被发送到最近的结点 Trunk的协议： 通用的802.1q 思科私有的ISL IPV4向IPV6转换的方式： 隧道 双栈 NAT-PT DoD模型： Application Host to Host Internet Network Access 查看OSPF链路状态：show ip ospf database OSPF中进程号范围为1-65535 DHCP中IP地址冲突解决方案：检测到IP地址冲突时，会将冲突的IP地址删除，直到冲突解决之后再将IP地址放回 查看端口安全状态：show port-security interface [端口名] 链路状态协议的特点： 提供参看拓扑的命令 计算最短路径-利用触发更新 OSPF建立邻居关系的四个条件： 区域ID一致 hello，dead时间一致 认证方式和认证密码一致 区域性质一致（都是普通区域或者是末节区域） 在全局配置模式下查看直连设备：cdp run EIGRP查看邻居关系：show ip eigrp neighbors PAP采用两次握手机制，CHAP采用三次握手机制 PVC状态： ACTIVE：成功的端对端电路 INACTIVE：表示成功连接到交换机，但是在另一端未检测到DTE 配置的端口被交换机视为无效 SNMPv3比SNMPv2多添加的： 数据完整性 认证 加密 系统日志存储位置： RAM 控制台终端 系统日志服务器 系统日志级别： 0：Emergency 1：Alert 2：Critical 3：Error 4：Warning 5：Notice 6：Informational 7：Debug HSRP的virtual mac address以0000.0c07.acxx开头 IPV6任播的三个特点： 数据包转发到该组接口，转发到最近的结点 同组中多个接口公用一个地址 发到任播地址的包被转发到最近的结点 IPV6地址： FF01::1 — all nodes（node-local） FF01::2 — all routers(node-local) FF02::1 — all nodes(link-local) FF02::2 — all routers(link-local) FF02::5 — OSPFv3 routers FF02::6 — OSPFv3 designated routers FF02::9 — RIP FF02::A — EIGRP routers FF02::B — Mobile agents FF02::C — SSDP FF02::D — all PIM routers FF05::2 — all routers(site-local) FF05::1:3 — DHCP","categories":[{"name":"大数据与网络安全","slug":"大数据与网络安全","permalink":"http://yoursite.com/categories/大数据与网络安全/"}],"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"http://yoursite.com/tags/计算机网络/"},{"name":"CCNA","slug":"CCNA","permalink":"http://yoursite.com/tags/CCNA/"},{"name":"Cisco","slug":"Cisco","permalink":"http://yoursite.com/tags/Cisco/"}],"keywords":[{"name":"大数据与网络安全","slug":"大数据与网络安全","permalink":"http://yoursite.com/categories/大数据与网络安全/"}]},{"title":"Google Java编程风格规范","slug":"Google Java编程风格指南","date":"2018-11-09T08:49:37.000Z","updated":"2019-07-12T02:10:01.627Z","comments":true,"path":"2018/11/09/Google Java编程风格指南/","link":"","permalink":"http://yoursite.com/2018/11/09/Google Java编程风格指南/","excerpt":"","text":"作者：Hawstein出处：http://hawstein.com/posts/google-java-style.html声明：本文采用以下协议进行授权： 自由转载-非商用-非衍生-保持署名|Creative Commons BY-NC-ND 3.0 ，转载请注明作者及出处。 前言这份文档是Google Java编程风格规范的完整定义。当且仅当一个Java源文件符合此文档中的规则， 我们才认为它符合Google的Java编程风格。 与其它的编程风格指南一样，这里所讨论的不仅仅是编码格式美不美观的问题， 同时也讨论一些约定及编码标准。然而，这份文档主要侧重于我们所普遍遵循的规则， 对于那些不是明确强制要求的，我们尽量避免提供意见。 1.1术语说明在本文档中，除非另有说明： 术语class可表示一个普通类，枚举类，接口或是annotation类型(@interface) 术语comment只用来指代实现的注释(implementation comments)，我们不使用“documentation comments”一词，而是用Javadoc。 其他的术语说明会偶尔在后面的文档出现。 1.2指南说明本文档中的示例代码并不作为规范。也就是说，虽然示例代码是遵循Google编程风格，但并不意味着这是展现这些代码的唯一方式。 示例中的格式选择不应该被强制定为规则。 源文件基础2.1 文件名源文件以其最顶层的类名来命名，大小写敏感，文件扩展名为.java。 2.2 文件编码：UTF-8源文件编码格式为UTF-8。 2.3 特殊字符2.3.1 空白字符除了行结束符序列，ASCII水平空格字符(0x20，即空格)是源文件中唯一允许出现的空白字符，这意味着： 所有其它字符串中的空白字符都要进行转义。 制表符不用于缩进。 2.3.2 特殊转义序列对于具有特殊转义序列的任何字符(\\b, \\t, \\n, \\f, \\r, “, ‘及)，我们使用它的转义序列，而不是相应的八进制(比如\\012)或Unicode(比如\\u000a)转义。 2.3.3 非ASCII字符对于剩余的非ASCII字符，是使用实际的Unicode字符(比如∞)，还是使用等价的Unicode转义符(比如\\u221e)，取决于哪个能让代码更易于阅读和理解。 Tip: 在使用Unicode转义符或是一些实际的Unicode字符时，建议做些注释给出解释，这有助于别人阅读和理解。 例如： 12345String unitAbbrev = \"μs\"; | 赞，即使没有注释也非常清晰String unitAbbrev = \"\\u03bcs\"; // \"μs\" | 允许，但没有理由要这样做String unitAbbrev = \"\\u03bcs\"; // Greek letter mu, \"s\" | 允许，但这样做显得笨拙还容易出错String unitAbbrev = \"\\u03bcs\"; | 很糟，读者根本看不出这是什么return '\\ufeff' + content; // byte order mark | Good，对于非打印字符，使用转义，并在必要时写上注释 Tip: 永远不要由于害怕某些程序可能无法正确处理非ASCII字符而让你的代码可读性变差。当程序无法正确处理非ASCII字符时，它自然无法正确运行， 你就会去fix这些问题的了。(言下之意就是大胆去用非ASCII字符，如果真的有需要的话) 源文件结构一个源文件包含(按顺序地)： 许可证或版权信息(如有需要) package语句 import语句 一个顶级类(只有一个) 以上每个部分之间用一个空行隔开。 3.1 许可证或版权信息如果一个文件包含许可证或版权信息，那么它应当被放在文件最前面。 3.2 package语句package语句不换行，列限制(4.4节)并不适用于package语句。(即package语句写在一行里) 3.3 import语句3.3.1 import不要使用通配符即，不要出现类似这样的import语句：import java.util.*; 3.3.2 不要换行import语句不换行，列限制(4.4节)并不适用于import语句。(每个import语句独立成行) 3.3.3 顺序和间距import语句可分为以下几组，按照这个顺序，每组由一个空行分隔： 所有的静态导入独立成组 com.google imports(仅当这个源文件是在com.google包下) 第三方的包。每个顶级包为一组，字典序。例如：android, com,junit, org, sun java imports javax imports 组内不空行，按字典序排列。 3.4 类声明3.4.1 只有一个顶级类声明每个顶级类都在一个与它同名的源文件中(当然，还包含.java后缀)。例外：package-info.java，该文件中可没有package-info类。 3.4.2 类成员顺序类的成员顺序对易学性有很大的影响，但这也不存在唯一的通用法则。不同的类对成员的排序可能是不同的。 最重要的一点，每个类应该以某种逻辑去排序它的成员，维护者应该要能解释这种排序逻辑。比如， 新的方法不能总是习惯性地添加到类的结尾，因为这样就是按时间顺序而非某种逻辑来排序的。 3.4.2.1 重载：永不分离当一个类有多个构造函数，或是多个同名方法，这些函数/方法应该按顺序出现在一起，中间不要放进其它函数/方法。 格式术语说明：块状结构(block-like construct)指的是一个类，方法或构造函数的主体。需要注意的是，数组初始化中的初始值可被选择性地视为块状结构(4.8.3.1节)。 4.1 大括号4.1.1 使用大括号(即使是可选的)大括号与if, else, for, do, while语句一起使用，即使只有一条语句(或是空)，也应该把大括号写上。 4.1.2 非空块：K &amp; R 风格对于非空块和块状结构，大括号遵循Kernighan和Ritchie风格 (Egyptian brackets): 左大括号前不换行 左大括号后换行 右大括号前换行 如果右大括号是一个语句、函数体或类的终止，则右大括号后换行; 否则不换行。例如，如果右大括号后面是else或逗号，则不换行。 示例： 1234567891011return new MyClass() &#123; @Override public void method() &#123; if (condition()) &#123; try &#123; something(); &#125; catch (ProblemException e) &#123; recover(); &#125; &#125; &#125;&#125;; 4.8.1节给出了enum类的一些例外。 4.1.3 空块：可以用简洁版本一个空的块状结构里什么也不包含，大括号可以简洁地写成{}，不需要换行。例外：如果它是一个多块语句的一部分(if/else 或 try/catch/finally) ，即使大括号内没内容，右大括号也要换行。 示例： 1void doNothing() &#123;&#125; 4.2 块缩进：2个空格每当开始一个新的块，缩进增加2个空格，当块结束时，缩进返回先前的缩进级别。缩进级别适用于代码和注释。(见4.1.2节中的代码示例) 4.3 一行一个语句每个语句后要换行。 4.4 列限制：80或100一个项目可以选择一行80个字符或100个字符的列限制，除了下述例外，任何一行如果超过这个字符数限制，必须自动换行。 例外： 不可能满足列限制的行(例如，Javadoc中的一个长URL，或是一个长的JSNI方法参考)。 package和import语句(见3.2节和3.3节)。 注释中那些可能被剪切并粘贴到shell中的命令行。 4.5 自动换行术语说明：一般情况下，一行长代码为了避免超出列限制(80或100个字符)而被分为多行，我们称之为自动换行(line-wrapping)。 我们并没有全面，确定性的准则来决定在每一种情况下如何自动换行。很多时候，对于同一段代码会有好几种有效的自动换行方式。 Tip: 提取方法或局部变量可以在不换行的情况下解决代码过长的问题(是合理缩短命名长度吧) 4.5.1 从哪里断开自动换行的基本准则是：更倾向于在更高的语法级别处断开。 如果在非赋值运算符处断开，那么在该符号前断开(比如+，它将位于下一行)。注意：这一点与Google其它语言的编程风格不同(如C++和JavaScript)。 这条规则也适用于以下“类运算符”符号：点分隔符(.)，类型界限中的&amp;（)，catch块中的管道符号(catch (FooException | BarException e) 如果在赋值运算符处断开，通常的做法是在该符号后断开(比如=，它与前面的内容留在同一行)。这条规则也适用于foreach语句中的分号。 方法名或构造函数名与左括号留在同一行。 逗号(,)与其前面的内容留在同一行。 4.5.2 自动换行时缩进至少+4个空格自动换行时，第一行后的每一行至少比第一行多缩进4个空格(注意：制表符不用于缩进。见2.3.1节)。 当存在连续自动换行时，缩进可能会多缩进不只4个空格(语法元素存在多级时)。一般而言，两个连续行使用相同的缩进当且仅当它们开始于同级语法元素。 第4.6.3水平对齐一节中指出，不鼓励使用可变数目的空格来对齐前面行的符号。 4.6 空白4.6.1 垂直空白以下情况需要使用一个空行： 类内连续的成员之间：字段，构造函数，方法，嵌套类，静态初始化块，实例初始化块。例外：两个连续字段之间的空行是可选的，用于字段的空行主要用来对字段进行逻辑分组。 在函数体内，语句的逻辑分组间使用空行。 类内的第一个成员前或最后一个成员后的空行是可选的(既不鼓励也不反对这样做，视个人喜好而定)。 要满足本文档中其他节的空行要求(比如3.3节：import语句) 多个连续的空行是允许的，但没有必要这样做(我们也不鼓励这样做)。 4.6.2 水平空白除了语言需求和其它规则，并且除了文字，注释和Javadoc用到单个空格，单个ASCII空格也出现在以下几个地方： 分隔任何保留字与紧随其后的左括号(()(如if, for catch等)。 分隔任何保留字与其前面的右大括号(})(如else, catch)。 在任何左大括号前({)，两个例外： @SomeAnnotation({a, b})(不使用空格)。 String[][] x = foo;(大括号间没有空格，见下面的Note)。 在任何二元或三元运算符的两侧。这也适用于以下“类运算符”符号： 类型界限中的&amp;()。 catch块中的管道符号(catch (FooException | BarException e)。 foreach语句中的分号。 在, : ;及右括号())后 如果在一条语句后做注释，则双斜杠(//)两边都要空格。这里可以允许多个空格，但没有必要。 类型和变量之间：List list。 数组初始化中，大括号内的空格是可选的，即new int[] {5, 6}和new int[] { 5, 6 }都是可以的。 Note：这个规则并不要求或禁止一行的开关或结尾需要额外的空格，只对内部空格做要求。 4.6.3 水平对齐：不做要求术语说明：水平对齐指的是通过增加可变数量的空格来使某一行的字符与上一行的相应字符对齐。 这是允许的(而且在不少地方可以看到这样的代码)，但Google编程风格对此不做要求。即使对于已经使用水平对齐的代码，我们也不需要去保持这种风格。 以下示例先展示未对齐的代码，然后是对齐的代码： 12345private int x; // this is fineprivate Color color; // this tooprivate int x; // permitted, but future editsprivate Color color; // may leave it unaligned Tip：对齐可增加代码可读性，但它为日后的维护带来问题。考虑未来某个时候，我们需要修改一堆对齐的代码中的一行。 这可能导致原本很漂亮的对齐代码变得错位。很可能它会提示你调整周围代码的空白来使这一堆代码重新水平对齐(比如程序员想保持这种水平对齐的风格)， 这就会让你做许多的无用功，增加了reviewer的工作并且可能导致更多的合并冲突。 4.7 用小括号来限定组：推荐除非作者和reviewer都认为去掉小括号也不会使代码被误解，或是去掉小括号能让代码更易于阅读，否则我们不应该去掉小括号。 我们没有理由假设读者能记住整个Java运算符优先级表。 4.8 具体结构4.8.1 枚举类枚举常量间用逗号隔开，换行可选。 没有方法和文档的枚举类可写成数组初始化的格式： 1private enum Suit &#123; CLUBS, HEARTS, SPADES, DIAMONDS &#125; 由于枚举类也是一个类，因此所有适用于其它类的格式规则也适用于枚举类。 4.8.2 变量声明4.8.2.1 每次只声明一个变量不要使用组合声明，比如int a, b;。 4.8.2.2 需要时才声明，并尽快进行初始化不要在一个代码块的开头把局部变量一次性都声明了(这是c语言的做法)，而是在第一次需要使用它时才声明。 局部变量在声明时最好就进行初始化，或者声明后尽快进行初始化。 4.8.3 数组4.8.3.1 数组初始化：可写成块状结构数组初始化可以写成块状结构，比如，下面的写法都是OK的： 1234567891011121314151617new int[] &#123; 0, 1, 2, 3 &#125;new int[] &#123; 0, 1, 2, 3&#125;new int[] &#123; 0, 1, 2, 3&#125;new int[]&#123;0, 1, 2, 3&#125; 4.8.3.2 非C风格的数组声明中括号是类型的一部分：String[] args， 而非String args[]。 4.8.4 switch语句术语说明：switch块的大括号内是一个或多个语句组。每个语句组包含一个或多个switch标签(case FOO:或default:)，后面跟着一条或多条语句。 4.8.4.1 缩进与其它块状结构一致，switch块中的内容缩进为2个空格。 每个switch标签后新起一行，再缩进2个空格，写下一条或多条语句。 4.8.4.2 Fall-through：注释在一个switch块内，每个语句组要么通过break, continue, return或抛出异常来终止，要么通过一条注释来说明程序将继续执行到下一个语句组， 任何能表达这个意思的注释都是OK的(典型的是用// fall through)。这个特殊的注释并不需要在最后一个语句组(一般是default)中出现。示例： 1234567891011switch (input) &#123; case 1: case 2: prepareOneOrTwo(); // fall through case 3: handleOneTwoOrThree(); break; default: handleLargeNumber(input);&#125; 4.8.4.3 default的情况要写出来每个switch语句都包含一个default语句组，即使它什么代码也不包含。 4.8.5 注解(Annotations)注解紧跟在文档块后面，应用于类、方法和构造函数，一个注解独占一行。这些换行不属于自动换行(第4.5节，自动换行)，因此缩进级别不变。例如： 123@Override@Nullablepublic String getNameIfPresent() &#123; ... &#125; 例外：单个的注解可以和签名的第一行出现在同一行。例如： 1@Override public int hashCode() &#123; ... &#125; 应用于字段的注解紧随文档块出现，应用于字段的多个注解允许与字段出现在同一行。例如： 1@Partial @Mock DataLoader loader; 参数和局部变量注解没有特定规则。 4.8.6 注释4.8.6.1 块注释风格块注释与其周围的代码在同一缩进级别。它们可以是/ … /风格，也可以是// …风格。对于多行的/ … /注释，后续行必须从开始， 并且与前一行的对齐。以下示例注释都是OK的。 1234/* * This is // And so /* Or you can * okay. // is this. * even do this. */ */ 注释不要封闭在由星号或其它字符绘制的框架里。 Tip：在写多行注释时，如果你希望在必要时能重新换行(即注释像段落风格一样)，那么使用/ … /。 4.8.7 Modifiers类和成员的modifiers如果存在，则按Java语言规范中推荐的顺序出现。 1public protected private abstract static final transient volatile synchronized native strictfp 命名约定5.1 对所有标识符都通用的规则标识符只能使用ASCII字母和数字，因此每个有效的标识符名称都能匹配正则表达式\\w+。 在Google其它编程语言风格中使用的特殊前缀或后缀，如name_, mName, s_name和kName，在Java编程风格中都不再使用。 5.2 标识符类型的规则5.2.1 包名包名全部小写，连续的单词只是简单地连接起来，不使用下划线。 5.2.2 类名类名都以UpperCamelCase风格编写。 类名通常是名词或名词短语，接口名称有时可能是形容词或形容词短语。现在还没有特定的规则或行之有效的约定来命名注解类型。 测试类的命名以它要测试的类的名称开始，以Test结束。例如，HashTest或HashIntegrationTest。 5.2.3 方法名方法名都以lowerCamelCase风格编写。 方法名通常是动词或动词短语。 下划线可能出现在JUnit测试方法名称中用以分隔名称的逻辑组件。一个典型的模式是：test_，例如testPop_emptyStack。 并不存在唯一正确的方式来命名测试方法。 5.2.4 常量名常量名命名模式为CONSTANT_CASE，全部字母大写，用下划线分隔单词。那，到底什么算是一个常量？ 每个常量都是一个静态final字段，但不是所有静态final字段都是常量。在决定一个字段是否是一个常量时， 考虑它是否真的感觉像是一个常量。例如，如果任何一个该实例的观测状态是可变的，则它几乎肯定不会是一个常量。 只是永远不打算改变对象一般是不够的，它要真的一直不变才能将它示为常量。 1234567891011121314// Constantsstatic final int NUMBER = 5;static final ImmutableList&lt;String&gt; NAMES = ImmutableList.of(\"Ed\", \"Ann\");static final Joiner COMMA_JOINER = Joiner.on(','); // because Joiner is immutablestatic final SomeMutableType[] EMPTY_ARRAY = &#123;&#125;;enum SomeEnum &#123; ENUM_CONSTANT &#125;// Not constantsstatic String nonFinal = \"non-final\";final String nonStatic = \"non-static\";static final Set&lt;String&gt; mutableCollection = new HashSet&lt;String&gt;();static final ImmutableSet&lt;SomeMutableType&gt; mutableElements = ImmutableSet.of(mutable);static final Logger logger = Logger.getLogger(MyClass.getName());static final String[] nonEmptyArray = &#123;\"these\", \"can\", \"change\"&#125;; 这些名字通常是名词或名词短语。 5.2.5 非常量字段名非常量字段名以lowerCamelCase风格编写。 这些名字通常是名词或名词短语。 5.2.6 参数名参数名以lowerCamelCase风格编写。 参数应该避免用单个字符命名。 5.2.7 局部变量名局部变量名以lowerCamelCase风格编写，比起其它类型的名称，局部变量名可以有更为宽松的缩写。 虽然缩写更宽松，但还是要避免用单字符进行命名，除了临时变量和循环变量。 即使局部变量是final和不可改变的，也不应该把它示为常量，自然也不能用常量的规则去命名它。 5.2.8 类型变量名类型变量可用以下两种风格之一进行命名： 单个的大写字母，后面可以跟一个数字(如：E, T, X, T2)。 以类命名方式(5.2.2节)，后面加个大写的T(如：RequestT, FooBarT)。 5.3 驼峰式命名法(CamelCase)驼峰式命名法分大驼峰式命名法(UpperCamelCase)和小驼峰式命名法(lowerCamelCase)。 有时，我们有不只一种合理的方式将一个英语词组转换成驼峰形式，如缩略语或不寻常的结构(例如”IPv6”或”iOS”)。Google指定了以下的转换方案。 名字从散文形式(prose form)开始: 把短语转换为纯ASCII码，并且移除任何单引号。例如：”Müller’s algorithm”将变成”Muellers algorithm”。 把这个结果切分成单词，在空格或其它标点符号(通常是连字符)处分割开。 推荐：如果某个单词已经有了常用的驼峰表示形式，按它的组成将它分割开(如”AdWords”将分割成”ad words”)。 需要注意的是”iOS”并不是一个真正的驼峰表示形式，因此该推荐对它并不适用。 现在将所有字母都小写(包括缩写)，然后将单词的第一个字母大写： 每个单词的第一个字母都大写，来得到大驼峰式命名。 除了第一个单词，每个单词的第一个字母都大写，来得到小驼峰式命名。 最后将所有的单词连接起来得到一个标识符。 示例： 12345678Prose form Correct Incorrect------------------------------------------------------------------\"XML HTTP request\" XmlHttpRequest XMLHTTPRequest\"new customer ID\" newCustomerId newCustomerID\"inner stopwatch\" innerStopwatch innerStopWatch\"supports IPv6 on iOS?\" supportsIpv6OnIos supportsIPv6OnIOS\"YouTube importer\" YouTubeImporter YoutubeImporter* 加星号处表示可以，但不推荐。 Note：在英语中，某些带有连字符的单词形式不唯一。例如：”nonempty”和”non-empty”都是正确的，因此方法名checkNonempty和checkNonEmpty也都是正确的。 编程实践6.1 @Override：能用则用只要是合法的，就把@Override注解给用上。 6.2 捕获的异常：不能忽视除了下面的例子，对捕获的异常不做响应是极少正确的。(典型的响应方式是打印日志，或者如果它被认为是不可能的，则把它当作一个AssertionError重新抛出。) 如果它确实是不需要在catch块中做任何响应，需要做注释加以说明(如下面的例子)。 1234567try &#123; int i = Integer.parseInt(response); return handleNumericResponse(i);&#125; catch (NumberFormatException ok) &#123; // it's not numeric; that's fine, just continue&#125;return handleTextResponse(response); 例外：在测试中，如果一个捕获的异常被命名为expected，则它可以被不加注释地忽略。下面是一种非常常见的情形，用以确保所测试的方法会抛出一个期望中的异常， 因此在这里就没有必要加注释。 12345try &#123; emptyStack.pop(); fail();&#125; catch (NoSuchElementException expected) &#123;&#125; 6.3 静态成员：使用类进行调用使用类名调用静态的类成员，而不是具体某个对象或表达式。 1234Foo aFoo = ...;Foo.aStaticMethod(); // goodaFoo.aStaticMethod(); // badsomethingThatYieldsAFoo().aStaticMethod(); // very bad 6.4 Finalizers: 禁用极少会去重写Object.finalize。 Tip：不要使用finalize。如果你非要使用它，请先仔细阅读和理解Effective Java 第7条款：“Avoid Finalizers”，然后不要使用它。 Javadoc7.1 格式7.1.1 一般形式Javadoc块的基本格式如下所示： 12345/** * Multiple lines of Javadoc text are written here, * wrapped normally... */public int method(String p1) &#123; ... &#125; 或者是以下单行形式： 1/** An especially short bit of Javadoc. */ 基本格式总是OK的。当整个Javadoc块能容纳于一行时(且没有Javadoc标记@XXX)，可以使用单行形式。 7.1.2 段落空行(即，只包含最左侧星号的行)会出现在段落之间和Javadoc标记(@XXX)之前(如果有的话)。 除了第一个段落，每个段落第一个单词前都有标签，并且它和第一个单词间没有空格。 7.1.3 Javadoc标记标准的Javadoc标记按以下顺序出现：@param, @return, @throws, @deprecated, 前面这4种标记如果出现，描述都不能为空。 当描述无法在一行中容纳，连续行需要至少再缩进4个空格。 7.2 摘要片段每个类或成员的Javadoc以一个简短的摘要片段开始。这个片段是非常重要的，在某些情况下，它是唯一出现的文本，比如在类和方法索引中。 这只是一个小片段，可以是一个名词短语或动词短语，但不是一个完整的句子。它不会以A {@code Foo} is a…或This method returns…开头, 它也不会是一个完整的祈使句，如Save the record…。然而，由于开头大写及被加了标点，它看起来就像是个完整的句子。 Tip：一个常见的错误是把简单的Javadoc写成/ @return the customer ID */，这是不正确的。它应该写成/ Returns the customer ID. */。 7.3 哪里需要使用Javadoc至少在每个public类及它的每个public和protected成员处使用Javadoc，以下是一些例外： 7.3.1 例外：不言自明的方法对于简单明显的方法如getFoo，Javadoc是可选的(即，是可以不写的)。这种情况下除了写“Returns the foo”，确实也没有什么值得写了。 单元测试类中的测试方法可能是不言自明的最常见例子了，我们通常可以从这些方法的描述性命名中知道它是干什么的，因此不需要额外的文档说明。 Tip：如果有一些相关信息是需要读者了解的，那么以上的例外不应作为忽视这些信息的理由。例如，对于方法名getCanonicalName， 就不应该忽视文档说明，因为读者很可能不知道词语canonical name指的是什么。 7.3.2 例外：重写如果一个方法重写了超类中的方法，那么Javadoc并非必需的。 7.3.3 可选的Javadoc对于包外不可见的类和方法，如有需要，也是要使用Javadoc的。如果一个注释是用来定义一个类，方法，字段的整体目的或行为， 那么这个注释应该写成Javadoc，这样更统一更友好。 后记本文档翻译自Google Java Style， 译者@Hawstein。","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://yoursite.com/categories/编程语言/"}],"tags":[{"name":"编程规范","slug":"编程规范","permalink":"http://yoursite.com/tags/编程规范/"},{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}],"keywords":[{"name":"编程语言","slug":"编程语言","permalink":"http://yoursite.com/categories/编程语言/"}]},{"title":"Material Design使用总结","slug":"Material Design使用总结","date":"2018-11-09T08:49:37.000Z","updated":"2019-07-12T02:10:01.627Z","comments":true,"path":"2018/11/09/Material Design使用总结/","link":"","permalink":"http://yoursite.com/2018/11/09/Material Design使用总结/","excerpt":"","text":"Material Design使用总结Material Design是在Android5.0时新推出的一种设计规范，现在绝大部分的app都已经使用这种新的设计规范来进行界面设计。其主要是强调材质和层次感在设计中的应用，Android中也做了一些原生态的支持，但是要使用这些都必须最小兼容到Android5.0，也就是API 21，或者是添加Material Design的一个支持库。关于详细的Material Design的解释和说明，可以参考这本书： 电子书下载地址推荐两个Material Design的配色和图标网站： 一个是可以在线进行配色方案的查看：Materia l Palette 一个是提供Material Design风格的图标：Materia l Design Icons 主题：最基本的主题有三个：@android:style/Theme.Material@android:style/Theme.Material.Light@android:style/Theme.Material.Light.DarkActionBar这几个是基本的主题，也是分别代表三种风格的主题，更多的需要我们自己根据自己的需要来进行定制。 12345678&lt;!--actionBar颜色--&gt;&lt;item name=\"colorPrimary\"&gt;@android:color/holo_green_light&lt;/item&gt;&lt;!--状态栏颜色--&gt;&lt;item name=\"colorPrimaryDark\"&gt;@android:color/holo_green_light&lt;/item&gt;&lt;!--控件颜色--&gt;&lt;item name=\"colorAccent\"&gt;#464545&lt;/item&gt; 主要由几部分组成，colorPrimary，colorPrimaryDark，colorAccent，textColorPrimary，windowPrimary，navigationBarColor这个值可以使用系统已经提供的颜色值，也可以直接自己定制。 基本使用方式：Android中为我们提供了一个便捷的提取相应主题的工具—-Palette。其能根据传入的Bitmap来获取到一系列特定风格的颜色值，使得当前主题和传入的图片更为的贴切。使用该工具能很方便的创建出各种风格的主题。 要使用需要导入相应的包—com.android.support:palette-v7。如果是AS，则直接打开module setting，在dependencies中进行添加即可。如果是Eclipse，这需要去sdk文件夹——-extras—-android—support—-v7文件夹中将palette项目导入工作空间，并作为主工程的依赖项目。 导入完成后直接在代码中使用。 123456789//声明一个Bitmap对象Bitmap bitmap = BitmapFactory.decodeResource(MainActivity.this.getResources(), R.drawable.study55);// 声明一个palette对象Palette.Builder palette = Palette.from(bitmap);//获取到相应的色调，并设置个相应的组件。Palette.Swatch darkMutedSwatch = palette.generate().getDarkMutedSwatch();MainActivity.this.getWindow().setStatusBarColor(darkMutedSwatch.getRgb()); 效果如下：点击前： 点击后： 常见的一些提取的色调： getDarkMutedColor(int defaultColor)———获取一个柔和的，深色的颜色 getLightMutedColor(int defaultColor)———获取一个柔和的，亮色的颜色 getDarkVibrantColor(int defaultColor)———获取一个有活力的，深色的颜色 getLightVibrantColor(int defaultColor)———获取一个有活力的，浅色的颜色 getMutedColor(int defaultColor)———获取一个柔和的颜色 getVibrantColor(int defaultColor)———获取最为有活力的颜色 视图与阴影：在Material Design中新添加了一个布局属性，除了原本的X，Y之外，新添加了Z轴（包含静态的高度和动态的高度），使得视图在垂直与手机屏幕的方向上也有了属性，也就是产生了视图和阴影效果，而不像是之前所有的视图都在同一个平面上。 一张图来说明在Material Design中视图的推荐高度： 阴影效果：Z轴由两部分组成，静态高度和动态高度。静态高度常用于视图的固定布局，动态高度则常用于实现动画效果。即 Z =elevation + translationZ elevation=0 elevation = 100 我们可以使用SeekBar在代码里动态的修改阴影的高度，更多的还是将其作为动画来使用。 1234567891011121314151617mSeekBarElevation.setOnSeekBarChangeListener(new SeekBar.OnSeekBarChangeListener() &#123; @Override public void onProgressChanged(SeekBar seekBar, int progress, boolean fromUser) &#123; mCardView.setCardElevation(progress); &#125; @Override public void onStartTrackingTouch(SeekBar seekBar) &#123; &#125; @Override public void onStopTrackingTouch(SeekBar seekBar) &#123; &#125; &#125;); 裁剪与着色：1. 着色：新添加的一种对图像的修改方式，通过修改图像中的Alpha遮罩来修改图像。基本使用方式： 在xml文件中：直接为需要的图片设置着色颜色和着色的模式即可。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556&lt;!--原图--&gt;&lt;ImageView android:src=\"@mipmap/ic_launcher\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" /&gt;&lt;!--默认模式--&gt;&lt;ImageView android:tint=\"#3759f4\" android:src=\"@mipmap/ic_launcher\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" /&gt;&lt;!--add--&gt;&lt;ImageView android:tint=\"#3759f4\" android:tintMode=\"add\" android:src=\"@mipmap/ic_launcher\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" /&gt;&lt;!--multiply--&gt;&lt;ImageView android:tint=\"#3759f4\" android:tintMode=\"multiply\" android:src=\"@mipmap/ic_launcher\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" /&gt;&lt;!--screen--&gt;&lt;ImageView android:tint=\"#3759f4\" android:tintMode=\"screen\" android:src=\"@mipmap/ic_launcher\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" /&gt;&lt;!--src_atop--&gt;&lt;ImageView android:tint=\"#3759f4\" android:tintMode=\"src_atop\" android:src=\"@mipmap/ic_launcher\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" /&gt;&lt;!--src_over--&gt;&lt;ImageView android:tint=\"#3759f4\" android:tintMode=\"src_over\" android:src=\"@mipmap/ic_launcher\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" /&gt;&lt;!--src_in--&gt;&lt;ImageView android:tint=\"#3759f4\" android:tintMode=\"src_in\" android:src=\"@mipmap/ic_launcher\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" /&gt; 2. 裁剪： Clipping裁剪可以使我们能够为控件的外形绘制指定类型的形状，和之前的shape有相同的效果，只是这是直接修改外形，而不是作为一个背景。基本使用方式： 在布局文件中放置一个需要用到的控件，无需有额外的设置。 12345678&lt;ImageView android:layout_margin=\"10dp\" android:layout_alignParentRight=\"true\" android:layout_alignParentBottom=\"true\" android:id=\"@+id/fab_add\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:src=\"@mipmap/ic_launcher\"/&gt; 在Java代码中获取到这个控件并使用ViewOutlineProvider来为其设置外形。 1234567891011//声明一个ViewOutlineProvider实例，并设置需要的类型，有多种图形可以选择，只需要重写其getOutline方法即可。ViewOutlineProvider outlineProvider = new ViewOutlineProvider()&#123; @Override public void getOutline(View view, Outline outline) &#123; int fabSize = 100; outline.setOval(-4,-4,fabSize+2,fabSize+2); &#125;&#125;;//调用View的setOutlineProvider（）方法为控件设置外形。View fabView = findViewById(R.id.fab_add);fabView.setOutlineProvider(outlineProvider); 这样就做出了一个圆形的按钮（类似于FloatingActionBar）： 控件：1.RecyclerView :RecyclerView 是对ListView进行的一次提升和拓展，同时考虑到了布局的重用问题，通过内部的ViewHolder来提升效率，同时提供了更多新的特性和定制细节，有更大的定制功能。基本使用方式： 首先和ListView一样，做一个Item中要用到的布局，这个根据自己额业务需要来自由定制（演示只使用一个TextView）。 recycle_view_item.xml 123456789101112131415&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" android:orientation=\"vertical\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\"&gt; &lt;TextView android:fontFamily=\"monospace\" android:padding=\"10dp\" android:textSize=\"20sp\" android:id=\"@+id/id_show_text_view\" android:layout_width=\"match_parent\" android:layout_height=\"0dp\" android:layout_weight=\"1\"/&gt;&lt;/LinearLayout&gt; 然后和ListView相似，也是定制自己的Adapter，这里一般需要重新复写的方法有三个，并实现一个自己的ViewHolder（继承自RecyclerView.ViewHolder） RecycleViewAdapter.java 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374package com.wei.designsupportlibrarystudy;import android.support.v7.widget.RecyclerView;import android.view.LayoutInflater;import android.view.View;import android.view.ViewGroup;import android.widget.TextView;import java.util.ArrayList;import java.util.Random;/** * Created by WQC */public class RecycleViewAdapter extends RecyclerView.Adapter&lt;RecycleViewAdapter.ViewHolder&gt; &#123; //保存数据的Java Bean private final ArrayList&lt;DataModel&gt; mDatas; public RecycleViewAdapter(ArrayList&lt;DataModel&gt; mDatas) &#123; this.mDatas = mDatas; &#125; /** * 当ViewHolder被创建时调用 * @param parent 父控件 * @param viewType View类型 * @return ViewHolder的实例 */ @Override public ViewHolder onCreateViewHolder(ViewGroup parent, int viewType) &#123; View itemView = LayoutInflater.from(parent.getContext()).inflate(R.layout.recycle_view_item, parent, false); return new ViewHolder(itemView); &#125; /** * 当数据和View进行绑定时被调用 * @param holder ViewHolder实例 * @param position 当前View的Item位置 */ @Override public void onBindViewHolder(ViewHolder holder, int position) &#123; //根据Position来获取相应的数据 final DataModel rowData = mDatas.get(position); //数据显示到视图上 holder.showTextView.setText(rowData.getShowText()); holder.showTextView.setTag(rowData); &#125; /** * 获取列表项的长度 * @return 列表的长度 */ @Override public int getItemCount() &#123; return mDatas.size(); &#125; /** * 实现ViewHolder的内部类，用于布局的重用 */ public static class ViewHolder extends RecyclerView.ViewHolder &#123; //这里只有一个TextView，和recycle_view_item.xml布局里边是对应的，都是根据自己的业务需要进行修改。 private final TextView showTextView; //通过itemView 来进行重用 public ViewHolder(View itemView) &#123; super(itemView); showTextView = (TextView) itemView.findViewById(R.id.id_show_text_view); &#125; &#125; 然后就是在主布局中加入RecyclerView控件进行使用： activity_recycleview.xml 12345678910111213141516171819&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;RelativeLayoutxmlns:android=\"http://schemas.android.com/apk/res/android\"xmlns:tools=\"http://schemas.android.com/tools\"android:orientation=\"vertical\"android:layout_width=\"match_parent\"android:layout_height=\"match_parent\"&gt; &lt;android.support.v7.widget.RecyclerView android:elevation=\"1dp\" android:id=\"@+id/id_recycle_view\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" &lt;!--在这里进行滚动条方向的声明--&gt; android:scrollbars=\"vertical\" &lt;!--在这里进行item布局的声明--&gt; tools:listitem=\"@layout/recycle_view_item\"&gt; &lt;/android.support.v7.widget.RecyclerView&gt;&lt;/RelativeLayout&gt; 接着在Java代码中使用RecyclerView： RecycleViewActivity.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354package com.wei.designsupportlibrarystudy;import android.graphics.Outline;import android.os.Bundle;import android.support.v7.app.AppCompatActivity;import android.support.v7.widget.LinearLayoutManager;import android.support.v7.widget.RecyclerView;import android.view.View;import android.view.ViewOutlineProvider;import android.widget.LinearLayout;import java.util.ArrayList;/** * Created by WQC. */public class RecycleViewActivity extends AppCompatActivity &#123; RecyclerView mRecyclerView; LinearLayoutManager linearLayoutManager; RecycleViewAdapter recycleViewAdapter; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_recycleview); //获取到布局中声明的RecyclerView mRecyclerView =(RecyclerView)findViewById(R.id.id_recycle_view); //为RecyclerView指定一个布局管理器，可以是GridLayoutManager，LinearLayoutManager等，搭配使用有多种的表现形式。 linearLayoutManager = new LinearLayoutManager(this); //设置布局管理器 mRecyclerView.setLayoutManager(linearLayoutManager); //声明一个适配器实例，并传入数据。 recycleViewAdapter = new RecycleViewAdapter(initData(20)); //将适配器绑定到RecyclerView上 mRecyclerView.setAdapter(recycleViewAdapter); &#125; /** * 准备初始化数据 */ public ArrayList&lt;DataModel&gt; initData(int size)&#123; ArrayList&lt;DataModel&gt; datas = new ArrayList&lt;&gt;(size); for (int i = 0;i&lt;size;i++) &#123; datas.add(new DataModel(\"初始化数据\" + \"&lt;\" + i + \"&gt;\")); &#125; return datas; &#125;&#125; ps：DataModel.java文件（JavaBean） 12345678910111213141516171819202122package com.wei.designsupportlibrarystudy;/** * Created by WQC 用于承载数据的Bean */public class DataModel &#123; private String showText; public DataModel(String showText) &#123; this.showText = showText; &#125; public String getShowText() &#123; return showText; &#125; public void setShowText(String showText) &#123; this.showText = showText; &#125;&#125; 至此RecyclerView的简单使用就完成了，可以尝试修改其列表方向，布局管理器的种类，不同的搭配产生不一样的效果，例如列表项，图墙，画廊效果，都可以自定义实现。 关于RecycleView中的分隔线的问题： 最开始Google推出的RecycleVIew并没有给出默认的分隔线实现，只是提供了一个RecyclerView.ItemDecoration类共供我们自定义实现，后来推出的版本中就给出了默认实现的分隔线。 使用默认实现的分割线： 1mRecyclerView.addItemDecoration(new DividerItemDecoration(this, DividerItemDecoration.HORIZONTAL)); 使用自定义实现的分割线： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061/** * Created by WQC on 2016/5/12. * 自定义的item分隔符 */public class SimpleDivider extends RecyclerView.ItemDecoration &#123; private static final int[] attrs = &#123;android.R.attr.listDivider&#125;; private Drawable mDivider; public SimpleDivider(Context context) &#123; TypedArray typedArray = context.obtainStyledAttributes(attrs); mDivider = typedArray.getDrawable(0); typedArray.recycle(); &#125; /** * 重写该方法来绘制自定义的分隔线，这里绘制的是一条直线（矩形） * @param canvas * @param parent * @param state */ @Override public void onDrawOver(Canvas canvas, RecyclerView parent, RecyclerView.State state) &#123; //左下角的点 int left = parent.getPaddingLeft(); //右下角的点 int right = parent.getWidth() - parent.getPaddingRight(); //获取总共的item个数 int childCount = parent.getChildCount(); for (int i = 0; i &lt; childCount; i ++) &#123; View child = parent.getChildAt(i); RecyclerView.LayoutParams layoutParams = (RecyclerView.LayoutParams) child.getLayoutParams(); int top = child.getBottom() + layoutParams.bottomMargin; int bottom = top + mDivider.getIntrinsicHeight(); mDivider.setBounds(left, top, right, bottom); mDivider.draw(canvas); &#125; &#125; @Override public void onDraw(Canvas c, RecyclerView parent, RecyclerView.State state) &#123; super.onDraw(c, parent, state); &#125; @Override public void getItemOffsets(Rect outRect, View view, RecyclerView parent, RecyclerView.State state) &#123; super.getItemOffsets(outRect, view, parent, state); &#125;&#125; 附：鸿洋大神关于RecyclerView的文章：http://blog.csdn.net/lmj623565791/article/details/45059587 附：慕课网上有一个RecyclerView的使用视频教程：视频地址 2. GardViewCardView其实就是一个像其名字一样，是一个卡片布局，并且继承自Framelayout所以其也可以作为布局容器使用。 基本使用方式： 首先要导入其所在的jar包：android.support.v7.widget.CardView。在Android Studio中直接可以找到。右键Module，选择Open Module Setting,选择Dependencies，点右边的加号，直接输入CardView搜索即可。 在布局文件中直接使用CardView： content_card.xml 1234567891011121314151617181920212223242526272829&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:app=\"http://schemas.android.com/apk/res-auto\" xmlns:tools=\"http://schemas.android.com/tools\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:orientation=\"vertical\" android:paddingBottom=\"@dimen/activity_vertical_margin\" android:paddingLeft=\"@dimen/activity_horizontal_margin\" android:paddingRight=\"@dimen/activity_horizontal_margin\" android:paddingTop=\"@dimen/activity_vertical_margin\" app:layout_behavior=\"@string/appbar_scrolling_view_behavior\" tools:context=\"com.wei.designsupportlibrarystudy.CardActivity\" tools:showIn=\"@layout/activity_card\"&gt;&lt;!--上边的都是AS自动生成的，不用理会--&gt; &lt;android.support.v7.widget.CardView android:id=\"@+id/id_card_view\" android:layout_width=\"match_parent\" android:layout_height=\"160dp\" &lt;!--控件的高度，影响阴影的效果--&gt; android:elevation=\"200dp\" android:layout_marginRight=\"@dimen/activity_horizontal_margin\" android:layout_marginLeft=\"@dimen/activity_horizontal_margin\" app:cardBackgroundColor=\"@color/cardview_dark_background\" &lt;!--控件矩形边框的角度--&gt; app:cardCornerRadius=\"10dp\"&gt; &lt;/android.support.v7.widget.CardView&gt;&lt;/LinearLayout&gt; 然后在Java文件中通过findViewById()使用即可 CardViewActivity.java 1mCardView = (CardView) findViewById(R.id.id_card_view); 就是一个卡片的效果 3. FloatingActionButtonFloatingActionButton名为浮动圆形按钮，在android.support.design.widget.FloatingActionButton包下。这个兼容包主要是为了向低版本的Android设备兼容Material Design。上边图片中的邮件小图标便是FloatingActionButton的效果，其用法和ImageView相似，只是更加符合Material Design的设计规范，同时加入了阴影效果。 基本使用方法： 首先要添加上android.support.design这个库，AS中方法和之前一样，Eclipse中则需要进入sdk中，选择extra，选择android，选择support，将里边的design项目导入工作空间并作为主工程依赖的项目。 其次就是在布局文件中直接使用FloatingActionButton 布局文件中的使用： 1234567891011121314151617&lt;android.support.design.widget.FloatingActionButton android:id=\"@+id/fab\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout_gravity=\"bottom|end\" android:layout_margin=\"@dimen/fab_margin\" android:src=\"@android:drawable/ic_dialog_info\" &lt;!--以下是该控件新增加的xml属性--&gt; &lt;!--设置背景颜色--&gt; app:backgroundTint=\"#ff77\" &lt;!--设置大小--&gt; app:fabSize=\"mini\" &lt;!--设置静态的高度--&gt; app:elevation=\"20dp\" &lt;!--点击时的颜色--&gt; app:rippleColor=\"#FFF4D6D6\"/&gt; 在Java代码中获取使用： 1FloatingActionButton fab = (FloatingActionButton) findViewById(R.id.fab); 该控件其实就是一个特定的ImageButton，也可以设置自己的事件监听，实现需要的业务逻辑。 该片段为FloatingActionButton设置了业务逻辑，点击时弹出一个Snackbar显示消息。 1234567fab.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; Snackbar.make(view, \"Replace with your own action\", Snackbar.LENGTH_LONG) .setAction(\"Action\", null).show(); &#125; &#125;); 4.TextInputLayout TextInputLayout 其实是一个对于EditText进行拓展的新控件，原本的EditText的默认提示文本hint在点击输入时就会消失，而TextInputLayout使得点击输入后也依然显示提示信息。 基本使用方式： 首先也是导入android.support.design这个包，然后在布局文件中直接进行使用，将EditText放入TextInputLayout中。 123456789&lt;android.support.design.widget.TextInputLayout android:layout_below=\"@+id/tabLayout\" android:id=\"@+id/textInput\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\"&gt; &lt;EditText android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" /&gt;&lt;/android.support.design.widget.TextInputLayout&gt; 然后在Java文件中进行使用 1234567891011121314151617181920212223242526272829303132//获取布局中的控件 final TextInputLayout textInputLayout = (TextInputLayout) findViewById(R.id.textInput); //设置Hint信息 textInputLayout.setHint(\"请输入用户名\"); //获取放在textInputLayout中的EditText EditText editText = textInputLayout.getEditText(); if (editText != null) &#123; //为EditText设置事件监听，用于处理输入事件 editText.addTextChangedListener(new TextWatcher() &#123; @Override public void beforeTextChanged(CharSequence s, int start, int count, int after) &#123; &#125; @Override public void onTextChanged(CharSequence s, int start, int before, int count) &#123; if (s.length() &gt; 10) &#123; //使用textInputLayout进行消息提示 textInputLayout.setError(\"输入的用户名不能超出10位\"); textInputLayout.setErrorEnabled(true); &#125;else &#123; textInputLayout.setErrorEnabled(false); &#125; &#125; @Override public void afterTextChanged(Editable s) &#123; &#125; &#125;); &#125; 效果： 5. Tablayout 新出来的一个布局，可以很便捷的帮我们实现选项卡的功能。要使用需要导入android.support.design.widget.TabLayout包 基本使用方式： 首先导入包，然后直接在布局文件中添加上即可。 布局文件 123456&lt;android.support.design.widget.TabLayout android:layout_alignParentTop=\"true\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" app:tabMode = \"scrollable\" android:id=\"@+id/tabLayout\"&gt;&lt;/android.support.design.widget.TabLayout&gt; 然后在Java代码中获取到，进行设置： 123456789TabLayout tabs = (TabLayout)findViewById(R.id.tabLayout);tabs.addTab(tabs.newTab().setText(\"tab1\"));tabs.addTab(tabs.newTab().setText(\"tab2\"));tabs.addTab(tabs.newTab().setText(\"tab3\"));tabs.addTab(tabs.newTab().setText(\"tab4\"));tabs.addTab(tabs.newTab().setText(\"tab4\"));tabs.addTab(tabs.newTab().setText(\"tab4\"));tabs.addTab(tabs.newTab().setText(\"tab4\"));tabs.addTab(tabs.newTab().setText(\"tab4\")); 这样就可以做出选项卡的效果了 6. SnackBar： SncakBar是新出来的一款控件，他提供了一个特贴轻量级的反馈，作用类似于Toast，但是又和Toast有所区别。 官方文档的内容： Snackbars provide lightweight feedback about an operation. They show a brief message at the bottom of the screen on mobile and lower left on larger devices. Snackbars appear above all other elements on screen and only one can be displayed at a time. Snackbars can contain an action which is set via setAction(CharSequence, android.view.View.OnClickListener). To be notified when a snackbar has been shown or dismissed, you can provide a Snackbar.Callback via setCallback(Callback). 翻译： SnackBar为一个操作提供了一个轻量级的回馈。它在手机屏幕的底部或者是在大屏幕设备的左下方显示一个简短的消息。SnackBar位于屏幕上所有元素的上方，并且只能显示一段时间 SnackBar可以通过setAction(CharSequence, android.view.View.OnClickListener)方法来包含一个动作 可以通过提供setCallback(Callback)接口来获取SnackBar显示和消失时的通知 基本使用方式： 类似于Toast，直接在程序中使用： Java代码： 12345678910Snackbar snackbar = Snackbar.make(actionButton, \"你点击了按钮\", Snackbar.LENGTH_LONG);snackbar.setAction(\"知道了\", new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; snackbar.dismiss(); &#125;&#125;);snackbar.show(); 当然了Material Design中新出现的各种特性，新控件，新布局还有很多，这只是我自己使用的一个总结，欢迎交流和分享。 2016.11.28更新：7. ToolBar： ToolBar已经开始取代ActionBar作为主要的标题栏的实现方式，使用toolBar也很简单，首先同样是在XML布局文件中声明好，然后在Java代码中获取使用即可。需要注意的是使用toolBar时要声明app使用的theme为android:theme=”@style/AppTheme.NoActionBar”,否则容易引起ActionBar和ToolBar的冲突。 //在xml布局文件中定义好 1234567&lt;android.support.v7.widget.Toolbar android:id=\"@+id/toolbar\" android:layout_width=\"match_parent\" android:layout_height=\"?attr/actionBarSize\" android:background=\"?attr/colorPrimary\" app:popupTheme=\"@style/AppTheme.PopupOverlay\"/&gt; //其中popupTheme是用于指定菜单选项弹出的样式的 //在Java代码中获取并使用 12Toolbar toolbar = (Toolbar) findViewById(R.id.toolbar); setSupportActionBar(toolbar); 这样就把ActionBar替换成了ToolBar，同时需要实现ToolBar对应的方法，包括menu菜单创建时和menu菜单项被点击时： 12345678910111213141516171819202122232425262728293031/** * 创建菜单时 * @param menu * @return */@Override public boolean onCreateOptionsMenu(Menu menu) &#123; // Inflate the menu; this adds items to the action bar if it is present. getMenuInflater().inflate(R.menu.main, menu); return true; &#125; /** * 菜单项被点击时 * @param item * @return */ @Override public boolean onOptionsItemSelected(MenuItem item) &#123; // Handle action bar item clicks here. The action bar will // automatically handle clicks on the Home/Up button, so long // as you specify a parent activity in AndroidManifest.xml. int id = item.getItemId(); //noinspection SimplifiableIfStatement if (id == R.id.action_settings) &#123; return true; &#125; return super.onOptionsItemSelected(item); &#125; 8. AppBarLayout： 参考自：http://blog.csdn.net/solo_talk/article/details/52222269 AppBarLayout可以将其布局里边所有的View都作为标题栏存在，例如可以在AppBarLayout中放一个ToolBar和一个ImageView，这样能丰富标题栏的类型。更主要的是使用AppBarLayout可以设置里边控件的滑动属性，实现滑动时AppBarLayout布局里边的控件隐藏或者是显示。 控制属性： scroll：表示向下滚动的时候，设置了这个属性的View会被滚出屏幕范围，直到消失，想要实现滑动隐藏的话必须要有这个属性 enterAlways：表示向上滚动的时候，设置了这个属性的View会随着滚动手势逐渐出现，直到恢复原来设置的位置 enterAlwaysCollapsed：是enterAlways的附加选项，一般跟enterAlways一起使用，它是指，View在往下“出现”的时候，首先是enterAlways效果，当View的高度达到最小高度时，View就暂时不去往下滚动，直到ScrollView滑动到顶部不再滑动时，View再继续往下滑动，直到滑到View的顶部结束。 exitUntilCollapsed：值设为exitUntilCollapsed的View，当这个View要往上逐渐“消逝”时，会一直往上滑动，直到剩下的的高度达到它的最小高度后，再响应ScrollView的内部滑动事件。 使用方式： AppBarLayout需要有一个和它同层次的滚动布局来配合使用，同时要以CoordinatorLayout作为根布局（因为只有CoordinatorLayout布局为根布局，不同的布局之间才能相互联系起来） 伪代码表示使用方式： 1234567891011121314151617181920&lt;CoordinatorLayout&gt; &lt;AppBarLayout&gt; &lt;ToolBar app:layout_scrollFlags=\"scroll|exitUntilCollapsed\"&gt; &lt;/ToolBar&gt; &lt;ImageView app:layout_scrollFlags=\"scroll|exitUntilCollapsed\"/&gt; &lt;/AppBarLayout&gt; &lt;!--和AppBarLayout同层级的滚动视图，如ScrollView等，同时设置app:layout_behavior属性--&gt; &lt;ScrollView app:layout_behavior=\"@string/appbar_scrolling_view_behavior\"&gt; &lt;/ScrollView&gt;&lt;/CoordinatorLayout&gt; 这样当下边的ScrollView向上滑动时，AppBarLayout中的控件会全部隐藏，向下滑动时会显示出来。 9. CoordinatorLayout：参考自http://blog.csdn.net/u010687392/article/details/46906657CoordinatorLayout可以组织多个子View之间相互协作，使用时同样需要引入design.support支持库。 在CoordinatorLayout布局中可以为其他的子View添加app:layout_behavior这个属性。若View添加上这个属性，那么当其产生响应的行为时CoordinatorLayout布局中的其他子View就可以获知这个消息，这时若是属性中设置了app:layout_scrollFlags这个属性的View就可以根据接受到的事件产生相应的动作。 使用方法： 1234567891011121314151617181920212223242526272829&lt;android.support.design.widget.CoordinatorLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:app=\"http://schemas.android.com/apk/res-auto\" android:id=\"@+id/coordinator_layout\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\"&gt; &lt;android.support.design.widget.AppBarLayout android:id=\"@+id/appbar_layout\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:fitsSystemWindows=\"true\"&gt; &lt;android.support.v7.widget.Toolbar android:id=\"@+id/toolBar\" android:layout_width=\"match_parent\" android:layout_height=\"?attr/actionBarSize\" android:background=\"#30469b\" app:layout_scrollFlags=\"scroll|enterAlways\" /&gt; &lt;/android.support.design.widget.AppBarLayout&gt; &lt;LinearLayout android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:orientation=\"vertical\" android:scrollbars=\"none\" app:layout_behavior=\"@string/appbar_scrolling_view_behavior\"&gt; &lt;!--为LinearLayout设置了behavior属性，当其滑动时，CoordinatorLayout就会通知其他设置了app:layout_scrollFlags属性的View产生变化 --&gt; &lt;/LinearLayout&gt; &lt;/android.support.design.widget.CoordinatorLayout&gt; 10. CollapsingToolbarLayout： 这是一个可以折叠的ToolBarLayout布局，可以用它来包裹ToolBar，指定当滑动时CollapsingToolbarLayout发生折叠，而ToolBar可以保留下来，这样就可以实现当滑动时，顶部的控件都折叠了，独留下Toolbar。 使用方式： 123456789101112131415161718192021222324&lt;android.support.design.widget.AppBarLayout android:id=\"@+id/app_bar\" android:layout_width=\"match_parent\" android:layout_height=\"@dimen/app_bar_height\" android:fitsSystemWindows=\"true\" android:theme=\"@style/AppTheme.AppBarOverlay\"&gt; &lt;android.support.design.widget.CollapsingToolbarLayout android:id=\"@+id/toolbar_layout\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:fitsSystemWindows=\"true\" app:contentScrim=\"?attr/colorPrimary\" app:layout_scrollFlags=\"scroll|exitUntilCollapsed\"&gt; &lt;android.support.v7.widget.Toolbar android:id=\"@+id/toolbar\" android:layout_width=\"match_parent\" android:layout_height=\"?attr/actionBarSize\" app:layout_collapseMode=\"pin\" app:popupTheme=\"@style/AppTheme.PopupOverlay\"/&gt; &lt;/android.support.design.widget.CollapsingToolbarLayout&gt; &lt;/android.support.design.widget.AppBarLayout&gt; 另附： Git-Hub上的一个UI测试库，遵循Material Design原则：github地址 Material Design控件demo：github地址","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}],"tags":[{"name":"UI支持库","slug":"UI支持库","permalink":"http://yoursite.com/tags/UI支持库/"},{"name":"Material Design","slug":"Material-Design","permalink":"http://yoursite.com/tags/Material-Design/"}],"keywords":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}]},{"title":"MongoDB使用入门及问题总结","slug":"MongoDB入门及问题总结","date":"2018-11-09T08:49:37.000Z","updated":"2019-07-12T02:10:01.627Z","comments":true,"path":"2018/11/09/MongoDB入门及问题总结/","link":"","permalink":"http://yoursite.com/2018/11/09/MongoDB入门及问题总结/","excerpt":"","text":"MongoDB使用入门及问题总结最近学习Python爬虫开发时需要使用MongoDB数据库，为此做个使用入门的介绍和所遇问题的总结。 关于MongoDB关于MongoDB的简介可以直接去官网查看，主要和传统的MySQL，SQL Server这些数据库的不同之处在于它是NoSql型数据库，即非关系型数据库。不同于MySQL中的数据都是一张张的关系表结构，MongoDB中的数据并不是以相互之间的关系表来存储的，所以这种数据的存储方式更适合复杂的爬虫环境。 参考文档：MongoDB官网MongoDB中文社区MongoDB官方中文文档MongoDB的入门视频教程MongoDB的下载和安装关于下载和安装直接按照官网的流程来即可 选择对应操作系统的版本，下载下来直接安装即可。 MongoDB的遇到的问题一 . 安装官方下载的msi的时候始终提示安装失败解决办法： 在安装程序最后一步的时候不勾选左下角的mongodb-compass 选项 二. 配置MongoDB为window服务时失败解决办法： 删除用于存放数据库的文件夹中的mongod.lock和storage.bson 文件，在重新启动 相关参考文章mongodb安装及100报错 关于安装MongoDB的过程与错误48 100的解决方法","categories":[{"name":"杂学","slug":"杂学","permalink":"http://yoursite.com/categories/杂学/"}],"tags":[{"name":"MongoDB","slug":"MongoDB","permalink":"http://yoursite.com/tags/MongoDB/"},{"name":"数据库","slug":"数据库","permalink":"http://yoursite.com/tags/数据库/"}],"keywords":[{"name":"杂学","slug":"杂学","permalink":"http://yoursite.com/categories/杂学/"}]},{"title":"Windows系统安全综述","slug":"Windows系统安全综述","date":"2018-11-09T08:49:37.000Z","updated":"2019-07-12T02:10:01.627Z","comments":true,"path":"2018/11/09/Windows系统安全综述/","link":"","permalink":"http://yoursite.com/2018/11/09/Windows系统安全综述/","excerpt":"","text":"Windows系统安全综述账户分类及概述用户账户 不同的用户身份拥有不同的权限 每个用户包含一个名称和一个密码 用户账户拥有唯一的安全标识符 在服务器管理器中管理用户 创建用户 为用户重置密码 重命名用户名 启用，禁用，删除用户账户 为用户设置权限 通过进程与服务区分各内置用户账户的作用 与使用者关联的用户账户 Administrator（管理员用户） Guest（来宾用户） 与Windows组件关联的用户账户 SYSTEM（本地系统） SYSTEM SERVICE（本地服务） NETWORK SERVICE（网络服务） 组账户 组是一些用户的集合 组内的用户自动具备组所设置的权限 在服务器管理其中管理组 新建组 向组内添加成员 重命名组 删除组 需要人为添加成员的内置组 Administrator Guests Power User Users（标准用户） 动态包含成员的内置组 Interactive（动态包含在本地登陆的用户） Authenticated Users（动态包含通过验证的用户，不包含来宾用户） Everyone（包含任何用户，设置开放的权限是经常使用） 克隆账户以及账户超级隐藏 在添加用户时在要添加的用户名后边多加一个 $ 符号(表示隐藏) net user test$ /add 通过这种方式创建的用户直接使用命令行的net user命令是无法查看到的，但是可以通过计算机管理界面查看到存在该账户 通过修改注册表中的信息来达到完全隐藏账户的 新建一个常规的隐藏账户（test$） 打开注册表，找到HKEY_LOCAL_MACHINE下的SAM，右键为其赋予权限之后展开 将Administrator的权限导出，同时将test$账户的权限和用户信息注册表导出 打开导出的Administrator和test$的权限注册表，用Administrator中的F的值代替test$中的F的值 删除之前创建的test$用户 运行之前导出的test$的注册表和test$权限的注册表 完成完全隐藏用户的创建（只能通过注册表来查找到） NTFS文件系统及权限应用 NTFS (New Technology File System)，是 WindowsNT 环境的文件系统。新技术文件系统是Windows NT家族（如，Windows 2000、Windows XP、Windows Vista、Windows 7和 windows 8.1）等的限制级专用的文件系统（操作系统所在的盘符的文件系统必须格式化为NTFS的文件系统，4096簇环境下）。NTFS取代了老式的FAT文件系统。NTFS对FAT和HPFS作了若干改进，例如，支持元数据，并且使用了高级数据结构，以便于改善性能、可靠性和磁盘空间利用率，并提供了若干附加扩展功能。 提高磁盘读写性能 可靠性 加密文件系统 访问控制列表 磁盘利用率 压缩 EFS加密为了提高文件的安全性，微软在Windows中针对NTFS引入了EFS加密技术。EFS加密操作简单，对加密文件的用户也是透明的，文件加密后不必再试用期手动解密，只有加密则才能打开加密文件。 EFS加密是基于公钥策略的。然后将利用FEK和数据扩展标准X算法创建加密后的文件，。如果你登录到了域环境中，密钥的生成依赖于域控制器，否则它就依赖于本地机器 EFS加密最简单的办法就是在目标对象上点击鼠标右键，选择“属性”，打开属性对话框,然后在常规选项卡上点击“高级”按钮，打开高级属性对话框，选中“加密内容以便保护数据”这个选项，反之解密。 服务service可以分为两个大类，服务应用程序和驱动服务。 服务应用程序指遵照Service Control Manager 2接口要求的，能在系统启动时自动启动的用户能够通过服务控制面板控制的那些没有用户登录也能够运行的程序。 驱动服务一般指设备驱动程序协议等应用于底层设备驱动的服务 病毒及防范计算机病毒定义 编制或者在计算机程序中插入的，破坏技术啊你功能或者破坏数据，影响计算机使用并且能够自我复制的一组计算机指令或者程序代码 特点 非授权执行 隐蔽性 传染性 潜伏性 破坏性 可触发性 分类 文件型 引导扇区型 宏病毒 VBS脚本病毒 蠕虫 脚本病毒 通常与网页相结合，将恶意的破坏性代码内嵌在网页中 利用asp，htm，html，vbs，js类型的文件进行传播 基于VB Script和Java Script脚本语言 由Windows脚本宿主解释执行（也具有跨平台的特性） 特点 隐蔽性强 浏览网页，电子邮件中的病毒可以具有双拓展名 传播性广 可以自我复制，不依赖于其他文件就可以直接解释执行 病毒变种多 只需要对源码稍加修改，就可以制造出新的变种病毒 计算机木马定义一个包含在合法程序中的非法程序 特征 未经许可即获得计算机的使用权 程序容量小，执行时不会占用太多资源 执行后很难停止 执行时不会在系统中显示出来 执行一次后会驻留在系统中，可以自动加载运行 自动变更文件名 作为驻留程序隐藏在系统内部 分为客户端和服务端 危害文件操作，修改注册表，窃取密码，系统操控","categories":[{"name":"大数据与网络安全","slug":"大数据与网络安全","permalink":"http://yoursite.com/categories/大数据与网络安全/"}],"tags":[{"name":"系统安全概述","slug":"系统安全概述","permalink":"http://yoursite.com/tags/系统安全概述/"},{"name":"Windows","slug":"Windows","permalink":"http://yoursite.com/tags/Windows/"}],"keywords":[{"name":"大数据与网络安全","slug":"大数据与网络安全","permalink":"http://yoursite.com/categories/大数据与网络安全/"}]},{"title":"图及其操作（C语言版）","slug":"图及其操作（C语言版）","date":"2018-11-09T08:49:37.000Z","updated":"2019-07-12T02:10:01.627Z","comments":true,"path":"2018/11/09/图及其操作（C语言版）/","link":"","permalink":"http://yoursite.com/2018/11/09/图及其操作（C语言版）/","excerpt":"","text":"图及其操作（C语言版）图的定义和性质： 定义: 图是由顶点的有穷非空集合和顶点之间边的集合组成，通常表示为：G(V,R)，其中，G表示一个图，V是图G中顶点的集合，R是图G中边的集合。 顶点： 在图中的数据元素通常叫做顶点。 弧头/弧尾： 若$\\in VR$则$$表示从$v$到 $w$的一条弧，且称$v$为弧尾或初始点，称$w$为弧头或终端点。 有向图： 若图中的边是有向的，即$\\in VR \\neq \\in VR$此时的图称为有向图。 无向图： 若$\\in VR$ 必有 $\\in VR$,即$VR$是对称的，则以无序对$(v,w)$代替两个有序对，表示v,w之间的一条边，此时的图称为无向图。 完全图： 若用n表示图中的顶点数，用e表示图中弧或者边的数目，在下边的讨论中，我们不考虑顶点到其自身的边或者弧。 对于无向图来说：$0\\le e \\le \\frac{1}{2}n(n-1) $,有$\\frac{1}{2}n(n-1)$条边的无向图称为完全图 对于有向图来说：$0\\le e \\le n(n-1) $,有$ n(n-1)$条弧的有向图称为有向安完全图。 稀疏图/稠密图： 有很多条边或者弧的图称为稠密图，反之称为稀疏图$例如：(e\\lt n\\log{n})$ 权： 有时边或者弧有和他相关的数，这种与图的边或者弧相关的数叫做权。这些权可以表示一个顶点到另一个顶点的距离或者消耗。 网： 带权的图称为网。 子图： 假设有两个图$G=\\{V,\\{R\\} \\}$和$G^=\\{ V^,\\{R^\\}\\}$，如果$V^ \\subseteq V $且$R^\\subseteq R $,则称$G^$为$G$的子图 邻接点： 对于无向图：$G=\\{V,\\{R\\} \\}$,如果边$(v,v^) \\in R$,则称顶点$v$ 和互为邻接点$v^$，边$(v,v^) $依附于顶点$v$和$v^$。或者说边$(v,v^) $和顶点$v$和$v^$相关联。 对于有向图：$G=\\{V,\\{A\\} \\}$,如果弧$ \\in A$,则称顶点$v$邻接到顶点$v^$，顶点$v^$邻接到顶点$v$,弧$$和顶点$v$，$v^`$相关联。 无向图顶点的度： 在无向图中，顶点v的度是和顶点v相关联的边的数目，记做$TD(v)$ 有向图顶点的度： 入度：在有向图中，顶点v的入度是指以顶点v为头的弧的数目 出度：在有向图中，顶点v的出度是指以顶点v为尾的弧的数目 顶点，边(弧)，度之间的关系： 一般的，如果顶点$v_i$的度记为$TD(v_i)$，那么一个有$n$个顶点，$e$条边或者弧的图，满足如下关系：e=\\frac{1}{2} \\sum_{i=1}^nTD(v_i) 图的路径：无向图$G=\\{V,\\{E \\} \\}$中从顶点$V$到顶点$V^$的路径是一个顶点序列$(v=v_{i,0},v_{i,1},...,v_{i,m}=v^)$其中$(v_{i,j-1},v_{i,j}) \\in E,1 \\le j \\le m$。如果G是有向图，则路径也是有向的。 路径的长度：路径上边或者弧的数目 回路/环第一个顶点和最后一个顶点相同的路径称为回路或者环。除了第一个和最后一个顶点之外，其余顶点不重复出现的回路，称为简单回路或者简单环。 连通图：在无向图G中，如果从顶点$v$到顶点$v^$有路径，则称$v$和$v^$是连通的。若对于图中任意两个顶点$v_i$、$v_j\\in V$，$v_i$和$v_j$都连通，则称G是连通图。 连通分量：无向图中的极大连通子图称为是该图的连通分量。 强连通图：在有向图G中，如果对于每一对$v_i,v_j \\in V ,v_i \\neq v_j$ ,从对$v_i到v_j$和从$v_j到v_i$都存在路径，则称G是强连通图。 强连通分量：有向图中的极大连通子图称作有向图的强连通分量。 连通图的生成树：一个连通图的生成树是一个极小连通子图，他含有图中的全部顶点，但是只含有构成一颗树的$n-1$条边。 性质： 一颗有n个顶点的生成树有且只有n-1条边 如果一个图有n个顶点和小于n-1条边，则是非连通图。若多于n-1条边，则一定有环。 如果一个有向图恰有一个顶点的入度为0，其余顶点的入度均为1，则是一颗有向树。 图的存储结构： 数组表示法： 用两个数组分别存储数据元素(顶点)的信息和数据之间的关系(边或弧)的信息。 123456789101112131415161718/**数组表示法（邻接矩阵）**/#define INFINITY INT_MAX//整数类型最大值#define MAX_VERTEX_NUM 20//最大顶点个数typedef enum&#123; DG,DN,uDG,UDN&#125; GraphKind;//&#123;有向图，有向网，无向图，无向网&#125;typedef struct ArcCell&#123; VRType adj;//弧或者边的类型：对于无权图，用0或者1表示是否相邻 //对带权图，则为权值类型 InfoType *inform;//改弧相关的信息指针&#125;ArcCell, AdjMatrix[MAX_VERTEX_NUM][MAX_VERTEX_NUM];typedef struct &#123; VertexType vexs[MAX_VERTEX_NUM];//顶点向量 AdjMatrix arcs;//邻接矩阵 int vexNum,arcNum;//图的当前顶点数量，边或者弧数量 GraphKind kind;//图类型&#125;MGraph; 邻接表：邻接表是图的一种链式存储结构。在邻接表中，对图中的每个顶点建立一个单链表，第$i$个单链表中的结点表示依附于顶点$v_i$的边（对有向图是以顶点$v_i$为尾的弧）。每个结点由3个域组成，其中邻接点域（adjvex）指示指示与顶点$v_i$邻接的点在图中的位置，链域（nextarc）指示下一条边或者弧的结点，数据域（info）存储和边或者弧相关的信息(如权值等)。在表头结点中除了设有链域（firstarc），指向链表中的第一个结点外，还设有存储顶点$v_i$的名或者其他有关信息的数据域（data）。","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://yoursite.com/categories/数据结构与算法/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/tags/数据结构/"},{"name":"图","slug":"图","permalink":"http://yoursite.com/tags/图/"}],"keywords":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://yoursite.com/categories/数据结构与算法/"}]},{"title":"树及其操作（C语言版）","slug":"树及其操作（C语言版）","date":"2018-11-09T08:49:37.000Z","updated":"2019-07-12T02:10:01.627Z","comments":true,"path":"2018/11/09/树及其操作（C语言版）/","link":"","permalink":"http://yoursite.com/2018/11/09/树及其操作（C语言版）/","excerpt":"","text":"树及其操作（C语言版）树定义和性质： 树的定义： 树是n个（n&gt;=0）有限节点组成一个具有层次关系的集合。 根及子树： 在任意一个非空树中，有且仅有一个特定的称为根的结点，当n&gt;1时，其余结点又可以分为m（m&gt;0）个互不相交的有限集$ T_1,T_2,…T_m$,其中每一个集合本身又是一颗树，并称为根的子树。 基本操作： InitTree(&amp;T):构造一颗空树 DestroyTree(&amp;T):销毁一颗树 ClearTree(&amp;T):清空一颗树 TreeDepth(&amp;T):求一颗树的深度 TraverseTree(&amp;T,Visit()):遍历树 结点： 树中包含一个数据元素和若干指向其子树的分支的集合叫做树的结点 度： 结点拥有的子树称为结点的度 叶子(终端结点)： 度为0的结点称为终端结点或者是叶子 分支结点(非终端结点)： 度不为0的结点称为分支结点或者是非终端结点。 孩子/双亲/兄弟： 结点的子树称为该结点的孩子，相应的，该结点称为孩子的双亲，同一个双亲的孩子互称兄弟。 祖先/子孙 结点的祖先是从根到该节点所经过的分支上的所有结点，反之，以某结点为根的子树中的任意结点都是该节点的子孙。 结点的层次： 结点的层次从根开始算起，根为第一层，根的孩子为第二层….. 树的深度： 树中结点的最大层次称为树的深度或者是高度 有序树/无序树： 如果树中结点的各子树看成从左到右是有次序的（不能互换），则树称为有序树，否则称为无序树。 森林： m（m&gt;=0）颗互不相交的树的集合 二叉树： 定义： 树中每个结点最多只有两颗子树（即结点的度不大于2），而且子树有左右之分（子树次序不能任意颠倒）的树称为二叉树。 满二叉树： 一颗深度为$k$且有$2^k-1$个结点的树称为满二叉树 完全二叉树： 深度为$k$，有n个结点的二叉树，当且仅当其每一个结点都与深度为$k$的满二叉树中编号从1至n的结点一一对应时，称之为完全二叉树。 二叉树性质： 在二叉树的第$i$层上最多有$2^(i-1)$个结点（i&gt;=1） 深度为$k$的二叉树最多有$2^k-1$个结点（k&gt;=1） 对任何一个二叉树T，如果其终端结点数为$n_0$,度为2的结点数为$n_2$,则$n_0 = n_2+1$ 完全二叉树的性质 具有n个结点的完全二叉树的深度为$\\lfloor log_(2^n) \\rfloor+1$ 线索二叉树： 定义：若做如下规定：若结点有左子树，则其lchild域指示其左孩子，否则令其指向其前驱，同样的，若结点有右子树，则其rchild域指向其右孩子，否则令其指向其后继。为了区分，我们增设一个tag字段。 LTag = \\begin{cases} 0 & \\text{lchild域指示结点的左孩子} \\\\ 1 & \\text{lchild域指示结点的前驱} \\end{cases}RTag = \\begin{cases} 0 & \\text{lchild域指示结点的右孩子} \\\\ 1 & \\text{lchild域指示结点的后继} \\end{cases}以这种结点结构构成的二叉链表表示的二叉树叫做线索二叉树，其中指向前驱和后继的指针叫做线索。 线索化：以某种遍历顺序使二叉树称为线索二叉树的过程叫做二叉树的线索化 树的存储结构： 双亲表示法： 以一组连续的空间存储树的结点，同时在每一个结点中附设一个指示器指示其双亲结点在链表中的位置 12345678910#define MAX_TREE_SIZE 100typedef struct PTNode&#123;//结点结构 TElemTye data;//数据元素类型 int parent;//双亲结点域&#125;PTNode;typedef struct &#123;//树结构 PTNode nodes[MAX_TREE_SIZE];//存储的结点 int r,n;//根的位置和节点数&#125;PTNode; 孩子表示法： 把每个结点的孩子结点排列起来，看成一个线性表，并且以单链表做存储结构，则n个结点有n个孩子链表（叶节点的孩子链表为空表），而n个头结点又组成一个线性表。 1234567891011121314#define MAX_TREE_SIZE 100typedef struct CTNode&#123;//孩子结点 int child;//孩子数 struct CTNode* next;//下一个孩子结点指针&#125;* ChildPtr;typedef struct&#123; TElemType data;//数据域 ChildPtr firstChild;//孩子链表头指针&#125;CTBox;typedef struct&#123; CTBox nodes[MAX_TREE_SIZE];//存储的结点 int n,r;//结点和根的位置 孩子兄弟表示法： 又称二叉树表示法，或者二叉链表表示法。链表中结点的两个链域分别指向该节点的第一个孩子结点和下一个兄弟结点 1234typedef struct CSNode&#123; TElemType data; struct CSNode *firstChild, *nextSibling;&#125;CSNode , *CSTree; 树的实现：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;/** *定义的树节点 */typedef struct BiTNode&#123; char data; struct BiTNode *Lchild,*Rchild;&#125;BiTNode, *BiTree;/**递归方式，先序遍历建立二叉树**/bool createBiTree(BiTree *T)&#123; char ch; //读取字符 scanf(\"%c\",&amp;ch); if(ch == ' ')&#123; *T = NULL; &#125;else&#123; //申请新的结点空间 if(!(*T = (BiTNode *)malloc(sizeof(BiTNode))))&#123; exit(0); &#125; (*T)-&gt;data = ch; createBiTree(&amp;((*T)-&gt;Lchild)); createBiTree(&amp;((*T)-&gt;Rchild)); &#125; return true;&#125;/*先序遍历*/bool preOrderTraverse(BiTree T,bool (*printElem)(char elem))&#123; //检验是否为空 if(T)&#123; if(printElem(T-&gt;data))&#123;//打印根元素的值 if(preOrderTraverse(T-&gt;Lchild,printElem))&#123;//打印左子树 if(preOrderTraverse(T-&gt;Rchild,printElem))&#123;//打印右子树 return true; &#125; &#125; &#125; return false; &#125;else&#123; return true; &#125;&#125;/** * 打印函数 */bool printElem(char elem)&#123; printf(\"%c\\n\",elem); return true;&#125;int main()&#123; BiTree tree; bool res; res = createBiTree(&amp;tree); if(res)&#123; printf(\"建立成功\\n\"); &#125;else&#123; printf(\"建立失败\\n\"); &#125; //先序遍历打印树 preOrderTraverse(tree,printElem); return 0;&#125;","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://yoursite.com/categories/数据结构与算法/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/tags/数据结构/"},{"name":"树","slug":"树","permalink":"http://yoursite.com/tags/树/"}],"keywords":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://yoursite.com/categories/数据结构与算法/"}]},{"title":"渗透测试---信息搜集初识","slug":"渗透测试---信息搜集初识","date":"2018-11-09T08:49:37.000Z","updated":"2019-07-12T02:10:01.627Z","comments":true,"path":"2018/11/09/渗透测试---信息搜集初识/","link":"","permalink":"http://yoursite.com/2018/11/09/渗透测试---信息搜集初识/","excerpt":"","text":"渗透测试—-信息搜集初识一. 外围信息搜集方式 使用whois 进行域名注册信息查询 1whois [域名] 注：使用whois查询时需要去掉www，ftp等前缀 使用nslookup与dig查询域名注册信息 1231. nslookup2. set type=A //（参数A表示查询IP地址，MX表示邮件转发） set [域名] 11. dig @[DNS服务器][待查询域名] 注：nslookup和dig的区别在于：nslookup得到的是DNS解析服务器保存在Cache中的非权威解答，而dig则是可以指定DNS解析服务器向官方权威DNS服务器进行查询 使用IP2Location进行地理位置查询，网站信息查询，反查域名等 一些网站提供IP地址到地理位置的查询服务，网站的信息查询等服务，可以进行信息的搜集。对于一些虚拟主机，可以通过域名反查来获取信息。 使用搜索引擎进行信息搜集 使用Google Hacking技术，以及一些自动化工具来进行查询，如SiteDigger和Search Diggity 通过在Google中输入parent directory site：[域名]来查询网站的目录 通过在Google中输入site：[域名] filetype：[文件类型名]来查询特定的文件 通过使用Metasploit中的辅助模块search_email_collector来进行邮件地址搜集 通过在Google中输入site:[域名] inurl:[关键字]来查询易存在SQL注入点的页面 二. 主机探测与端口扫描 ICMP Ping命令 1ping [域名或IP地址] Metasploit的主机发现模块 Metasploit中提供了一些辅助模块用于发现活跃的主机，位于Metasploit的modules/auxiliary/scanner/discovery/目录下。其中arp_sweep与udp_sweep两个模块最常用 使用Nmap进行主机探测及系统识别 12nmap [扫描选项][扫描目标地址] //可以扫描单个地址或者是一个地址段nmap -o [目标IP地址] -A //-o参数可以识别目标地址的系统类型，-A可以得到更加详细信息 端口扫描与服务类型探测 Metasploit中的端口扫描器，Metasploit中的auxiliary/scanner/portscan/中提供了多种端口扫描器 123451. ack: 通过ack扫描的方式对防火墙上未被屏蔽的端口进行探测2. ftpbounce： 通过ftp bounce攻击的原理对TCP服务进行枚举3. syn： 使用发送TCP SYN标志的方式探测开放端口4. tcp： 通过一次完整的TCP链接过程来探测端口是否开放，准确度最高，但速 度很慢5. xmans： 一种更为隐秘的扫描方式，通过发送FIN，PSH和URG标志，能够躲 避一些TCP标记检测器的过滤 ​ nmap端口扫描： 1234567891011121314nmap [扫描参数] [扫描选项] [扫描地址]1）常见扫描参数： 1. -sT:Tcp connect 扫描，类似于Metasploit中的tcp扫描模块 2. -sS:TCP SYN扫描，类似于Metasploit中的syn扫描模块 3. -sF/-sX/-sN:通过发送一些特殊的标记位来避开一些设备或者软件的监测 4. -sP：通过发送ICMP echo请求探测主机是否存活，原理同ping 5. -sU：探测目标主机开放了哪些UDP端口 6. -sA：TCP ACK扫描，类似于Metasploit中的ack扫描模块 7. -sV：获取更加详细的服务版本等信息2）常见扫描选项： -Pn：在扫描之前不发送ICMP echo测试目标是否活跃 -O：启用对于TCP/IP协议栈的指纹特征扫描以获得远程主机的操作系统类型等信息 -F：快速扫描模式，只扫描在nmap-services中列出的端口 -p[端口范围]：可以使用这个参数指定希望扫描的端口 三. 服务扫描与查点 Telnet服务扫描 Metasploit中提供了Telnet服务扫描的模块，该模块位于auxiliary/scanner/telnet/telnet_version，可以通过该模块探查目标主机的telnet版本 SHH服务扫描 Metasploit同样提供了对于SSH服务的扫描木块，该模块位于auxiliary/scanner/ssh/ssh_version。 Oracle数据库查点 Metasploit提供对于Oracle数据库的扫描，该模块位于auxiliary/scanner/oracle/tnslsnr_version。 开放代理与利用 Metasploit提供用于隐藏自己地址的代理服务，该模块位于auxiliary/scanner/http/open_proxy，可以使用该模块设置自己的代理服务 口令猜测和嗅探 SSH口令猜测：Metasploit提供了用于猜测SSH口令的模块，通过设置高质量的密码字典可以有效的破解弱口令密码，该模块位于auxiliary/scanner/ssh/ssh_login psnuffle口令嗅探：Metasploit提供了一个用于口令嗅探的工具，可以截获常见协议的身份认证过程，并记录用户名和口令，该模块位于auxiliary/sniffer/psnuffle 三. 网络漏洞扫描1. 使用Nessus Nessus提供完整的电脑端漏洞扫描服务，并会及时更新漏洞数据库。同时不同于传统的漏洞扫描工具，Nessus提供同时在本机和远程端上得控制，在命令行的基础上也提供图形化操作界面。 1234561. 启动Nessus nessusd start2. 激活Nessus nessus -fetch --register [激活码]3. 添加用户 nessus -add user 2. 使用OpenVAS OpenVAS常用来评估目标主机上得漏洞，是Nessus项目的一个分支，提供完全免费的服务。 1234567891011121314151617181. 配置OpenVAS openvas-mkcert2. 同步OpenVAS NVT数据库 openvas-nvt-sync3. 创建客户端证书库 openvas-mkcert-client -n [用户名] -i4. 重建数据库 openvasmd -rebuild5. 启动openvas并加载插件 openvassd6. 创建数据库备份 openvasmd -backup7. 创建管理账户 openvasad -c 'add_user' -n [账户名] -r Admin8. 创建普通账户 openvasad -adduser9. 为openvas配置端口 openvasmd -p [端口号] -a [IP地址]","categories":[{"name":"大数据与网络安全","slug":"大数据与网络安全","permalink":"http://yoursite.com/categories/大数据与网络安全/"}],"tags":[{"name":"渗透测试","slug":"渗透测试","permalink":"http://yoursite.com/tags/渗透测试/"},{"name":"信息收集","slug":"信息收集","permalink":"http://yoursite.com/tags/信息收集/"}],"keywords":[{"name":"大数据与网络安全","slug":"大数据与网络安全","permalink":"http://yoursite.com/categories/大数据与网络安全/"}]},{"title":"渗透测试--密码攻击初识","slug":"渗透测试--密码攻击初识","date":"2018-11-09T08:49:37.000Z","updated":"2019-07-12T02:10:01.627Z","comments":true,"path":"2018/11/09/渗透测试--密码攻击初识/","link":"","permalink":"http://yoursite.com/2018/11/09/渗透测试--密码攻击初识/","excerpt":"","text":"渗透测试—密码攻击初识一. 密码在线攻击1. Hydra工具 Hydra支持几乎所有协议的在线破解密码，同时也提供命令行和GUI界面两种操作方式通过Hydra-gtk来启动图形化界面。 2. Medusa工具 Medusa通过并行登录暴力破解的方式来尝试获取远程验证服务访问权限。可以通过medusa命令直接启动工具 二. 分析密码1. Ettercap工具 Ettercap是一个强大的欺骗工具，使用该工具可以快速的构建伪造的各类型数据包，实现从网络适配器到应用软件的各种级别的包，并绑定监听数据到本地端口等。通过对目标系统的信息收集，可以构建可能的密码字典。 1234561. 配置Ettercap的配置文件etter.conf 1. 查找配置文件： locate etter.conf 2. 修改配置文件： vim /etc/ettercap/etter.conf 3. 将ec_uid 和 ec_gid配置项的值改为0;将Linux部分附近的IPTABLES行的注释去掉2. 启动Ettercap ettercap -G #-G参数可以启动图形化界面 2. 使用Metasploit中的模块 Metasploit框架中的search_email_collector可以搜集一个组织相关的各种邮件，通过邮件信息可以构建一个密码字典，该模块位于auxiliary/gather/search_email_collector。 3. Hash值识别工具Hash Identity 1231. 启动Hash Identity hash identifier2. 输入Hash值，可以查出最可能的Hash加密算法 4. findmyhash用于破解LM Hash 1234findmyhash [Encryption] -h hash注： [Encryption] 指定使用的Hash加密算法 -h 指定要破解的LM Hash值 三. 创建密码字典1. Crunch工具 Crunch工具是一种密码创建工具，其生成的密码可以发送到终端，文件或另一程序。 1234567891011crunch [minimun length] [maximum length] [character set][options]注: [minimun length] 密码最小长度 [maximum length] 密码最大长度 [character set] 密码使用的字符集 [options] 可以选用的参数： -o：用于指定输出字典文件的位置 -b：指定写入文件的最大字节数，必须和-o选项一起使用 -t：设置使用的特殊格式 -l：该选项在-t选项指定@，%或^字符时，用来识别一些占位符 2. rtgen工具 rtgen工具用于生成彩虹表，可以针对各种算法。 1rtgen [加密算法] [彩虹表]","categories":[{"name":"大数据与网络安全","slug":"大数据与网络安全","permalink":"http://yoursite.com/categories/大数据与网络安全/"}],"tags":[{"name":"渗透测试","slug":"渗透测试","permalink":"http://yoursite.com/tags/渗透测试/"},{"name":"密码攻击","slug":"密码攻击","permalink":"http://yoursite.com/tags/密码攻击/"}],"keywords":[{"name":"大数据与网络安全","slug":"大数据与网络安全","permalink":"http://yoursite.com/categories/大数据与网络安全/"}]},{"title":"计算机网络基础汇总","slug":"计算机网络基础汇总","date":"2018-11-09T08:49:37.000Z","updated":"2019-07-12T02:10:01.627Z","comments":true,"path":"2018/11/09/计算机网络基础汇总/","link":"","permalink":"http://yoursite.com/2018/11/09/计算机网络基础汇总/","excerpt":"","text":"计算机网络体系分类：计算机网络整个体系有两个大的分类：一个是国际组织制定的OSI七层模型，一种是实际使用中的TCP/IP四层模型。 OSI七层模型 TCP/IP四层模型 应用层 表示层 应用层 会话层 传输层 传输层 网络层 网络层 数据链路层 物理接入层 物理层 物理层：物理层主要是实现主机和网络之间的物理连接，规定一些与传输媒体接口有关的一些特性。 通信方式： 单工通信： 只能由A主机向B主机发送消息，通信是单向的。 半双工通信：同一时间只能是由A主机向B主机或者是B主机向A主机发送信息，不能同时发送消息。 全双工通信： A主机和B主机可以实现在同一时间内既接收消息，又发送消息，极大的提升了通信效率。 常见引导型传输媒体：双绞线：分为屏蔽双绞线（STP）和非屏蔽双绞线（UTP），屏蔽双绞线就是在非屏蔽双绞线外边又加了一层屏蔽层 tips：为什么双绞线要两根线绞起来，两个线绞起来可以有效的减少相互之间的电磁干扰。 同轴电缆：由内导体铜制芯线，绝缘层，网状编织的外导体屏蔽层，以及塑料保护外层组成。有良好的抗干扰性，被广泛用于较高速率的传输。 光缆：由非常透明的石英玻璃拉成细丝，主要由纤芯和包层构成双层通讯柱。可以分为单模光纤和多模光纤。 信道复用技术： 频分复用：根据传输的波的频率的不同，将不同频段的波用于不同的通信。 时分复用：将时间分割为时间段，规定在某个时间段内发送什么样的信息，根据时间段来进行信息类别的区分。也称为同步时分复用 统计时分复用：基于时分复用的一种改进，由于基本的时分复用并没有考虑到每个时间段内是否有信息发出，例如说每个时间段是20，但是发送消息只占用其中的2，那么剩下的18就处于空闲时间。统计时分复用就是基于这种考虑而设计的，他允许用户有数据时就将数据发送到缓存中，然后会依次扫描输入缓存，把缓存中的数据放入到STMD帧中，若没有就跳过，每当一个帧满了就把这个帧发出去。STMD帧不是分配的固定时序，而是根据需要动态的分配时隙，也称之为异步时分复用 光分复用：就是光的频分复用，根据光谱中频率的不同，用不同频率的光来携带不同的信息。 数据链路层：数据链路层主要是将上层的数据转化为数据帧发送到链路上，以及把接受到的帧中的数据取出并交给网络层。 通信方式： 点对点通信：通信方式是点到点的，也就是只能是两个点之间的通信。常见的就是PPP协议 广播通信：广播通讯，也就是可以同时实现一对多的通信。常见的就是CSMA/CD（载波监听多点访问/冲突检测） 核心要解决的问题： 封装成帧：在一段数据的前后分别添加首部和尾部，这样就构成了一个帧。接收端在接受到后就可以方便准确的确定帧的首尾，也称为帧定界符。同时定义出了最大传输单元（MTU）—表示一次可以传输的最大长度上限。 透明传输： 由于使用特定的字符来表示帧的开始和结束，所以传输的内容中不能出现和帧定界符相同的字符，但这显然是不可能的，为了解决这个办法，就可以在内容中和帧定界符一样的字符前边加上规定好的转义字符，这种方法称为字符填充或者是字节填充。 差错检测： 比特在传输过程中可能产生差错，差错检测就是用于检测出现的差错，以便及时的重传，最常用的差错检测算法就是CRC（循环冗余检验） 网络层网络层主要是向上只提供简单灵活的，无连接的，尽最大努力交付的数据报服务。 IP协议（网际协议）：IP协议是TCP/IP体系中最主要的协议之一，一切在IP之下，一切又在IP之上。我们常说的应该是IP协议族，还包含配套的协议： ARP（地址解析协议）：将网络的IP地址转化为实际的物理地址（MAC地址），并存储在MAC地址表中。 ICMP（网际控制报文协议）：用于进行差错情况和异常情况的反馈，分为询问报文和差错报告报文。 IGMP（网际组管理协议）：用于控制和管理多播和组播的协议。 网络地址（IP地址）主要分为五类： A类：前8位为网络位，后24位为主机位，首位为0 B类：前16位为网络位，后16位为主机位，前两位为10 C类：前24位为网络位，后8位位主机位，前三位为110 D类：前四位为1110，用于多播地址 E类：前四位为1111，保留为以后使用 路由选择协议：路由选择协议分为内部网关协议（IGP）和外部网关协议（EGP） 内部网关协议：主要是有RIP协议和OSPF协议 RIP协议（路由信息协议）：基于距离矢量的协议 OSPF（开放最短路径优先协议）：基于链路状态的协议 外部网关协议：主要是边界网关协议（BGP），将一个大的网络分为多个小的自治域，每个自治域内有一个网关路由负责和其他的自治域的网关进行通讯。 传输层网络层主要是为主机之间提供逻辑通讯，而传输层为应用程序之间提供端到端的逻辑通讯。主要是两种类型的通讯方式，面向连接的TCP协议和面向无连接的UDP。 端口号：端口号按照使用地方的不同分为两大类：服务端端口号，客户端端口号。按照占用时长又可以分为熟知端口号（0~1023），登记端口号（1024~49151），短暂端口号（49152~65535） 常见端口： FTP（文件传输协议）：20，21———其中20端口用于传输数据，21端口用于命令控制 Telnet（远程登录协议）：23 DNS（域名解析服务）：53 TFTP（简单文件传输协议）：69 HTTP（超文本传输协议）：80 两种协议： UDP（用户数据报协议）： UDP是无连接的 UDP使用尽最大努力交付，但是不保证可靠交付 UDP是面向报文的 UDP没有拥塞控制 UDP支持一对一，一对多，多对一，多对一的交互通讯 UDP首部的开销小 TCP（传输控制协议）： TCP是面向连接的 每一条TCP连接只能由两个端点，每一条TCP连接只能是点对点的$TCP连接：：= \\{ socket_1,socket_2 \\} =\\{ (IP_1:port_1),(IP_2:port_2)\\}$ TCP提供可靠交付的服务 TCP提供全双工通信 面向字节流 可靠传输的实现机制：停止等待协议：每发完一个分组就停止发送，直到收到上一个分组的确认信息。若超过规定时间没有接收到确认信息，边认为是分组丢失，开始重传。 连续ARQ协议：发送方采用滑动窗口的形式，处于滑动窗口的分组可以直接发送出去；接收方一般采用累积确认的方式，也就是说接受方不必对接收到的每一个分组都进行确认，而是对按序到达的最后一个分组进行确认，而发送方每接收到一个确认，窗口就向前滑动一定距离。 流量控制：协调发送方和接收方的收发速率，利用滑动窗口来协调，使用探测报文来探测当前应该发送的速率，采用Nagle算法 拥塞控制：当网络中某一资源的需求超出了该资源所能提供的可用部分，这时网络的性能就要开始变坏，这种情况就叫做拥塞。而拥塞控制就是为了减少或者避免拥塞对网络性能的影响而做出的一种控制手段。 拥塞控制思路： 发送方维持一个叫做拥塞窗口的状态变量，拥塞窗口的大小取决于网络的拥塞程度，并且在动态的变化。发送方让自己的发送窗口等于拥塞窗口，如果在考虑接收方的接收能力，一般发送窗口还要小于拥塞窗口。 慢开始： 当主机开始发送数据的时候，由小到大的增大发送窗口，也就是由小到大的增大拥塞窗口。接收方接收到一个报文之后就回传一个确认报文，发送方每接收到一个确认报文，就将拥塞窗口加1，这样每经过一个传输轮次之后，拥塞窗口就增大一倍。 拥塞避免： 思路是让拥塞窗口缓慢的增大，即每经过一个往返时间RTT就把发送方的拥塞窗口加1，而不是加倍，这样拥塞窗口就是线性缓慢增加，比慢开始的增长速率缓慢的多。 慢开始门限： 为了防止拥塞窗口增长过大引起网络拥塞，还需要设置一个慢开始门限 拥塞窗口&lt;慢开始门限时，使用慢开始算法 拥塞窗口&gt;慢开始门限时，使用拥塞避免算法 拥塞窗口=慢开始门限时，两种算法都可以 快重传： 要求收到方每收到一个时序的报文段之后就立即发出重复确认，而不要等到自己发送数据时才进行捎带确认。而发送方只要一连收到三个重复确认就应当立即重传对方尚未接受到的报文，而不必等待为报文设置的重传计时器到期。 快回复： 与快重传配合使用，当发送方连续收到三个重复确认的时候，就执行“乘法减小”算法，将慢开始门限减半。将拥塞窗口设置为慢开始门限减半之后的值，并开始指向拥塞避免算法。 TCP的连接管理：连接三次握手： 客户端请求建立连接：SYN=1，seq=x； 服务器对客户端的请求进行响应：SYN=1，ACK=1，seq=y，ack=x+1 客户端对服务器端的响应信息进行回应：ACK=1，seq=x+1，ack=y+1 注： SYN为同步信息，在建立连接过程中始终为1 断开连接四次握手： 客户端请求断开连接： FIN=1，seq = u； 服务端对客户端的请求应答：ACK=1，seq=v，ack=u+1； 服务端请求断开连接：FIN=1，ACK=1，seq=w，ack=u+1； 客户端对服务端的请求应答：ACK=1，seq=u+1，ack=w+1； 应用层应用层有多种协议，常用到的就是HTTP以及HTTPS。HTTP协议报文格式 请求报文 相应报文 请求行（用于区分是请求报文还是响应报文，在响应报文中为状态行） 状态行 首部行（用来说明浏览器，服务器或者是报文主体的一些信息） 首部行 空行（用于隔开请求实体和首部行） 空行 实体主体（用于一些请求或者是响应的的参数内容等） 实体主体 常见状态码 1xx：表示通知信息，例如表示收到或者是正在处理2xx：表示成功，例如表示接受或知道了3xx：表示重定向，例如表示完成请求还需要采取进一步的行动4xx：表示客户端的差错，例如表示请求中有语法错误或不能完成5xx：表示服务器端的差错：例如表示服务器失效无法完成请求 HTTPS协议就是对HTTP协议的加密，更加安全可靠，采用HTTP+SSL（安全套接字层）来保证数据的安全性。","categories":[{"name":"大数据与网络安全","slug":"大数据与网络安全","permalink":"http://yoursite.com/categories/大数据与网络安全/"}],"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"http://yoursite.com/tags/计算机网络/"},{"name":"网络协议","slug":"网络协议","permalink":"http://yoursite.com/tags/网络协议/"}],"keywords":[{"name":"大数据与网络安全","slug":"大数据与网络安全","permalink":"http://yoursite.com/categories/大数据与网络安全/"}]},{"title":"面试中的十大排序算法总结","slug":"面试中的 10 大排序算法总结","date":"2018-11-09T08:49:37.000Z","updated":"2019-07-12T02:10:01.627Z","comments":true,"path":"2018/11/09/面试中的 10 大排序算法总结/","link":"","permalink":"http://yoursite.com/2018/11/09/面试中的 10 大排序算法总结/","excerpt":"","text":"本文转载自码农网：http://www.codeceo.com/article/10-sort-algorithm-interview.html#0-tsina-1-10490-397232819ff9a47a7b7e80a40613cfe1 查找和排序算法是算法的入门知识，其经典思想可以用于很多算法当中。因为其实现代码较短，应用较常见。所以在面试中经常会问到排序算法及其相关的问题。但万变不离其宗，只要熟悉了思想，灵活运用也不是难事。一般在面试中最常考的是快速排序和归并排序，并且经常有面试官要求现场写出这两种排序的代码。对这两种排序的代码一定要信手拈来才行。还有插入排序、冒泡排序、堆排序、基数排序、桶排序等。面试官对于这些排序可能会要求比较各自的优劣、各种算法的思想及其使用场景。还有要会分析算法的时间和空间复杂度。通常查找和排序算法的考察是面试的开始，如果这些问题回答不好，估计面试官都没有继续面试下去的兴趣都没了。所以想开个好头就要把常见的排序算法思想及其特点要熟练掌握，有必要时要熟练写出代码。 接下来我们就分析一下常见的排序算法及其使用场景。限于篇幅，某些算法的详细演示和图示请自行寻找详细的参考。 冒泡排序 冒泡排序是最简单的排序之一了，其大体思想就是通过与相邻元素的比较和交换来把小的数交换到最前面。这个过程类似于水泡向上升一样，因此而得名。举个栗子，对5,3,8,6,4这个无序序列进行冒泡排序。首先从后向前冒泡，4和6比较，把4交换到前面，序列变成5,3,8,4,6。同理4和8交换，变成5,3,4,8,6,3和4无需交换。5和3交换，变成3,5,4,8,6,3.这样一次冒泡就完了，把最小的数3排到最前面了。对剩下的序列依次冒泡就会得到一个有序序列。冒泡排序的时间复杂度为O(n^2)。 实现代码： /* @Description:&lt;p&gt;冒泡排序算法实现&lt;/p&gt; @author 王旭 @time 2016-3-3 下午8:54:27 */public class BubbleSort { public static void bubbleSort(int[] arr) { if(arr == null || arr.length == 0) return ; for(int i=0; i&amp;lt;arr.length-1; i++) { for(int j=arr.length-1; j&amp;gt;i; j--) { if(arr[j] &amp;lt; arr[j-1]) { swap(arr, j-1, j); } } } } public static void swap(int[] arr, int i, int j) { int temp = arr[i]; arr[i] = arr[j]; arr[j] = temp; } }&lt;/pre&gt;&lt;/div&gt; 选择排序 选择排序的思想其实和冒泡排序有点类似，都是在一次排序后把最小的元素放到最前面。但是过程不同，冒泡排序是通过相邻的比较和交换。而选择排序是通过对整体的选择。举个栗子，对5,3,8,6,4这个无序序列进行简单选择排序，首先要选择5以外的最小数来和5交换，也就是选择3和5交换，一次排序后就变成了3,5,8,6,4.对剩下的序列一次进行选择和交换，最终就会得到一个有序序列。其实选择排序可以看成冒泡排序的优化，因为其目的相同，只是选择排序只有在确定了最小数的前提下才进行交换，大大减少了交换的次数。选择排序的时间复杂度为O(n^2) 实现代码： /* @Description:&lt;p&gt;简单选择排序算法的实现&lt;/p&gt; @author 王旭 @time 2016-3-3 下午9:13:35 */public class SelectSort { public static void selectSort(int[] arr) { if(arr == null || arr.length == 0) return ; int minIndex = 0; for(int i=0; i&amp;lt;arr.length-1; i++) { //只需要比较n-1次 minIndex = i; for(int j=i+1; j&amp;lt;arr.length; j++) { //从i+1开始比较，因为minIndex默认为i了，i就没必要比了。 if(arr[j] &amp;lt; arr[minIndex]) { minIndex = j; } } if(minIndex != i) { //如果minIndex不为i，说明找到了更小的值，交换之。 swap(arr, i, minIndex); } } } public static void swap(int[] arr, int i, int j) { int temp = arr[i]; arr[i] = arr[j]; arr[j] = temp; } }&lt;/pre&gt;&lt;/div&gt; 插入排序 插入排序不是通过交换位置而是通过比较找到合适的位置插入元素来达到排序的目的的。相信大家都有过打扑克牌的经历，特别是牌数较大的。在分牌时可能要整理自己的牌，牌多的时候怎么整理呢？就是拿到一张牌，找到一个合适的位置插入。这个原理其实和插入排序是一样的。举个栗子，对5,3,8,6,4这个无序序列进行简单插入排序，首先假设第一个数的位置时正确的，想一下在拿到第一张牌的时候，没必要整理。然后3要插到5前面，把5后移一位，变成3,5,8,6,4.想一下整理牌的时候应该也是这样吧。然后8不用动，6插在8前面，8后移一位，4插在5前面，从5开始都向后移一位。注意在插入一个数的时候要保证这个数前面的数已经有序。简单插入排序的时间复杂度也是O(n^2)。 实现代码： /* @Description:&lt;p&gt;简单插入排序算法实现&lt;/p&gt; @author 王旭 @time 2016-3-3 下午9:38:55 */public class InsertSort { public static void insertSort(int[] arr) { if(arr == null || arr.length == 0) return ; for(int i=1; i&amp;lt;arr.length; i++) { //假设第一个数位置时正确的；要往后移，必须要假设第一个。 int j = i; int target = arr[i]; //待插入的 //后移 while(j &amp;gt; 0 &amp;amp;&amp;amp; target &amp;lt; arr[j-1]) { arr[j] = arr[j-1]; j --; } //插入 arr[j] = target; } } }&lt;/pre&gt;&lt;/div&gt; 快速排序 快速排序一听名字就觉得很高端，在实际应用当中快速排序确实也是表现最好的排序算法。冒泡排序虽然高端，但其实其思想是来自冒泡排序，冒泡排序是通过相邻元素的比较和交换把最小的冒泡到最顶端，而快速排序是比较和交换小数和大数，这样一来不仅把小数冒泡到上面同时也把大数沉到下面。 举个栗子：对5,3,8,6,4这个无序序列进行快速排序，思路是右指针找比基准数小的，左指针找比基准数大的，交换之。 5,3,8,6,4 用5作为比较的基准，最终会把5小的移动到5的左边，比5大的移动到5的右边。 5,3,8,6,4 首先设置i,j两个指针分别指向两端，j指针先扫描（思考一下为什么？）4比5小停止。然后i扫描，8比5大停止。交换i,j位置。 5,3,4,6,8 然后j指针再扫描，这时j扫描4时两指针相遇。停止。然后交换4和基准数。 4,3,5,6,8 一次划分后达到了左边比5小，右边比5大的目的。之后对左右子序列递归排序，最终得到有序序列。 上面留下来了一个问题为什么一定要j指针先动呢？首先这也不是绝对的，这取决于基准数的位置，因为在最后两个指针相遇的时候，要交换基准数到相遇的位置。一般选取第一个数作为基准数，那么就是在左边，所以最后相遇的数要和基准数交换，那么相遇的数一定要比基准数小。所以j指针先移动才能先找到比基准数小的数。 快速排序是不稳定的，其时间平均时间复杂度是O(nlgn)。 实现代码： /* @Description:&lt;p&gt;实现快速排序算法&lt;/p&gt; @author 王旭 @time 2016-3-3 下午5:07:29 */public class QuickSort { //一次划分 public static int partition(int[] arr, int left, int right) { int pivotKey = arr[left]; int pivotPointer = left; while(left &amp;lt; right) { while(left &amp;lt; right &amp;amp;&amp;amp; arr[right] &amp;gt;= pivotKey) right --; while(left &amp;lt; right &amp;amp;&amp;amp; arr[left] &amp;lt;= pivotKey) left ++; swap(arr, left, right); //把大的交换到右边，把小的交换到左边。 } swap(arr, pivotPointer, left); //最后把pivot交换到中间 return left; } public static void quickSort(int[] arr, int left, int right) { if(left &amp;gt;= right) return ; int pivotPos = partition(arr, left, right); quickSort(arr, left, pivotPos-1); quickSort(arr, pivotPos+1, right); } public static void sort(int[] arr) { if(arr == null || arr.length == 0) return ; quickSort(arr, 0, arr.length-1); } public static void swap(int[] arr, int left, int right) { int temp = arr[left]; arr[left] = arr[right]; arr[right] = temp; } }&lt;/pre&gt;&lt;/div&gt; 其实上面的代码还可以再优化，上面代码中基准数已经在pivotKey中保存了，所以不需要每次交换都设置一个temp变量，在交换左右指针的时候只需要先后覆盖就可以了。这样既能减少空间的使用还能降低赋值运算的次数。优化代码如下： /* @Description:&lt;p&gt;实现快速排序算法&lt;/p&gt; @author 王旭 @time 2016-3-3 下午5:07:29 */public class QuickSort { /** * 划分 * @param arr * @param left * @param right * @return */ public static int partition(int[] arr, int left, int right) { int pivotKey = arr[left]; while(left &amp;lt; right) { while(left &amp;lt; right &amp;amp;&amp;amp; arr[right] &amp;gt;= pivotKey) right --; arr[left] = arr[right]; //把小的移动到左边 while(left &amp;lt; right &amp;amp;&amp;amp; arr[left] &amp;lt;= pivotKey) left ++; arr[right] = arr[left]; //把大的移动到右边 } arr[left] = pivotKey; //最后把pivot赋值到中间 return left; } /** * 递归划分子序列 * @param arr * @param left * @param right */ public static void quickSort(int[] arr, int left, int right) { if(left &amp;gt;= right) return ; int pivotPos = partition(arr, left, right); quickSort(arr, left, pivotPos-1); quickSort(arr, pivotPos+1, right); } public static void sort(int[] arr) { if(arr == null || arr.length == 0) return ; quickSort(arr, 0, arr.length-1); } }&lt;/pre&gt;&lt;/div&gt; 总结快速排序的思想：冒泡+二分+递归分治，慢慢体会。。。 堆排序 堆排序是借助堆来实现的选择排序，思想同简单的选择排序，以下以大顶堆为例。注意：如果想升序排序就使用大顶堆，反之使用小顶堆。原因是堆顶元素需要交换到序列尾部。 首先，实现堆排序需要解决两个问题： 1. 如何由一个无序序列键成一个堆？ 2. 如何在输出堆顶元素之后，调整剩余元素成为一个新的堆？ 第一个问题，可以直接使用线性数组来表示一个堆，由初始的无序序列建成一个堆就需要自底向上从第一个非叶元素开始挨个调整成一个堆。 第二个问题，怎么调整成堆？首先是将堆顶元素和最后一个元素交换。然后比较当前堆顶元素的左右孩子节点，因为除了当前的堆顶元素，左右孩子堆均满足条件，这时需要选择当前堆顶元素与左右孩子节点的较大者（大顶堆）交换，直至叶子节点。我们称这个自堆顶自叶子的调整成为筛选。 从一个无序序列建堆的过程就是一个反复筛选的过程。若将此序列看成是一个完全二叉树，则最后一个非终端节点是n/2取底个元素，由此筛选即可。举个栗子： 49,38,65,97,76,13,27,49序列的堆排序建初始堆和调整的过程如下： 实现代码： /* @Description:&lt;p&gt;堆排序算法的实现，以大顶堆为例。&lt;/p&gt; @author 王旭 @time 2016-3-4 上午9:26:02 */public class HeapSort { /** * 堆筛选，除了start之外，start~end均满足大顶堆的定义。 * 调整之后start~end称为一个大顶堆。 * @param arr 待调整数组 * @param start 起始指针 * @param end 结束指针 */ public static void heapAdjust(int[] arr, int start, int end) { int temp = arr[start]; for(int i=2*start+1; i&amp;lt;=end; i*=2) { //左右孩子的节点分别为2*i+1,2*i+2 //选择出左右孩子较小的下标 if(i &amp;lt; end &amp;amp;&amp;amp; arr[i] &amp;lt; arr[i+1]) { i ++; } if(temp &amp;gt;= arr[i]) { break; //已经为大顶堆，=保持稳定性。 } arr[start] = arr[i]; //将子节点上移 start = i; //下一轮筛选 } arr[start] = temp; //插入正确的位置 } public static void heapSort(int[] arr) { if(arr == null || arr.length == 0) return ; //建立大顶堆 for(int i=arr.length/2; i&amp;gt;=0; i--) { heapAdjust(arr, i, arr.length-1); } for(int i=arr.length-1; i&amp;gt;=0; i--) { swap(arr, 0, i); heapAdjust(arr, 0, i-1); } } public static void swap(int[] arr, int i, int j) { int temp = arr[i]; arr[i] = arr[j]; arr[j] = temp; } }&lt;/pre&gt;&lt;/div&gt; 希尔排序 希尔排序是插入排序的一种高效率的实现，也叫缩小增量排序。简单的插入排序中，如果待排序列是正序时，时间复杂度是O(n)，如果序列是基本有序的，使用直接插入排序效率就非常高。希尔排序就利用了这个特点。基本思想是：先将整个待排记录序列分割成为若干子序列分别进行直接插入排序，待整个序列中的记录基本有序时再对全体记录进行一次直接插入排序。 举个栗子： 从上述排序过程可见，希尔排序的特点是，子序列的构成不是简单的逐段分割，而是将某个相隔某个增量的记录组成一个子序列。如上面的例子，第一堂排序时的增量为5，第二趟排序的增量为3。由于前两趟的插入排序中记录的关键字是和同一子序列中的前一个记录的关键字进行比较，因此关键字较小的记录就不是一步一步地向前挪动，而是跳跃式地往前移，从而使得进行最后一趟排序时，整个序列已经做到基本有序，只要作记录的少量比较和移动即可。因此希尔排序的效率要比直接插入排序高。 希尔排序的分析是复杂的，时间复杂度是所取增量的函数，这涉及一些数学上的难题。但是在大量实验的基础上推出当n在某个范围内时，时间复杂度可以达到O(n^1.3)。 实现代码： /* @Description:&lt;p&gt;希尔排序算法实现&lt;/p&gt; @author 王旭 @time 2016-3-3 下午10:53:55 */public class ShellSort { /** * 希尔排序的一趟插入 * @param arr 待排数组 * @param d 增量 */ public static void shellInsert(int[] arr, int d) { for(int i=d; i&amp;lt;arr.length; i++) { int j = i - d; int temp = arr[i]; //记录要插入的数据 while (j&amp;gt;=0 &amp;amp;&amp;amp; arr[j]&amp;gt;temp) { //从后向前，找到比其小的数的位置 arr[j+d] = arr[j]; //向后挪动 j -= d; } if (j != i - d) //存在比其小的数 arr[j+d] = temp; } } public static void shellSort(int[] arr) { if(arr == null || arr.length == 0) return ; int d = arr.length / 2; while(d &amp;gt;= 1) { shellInsert(arr, d); d /= 2; } } }&lt;/pre&gt;&lt;/div&gt; 归并排序 归并排序是另一种不同的排序方法，因为归并排序使用了递归分治的思想，所以理解起来比较容易。其基本思想是，先递归划分子问题，然后合并结果。把待排序列看成由两个有序的子序列，然后合并两个子序列，然后把子序列看成由两个有序序列。。。。。倒着来看，其实就是先两两合并，然后四四合并。。。最终形成有序序列。空间复杂度为O(n)，时间复杂度为O(nlogn)。 举个栗子： 实现代码： /* @Description:&lt;p&gt;归并排序算法的实现&lt;/p&gt; @author 王旭 @time 2016-3-4 上午8:14:20 */public class MergeSort { public static void mergeSort(int[] arr) { mSort(arr, 0, arr.length-1); } /** * 递归分治 * @param arr 待排数组 * @param left 左指针 * @param right 右指针 */ public static void mSort(int[] arr, int left, int right) { if(left &amp;gt;= right) return ; int mid = (left + right) / 2; mSort(arr, left, mid); //递归排序左边 mSort(arr, mid+1, right); //递归排序右边 merge(arr, left, mid, right); //合并 } /** * 合并两个有序数组 * @param arr 待合并数组 * @param left 左指针 * @param mid 中间指针 * @param right 右指针 */ public static void merge(int[] arr, int left, int mid, int right) { //[left, mid] [mid+1, right] int[] temp = new int[right - left + 1]; //中间数组 int i = left; int j = mid + 1; int k = 0; while(i &amp;lt;= mid &amp;amp;&amp;amp; j &amp;lt;= right) { if(arr[i] &amp;lt;= arr[j]) { temp[k++] = arr[i++]; } else { temp[k++] = arr[j++]; } } while(i &amp;lt;= mid) { temp[k++] = arr[i++]; } while(j &amp;lt;= right) { temp[k++] = arr[j++]; } for(int p=0; p&amp;lt;temp.length; p++) { arr[left + p] = temp[p]; } } }&lt;/pre&gt;&lt;/div&gt; 计数排序 如果在面试中有面试官要求你写一个O(n)时间复杂度的排序算法，你千万不要立刻说：这不可能！虽然前面基于比较的排序的下限是O(nlogn)。但是确实也有线性时间复杂度的排序，只不过有前提条件，就是待排序的数要满足一定的范围的整数，而且计数排序需要比较多的辅助空间。其基本思想是，用待排序的数作为计数数组的下标，统计每个数字的个数。然后依次输出即可得到有序序列。 实现代码： /* @Description:&lt;p&gt;计数排序算法实现&lt;/p&gt; @author 王旭 @time 2016-3-4 下午4:52:02 */public class CountSort { public static void countSort(int[] arr) { if(arr == null || arr.length == 0) return ; int max = max(arr); int[] count = new int[max+1]; Arrays.fill(count, 0); for(int i=0; i&amp;lt;arr.length; i++) { count[arr[i]] ++; } int k = 0; for(int i=0; i&amp;lt;=max; i++) { for(int j=0; j&amp;lt;count[i]; j++) { arr[k++] = i; } } } public static int max(int[] arr) { int max = Integer.MIN_VALUE; for(int ele : arr) { if(ele &amp;gt; max) max = ele; } return max; } }&lt;/pre&gt;&lt;/div&gt; 桶排序 桶排序算是计数排序的一种改进和推广，但是网上有许多资料把计数排序和桶排序混为一谈。其实桶排序要比计数排序复杂许多。 对桶排序的分析和解释借鉴这位兄弟的文章（有改动）：http://hxraid.iteye.com/blog/647759 桶排序的基本思想： 假设有一组长度为N的待排关键字序列K[1....n]。首先将这个序列划分成M个的子区间(桶) 。然后基于某种映射函数 ，将待排序列的关键字k映射到第i个桶中(即桶数组B的下标 i) ，那么该关键字k就作为B[i]中的元素(每个桶B[i]都是一组大小为N/M的序列)。接着对每个桶B[i]中的所有元素进行比较排序(可以使用快排)。然后依次枚举输出B[0]&#8230;.B[M]中的全部内容即是一个有序序列。bindex=f(key) 其中，bindex 为桶数组B的下标(即第bindex个桶), k为待排序列的关键字。桶排序之所以能够高效，其关键在于这个映射函数，它必须做到：如果关键字k1&lt;k2，那么f(k1)&lt;=f(k2)。也就是说B(i)中的最小数据都要大于B(i-1)中最大数据。很显然，映射函数的确定与数据本身的特点有很大的关系。 举个栗子： 假如待排序列K= {49、 38 、 35、 97 、 76、 73 、 27、 49 }。这些数据全部在1—100之间。因此我们定制10个桶，然后确定映射函数f(k)=k/10。则第一个关键字49将定位到第4个桶中(49/10=4)。依次将所有关键字全部堆入桶中，并在每个非空的桶中进行快速排序后得到如图所示。只要顺序输出每个B[i]中的数据就可以得到有序序列了。 桶排序分析： 桶排序利用函数的映射关系，减少了几乎所有的比较工作。实际上，桶排序的f(k)值的计算，其作用就相当于快排中划分，希尔排序中的子序列，归并排序中的子问题，已经把大量数据分割成了基本有序的数据块(桶)。然后只需要对桶中的少量数据做先进的比较排序即可。 对N个关键字进行桶排序的时间复杂度分为两个部分： (1) 循环计算每个关键字的桶映射函数，这个时间复杂度是O(N)。 (2) 利用先进的比较排序算法对每个桶内的所有数据进行排序，其时间复杂度为 ∑ O(Ni*logNi) 。其中Ni 为第i个桶的数据量。 很显然，第(2)部分是桶排序性能好坏的决定因素。尽量减少桶内数据的数量是提高效率的唯一办法(因为基于比较排序的最好平均时间复杂度只能达到O(N*logN)了)。因此，我们需要尽量做到下面两点： (1) 映射函数f(k)能够将N个数据平均的分配到M个桶中，这样每个桶就有[N/M]个数据量。 (2) 尽量的增大桶的数量。极限情况下每个桶只能得到一个数据，这样就完全避开了桶内数据的“比较”排序操作。当然，做到这一点很不容易，数据量巨大的情况下，f(k)函数会使得桶集合的数量巨大，空间浪费严重。这就是一个时间代价和空间代价的权衡问题了。 对于N个待排数据，M个桶，平均每个桶[N/M]个数据的桶排序平均时间复杂度为： O(N)+O(M*(N/M)*log(N/M))=O(N+N*(logN-logM))=O(N+N*logN-N*logM) 当N=M时，即极限情况下每个桶只有一个数据时。桶排序的最好效率能够达到O(N)。 总结： 桶排序的平均时间复杂度为线性的O(N+C)，其中C=N*(logN-logM)。如果相对于同样的N，桶数量M越大，其效率越高，最好的时间复杂度达到O(N)。 当然桶排序的空间复杂度 为O(N+M)，如果输入数据非常庞大，而桶的数量也非常多，则空间代价无疑是昂贵的。此外，桶排序是稳定的。 实现代码： /* @Description:&lt;p&gt;桶排序算法实现&lt;/p&gt; @author 王旭 @time 2016-3-4 下午7:39:31 */public class BucketSort { public static void bucketSort(int[] arr) { if(arr == null &amp;amp;&amp;amp; arr.length == 0) return ; int bucketNums = 10; //这里默认为10，规定待排数[0,100) List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; buckets = new ArrayList&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt;(); //桶的索引 for(int i=0; i&amp;lt;10; i++) { buckets.add(new LinkedList&amp;lt;Integer&amp;gt;()); //用链表比较合适 } //划分桶 for(int i=0; i&amp;lt;arr.length; i++) { buckets.get(f(arr[i])).add(arr[i]); } //对每个桶进行排序 for(int i=0; i&amp;lt;buckets.size(); i++) { if(!buckets.get(i).isEmpty()) { Collections.sort(buckets.get(i)); //对每个桶进行快排 } } //还原排好序的数组 int k = 0; for(List&amp;lt;Integer&amp;gt; bucket : buckets) { for(int ele : bucket) { arr[k++] = ele; } } } /** * 映射函数 * @param x * @return */ public static int f(int x) { return x / 10; } }&lt;/pre&gt;&lt;/div&gt; 基数排序 基数排序又是一种和前面排序方式不同的排序方式，基数排序不需要进行记录关键字之间的比较。基数排序是一种借助多关键字排序思想对单逻辑关键字进行排序的方法。所谓的多关键字排序就是有多个优先级不同的关键字。比如说成绩的排序，如果两个人总分相同，则语文高的排在前面，语文成绩也相同则数学高的排在前面。。。如果对数字进行排序，那么个位、十位、百位就是不同优先级的关键字，如果要进行升序排序，那么个位、十位、百位优先级一次增加。基数排序是通过多次的收分配和收集来实现的，关键字优先级低的先进行分配和收集。 举个栗子： 实现代码： /* @Description:&lt;p&gt;基数排序算法实现&lt;/p&gt; @author 王旭 @time 2016-3-4 下午8:29:52 */public class RadixSort { public static void radixSort(int[] arr) { if(arr == null &amp;amp;&amp;amp; arr.length == 0) return ; int maxBit = getMaxBit(arr); for(int i=1; i&amp;lt;=maxBit; i++) { List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; buf = distribute(arr, i); //分配 collecte(arr, buf); //收集 } } /** * 分配 * @param arr 待分配数组 * @param iBit 要分配第几位 * @return */ public static List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; distribute(int[] arr, int iBit) { List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; buf = new ArrayList&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt;(); for(int j=0; j&amp;lt;10; j++) { buf.add(new LinkedList&amp;lt;Integer&amp;gt;()); } for(int i=0; i&amp;lt;arr.length; i++) { buf.get(getNBit(arr[i], iBit)).add(arr[i]); } return buf; } /** * 收集 * @param arr 把分配的数据收集到arr中 * @param buf */ public static void collecte(int[] arr, List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; buf) { int k = 0; for(List&amp;lt;Integer&amp;gt; bucket : buf) { for(int ele : bucket) { arr[k++] = ele; } } } /** * 获取最大位数 * @param x * @return */ public static int getMaxBit(int[] arr) { int max = Integer.MIN_VALUE; for(int ele : arr) { int len = (ele+&quot;&quot;).length(); if(len &amp;gt; max) max = len; } return max; } /** * 获取x的第n位，如果没有则为0. * @param x * @param n * @return */ public static int getNBit(int x, int n) { String sx = x + &quot;&quot;; if(sx.length() &amp;lt; n) return 0; else return sx.charAt(sx.length()-n) - &#39;0&#39;; } }&lt;/pre&gt;&lt;/div&gt; 总结 在前面的介绍和分析中我们提到了冒泡排序、选择排序、插入排序三种简单的排序及其变种快速排序、堆排序、希尔排序三种比较高效的排序。后面我们又分析了基于分治递归思想的归并排序还有计数排序、桶排序、基数排序三种线性排序。我们可以知道排序算法要么简单有效，要么是利用简单排序的特点加以改进，要么是以空间换取时间在特定情况下的高效排序。但是这些排序方法都不是固定不变的，需要结合具体的需求和场景来选择甚至组合使用。才能达到高效稳定的目的。没有最好的排序，只有最适合的排序。 下面就总结一下排序算法的各自的使用场景和适用场合。 1. 从平均时间来看，快速排序是效率最高的，但快速排序在最坏情况下的时间性能不如堆排序和归并排序。而后者相比较的结果是，在n较大时归并排序使用时间较少，但使用辅助空间较多。 2. 上面说的简单排序包括除希尔排序之外的所有冒泡排序、插入排序、简单选择排序。其中直接插入排序最简单，但序列基本有序或者n较小时，直接插入排序是好的方法，因此常将它和其他的排序方法，如快速排序、归并排序等结合在一起使用。 3. 基数排序的时间复杂度也可以写成O(d*n)。因此它最使用于n值很大而关键字较小的的序列。若关键字也很大，而序列中大多数记录的最高关键字均不同，则亦可先按最高关键字不同，将序列分成若干小的子序列，而后进行直接插入排序。 4. 从方法的稳定性来比较，基数排序是稳定的内排方法，所有时间复杂度为O(n^2)的简单排序也是稳定的。但是快速排序、堆排序、希尔排序等时间性能较好的排序方法都是不稳定的。稳定性需要根据具体需求选择。 5. 上面的算法实现大多数是使用线性存储结构，像插入排序这种算法用链表实现更好，省去了移动元素的时间。具体的存储结构在具体的实现版本中也是不同的。 附：基于比较排序算法时间下限为O(nlogn)的证明： 基于比较排序下限的证明是通过决策树证明的，决策树的高度Ω（nlgn），这样就得出了比较排序的下限。 首先要引入决策树。 首先决策树是一颗二叉树，每个节点表示元素之间一组可能的排序，它予以京进行的比较相一致，比较的结果是树的边。 先来说明一些二叉树的性质，令T是深度为d的二叉树，则T最多有2^片树叶。 具有L片树叶的二叉树的深度至少是logL。 所以，对n个元素排序的决策树必然有n!片树叶（因为n个数有n!种不同的大小关系），所以决策树的深度至少是log(n!)，即至少需要log(n!)次比较。 而 log(n!)=logn+log(n-1)+log(n-2)+&#8230;+log2+log1 &gt;=logn+log(n-1)+log(n-2)+&#8230;+log(n/2) &gt;=(n/2)log(n/2) &gt;=(n/2)logn-n/2 =O(nlogn) 所以只用到比较的排序算法最低时间复杂度是O(nlogn)。 参考资料： 《数据结构》 严蔚敏 吴伟民 编著 桶排序分析：http://hxraid.iteye.com/blog/647759 部分排序算法分析与介绍：http://www.cnblogs.com/weixliu/archive/2012/12/23/2829671.html&lt;/ul&gt; var strBatchView = 37731","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://yoursite.com/categories/数据结构与算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/算法/"},{"name":"排序算法","slug":"排序算法","permalink":"http://yoursite.com/tags/排序算法/"}],"keywords":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://yoursite.com/categories/数据结构与算法/"}]}]}